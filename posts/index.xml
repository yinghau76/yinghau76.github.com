<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Simply Patrick</title>
    <link>https://blog.simplypatrick.com/posts/</link>
    <description>Recent content in Posts on Simply Patrick</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 02 Jan 2021 18:42:35 -0800</lastBuildDate><atom:link href="https://blog.simplypatrick.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>建置 Jupyter Notebook 的 Rust 運作環境</title>
      <link>https://blog.simplypatrick.com/posts/2021/01-02-rust-jupyter-notebook/</link>
      <pubDate>Sat, 02 Jan 2021 18:42:35 -0800</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2021/01-02-rust-jupyter-notebook/</guid>
      <description>最近重新安裝了 macOS Big Sur，也順便想試試 Jupyter Notebook 的 Rust 運作環境，再加上這幾天放假比較有時間，就把安裝的過程記錄下來。
安裝 Miniconda 過去一直覺得 Anaconda 有點肥大，所以這次決定先從安裝比較精簡的 miniconda 開始:
$ brew install --cask miniconda 新增 conda-forge channel 等下才能安裝一些需要的套件如 jupyterlab:
$ conda config --add channels conda-forge $ conda config --set channel_priority strict 然後需要初始化 conda 的 base 環境，一般都是跑 conda init，但它會加一段不是很通用的設定到我個人的 .zshrc，我不是很喜歡這種做法，所以就先只套用在目前的 shell 裡:
$ eval `conda shell.zsh hook` 創建新的 conda 環境 創建一個新的環境叫 rust-notebook:
(base) $ conda create -n rust-notebook python=3 (base) $ conda activate rust-notebook 安裝 JupyterLab 在新的環境指定安裝 jupyterlab 版本 2.</description>
    </item>
    
    <item>
      <title>看 log 的好工具: klogg</title>
      <link>https://blog.simplypatrick.com/posts/2019/12-25-klogg/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2019/12-25-klogg/</guid>
      <description>工作上常需要看 log 解決問題，推薦一個好用的工具 klogg:</description>
    </item>
    
    <item>
      <title>Setup Fuchsia Rust Development on macOS</title>
      <link>https://blog.simplypatrick.com/posts/2019/06-06-setup-fuchsia-rust-dev/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2019/06-06-setup-fuchsia-rust-dev/</guid>
      <description>基本上照著官方的指引 Rust Editor Configuration，設置 Fuchsia OS 開發的 Rust 開發環境主要就兩個步驟:
 產生 Cargo.toml 設定編輯器使用 Rust 的 Language Server (RLS)  產生 Cargo.toml 很簡單，就是用 fx gen-cargo //garnet/foo/path/to/target:label 產生對應的 Cargo.toml。例如 fx gen-cargo //garnet/bin/log_listener:bin 會產生 /garnet/bin/log_listener/Cargo.toml。
設定 RLS 官方文檔提到要先把 Fuchsia 自帶的 Rust 連結到 rustup，並且設成預設的 toolchain:
$ rustup toolchain link fuchsia /&amp;lt;your Fuchsia root&amp;gt;/buildtools/&amp;lt;platform&amp;gt;/rust $ rustup default fuchsia 我是有做第一步，但第二步我比較持保留態度，之後試過似乎不做也沒影響，我會建議跳過這一步。
Vim 跟 C++ 類似，只是 Language Server 我們必須從 clangd 換成 RLS，所以可以在 Vim 裡用 :CocInstall coc-rls 來安裝 coc-rls extension，如果你系統之前就有裝過 RLS 的話，在 Vim 裡打開對應的目錄就會有 code completion 的功能了。</description>
    </item>
    
    <item>
      <title>Setup Fuchsia C&#43;&#43; Development on macOS</title>
      <link>https://blog.simplypatrick.com/posts/2019/06-05-setup-fuchsia-c&#43;&#43;-dev/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2019/06-05-setup-fuchsia-c&#43;&#43;-dev/</guid>
      <description>關於 Fuchsia Fuchsia 是 Google 開發中的新作業系統，它的底層原始碼可以到 https://fuchsia.googlesource.com 公開下載。雖然 Google 對外宣稱 Fuchsia 是個實驗性質的專案，但蠻多人認為它有潛力成為 Google 的大一統 OS，慢慢取代掉 Android 或 Chrome OS，姑且不論這是否會發生，對於喜歡研究系統軟體或嵌入式軟體技術的開發人員，Fuchsia 可以讓你一窺如何打造一個現代化的 OS。
Fuchsia 的開發環境 目前 Fuchsia OS 可以在 Linux 或 macOS 上編譯，這篇主要是分享在 macOS 上建置 C++ 的 OS 開發環境的經驗，包括:
 基本的編輯器 (Vim 及 Visual Studio Code) 設置 Code completion 的設置 使用 direnv 來實現設置自動化  編輯器選擇 我的環境建置基本是根據這份官方提供的 C++ Editor/IDE Setup 指南，裡面有提到 CLion, Vim, 以及 Visual Studio Code，試用過後個人推薦 Vim &amp;gt; VS Code &amp;raquo; CLion，主要還是因為個人開發時通常只會需要修改全部 code base 的極小一部份，小巧的編輯器使用體驗會比較流暢，也不會耗用太多的機器資源去處理不會修改的部份。</description>
    </item>
    
    <item>
      <title>Learning Rust</title>
      <link>https://blog.simplypatrick.com/posts/2019/04-08-learning-rust/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2019/04-08-learning-rust/</guid>
      <description>關於 Rust 會知道 Rust 是因為之前公司團隊的工作是跟瀏覽器引擎 (Webkit/Blink) 的優化有關，那時只知道 Mozilla 正在用 Rust 這個新的程式語言實驗性地開發 Servo 引擎。同時間 Go 已經到達 1.0 的里程碑，同時有著優異的編譯及執行效能，很快地 Go 就變成我個人主要使用的程式語言，工作上需要的一些小工具也都是用 Go 來實現。
開始對 Rust 重新關注大概是它在 2015 年釋放 1.0 版本後，那時只稍微了解一下語法及主要的語言特性，當時覺得這程式語言的學習曲線蠻陡峭的，必須全面地對所有的語言特性有一定了解後才能駕馭它。那時 Go 用的正是順手，所以就沒什麼動力把 Rust 完整學起來。
去年開始工作上需要了解 Fuchsia OS 的實作，赫然發現裡面蠻多系統服務都是用 Rust 開發的，數量上甚至比 Google 自家的 Go 還多，這也是我決定多投入時間學習 Rust 的轉捩點。
學習資源 我主要使用下列幾本書來學習 Rust：
 深入浅出 Rust 這本書的電子版: 它的特色是側重於解釋 Rust 主要概念的設計思想，而不只是單純語法或用法的說明；且因為是中文的緣故，讀起來速度還是比較快，比較像是 Rust 的內功心法入門。 30 天深入淺出 Rust 系列 則是以淺顯易懂的範例把 Rust 主要的特色講解了一遍，內容適合對於想要快速地對 Rust 有個全面性的概觀的人。 對 Rust 有了基本的了解後，A Gentle Introduction to Rust 則是適合有 C/C++ 經驗的開發者來學習如何寫 idiomatic Rust。  至於最經典的 The Rust Programming Language 呢?</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 套件管理: 使用 Conan</title>
      <link>https://blog.simplypatrick.com/posts/2018/03-12-c&#43;&#43;-conan/</link>
      <pubDate>Sun, 11 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2018/03-12-c&#43;&#43;-conan/</guid>
      <description>手動管理 C/C++ 套件 想像你需要使用 LLVM 開發一個程式，如果在 macOS 上，最簡單的安裝方法是用 Homebrew，一行就搞定: brew install llvm。但 Homebrew 上的版本不一定是最新的而且也無法同時安裝不同的版本 (例如 LLVM 5.0/6.0 共存) 或同版本但不同設置（例如 LLVM 6.0 的 debug/release 版本)；而在 Linux 及 Windows 上也有各自不同的安裝問題。
安裝完畢後，麻煩才剛開始：通常第一步是設置編譯環境的 CPPFLAGS 及 LDFLAGS:
For compilers to find this software you may need to set: LDFLAGS: -L/usr/local/opt/llvm/lib CPPFLAGS: -I/usr/local/opt/llvm/include 根據不同的開發環境或編譯器，設置的方法也都不同。最後設置完後編譯及連結也不一定能成功，因為 LLVM 本身可能又依賴其他套件，還需要把它的 dependencies 一一安裝及設置。
Conan 介紹 Conan 企圖幫助 C/C++ 脫離這個窘境：沒有一個像樣的套件管理 (package management) 工具。
我建議先讀一下 Conan 的文檔來了解如何安裝 Conan 以及利用 Conan 來使用現成的程式庫。
如果你是使用 CMake，事情會簡單一些，因為 Conan 提供的 CMake 整合還算好用，使用範例可以參考這個基於 LLVM 的小程式: clike。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 單元測試: 使用 Catch2</title>
      <link>https://blog.simplypatrick.com/posts/2018/03-10-catch2/</link>
      <pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2018/03-10-catch2/</guid>
      <description>Catch2 介紹 介紹一下最近有在使用的一個 C++ test framework, Catch2，它對自己的描述是:
 A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or C++03 on the Catch1.x branch)
 我主要的用途是做一些 C++ 小程式的簡單驗證，因此簡單易用是我首要的選擇條件，而 Catch2 應該是目前找的到最好的選擇，例如這是個 Huffman coding 的測試代碼:
TEST_CASE(&amp;#34;HuffmanEncoding&amp;#34;) { vector&amp;lt;Symbol&amp;gt; symbols{ {&amp;#39;a&amp;#39;, 8.17}, {&amp;#39;b&amp;#39;, 1.49}, {&amp;#39;c&amp;#39;, 2.78}, {&amp;#39;d&amp;#39;, 4.25}, {&amp;#39;e&amp;#39;, 12.7}, {&amp;#39;f&amp;#39;, 2.23}, {&amp;#39;g&amp;#39;, 2.02}, {&amp;#39;h&amp;#39;, 6.09}, {&amp;#39;i&amp;#39;, 6.97}, {&amp;#39;j&amp;#39;, 0.15}, {&amp;#39;k&amp;#39;, 0.77}, {&amp;#39;l&amp;#39;, 4.03}, {&amp;#39;m&amp;#39;, 2.</description>
    </item>
    
    <item>
      <title>Kotlin Coroutines and Threads</title>
      <link>https://blog.simplypatrick.com/posts/2018/02-14-kotlin-coroutines-and-threads/</link>
      <pubDate>Wed, 14 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2018/02-14-kotlin-coroutines-and-threads/</guid>
      <description>Coroutine 跟 thread 的關係 Coroutine 通常可以理解成輕量化的 thread，但實際運作還是需要被排程到作業系統層級的 thread，然後再被排程到某個 CPU來執行：
相對於 thread，使用 coroutine 的好處是， coroutine 之間的切換快速，需要耗用的系統資源也比較小。
Coroutine 如何排程？ Kotlin 的 coroutine 會被分派到那個 thread 是由呼叫 coroutine builder 時提供的 CoroutineContext 參數來決定。
透過觀察這個範例的輸出，我們可以了解不同 CoroutineContext 的行為：
class CoroutineContextActivity : ConsoleActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) logThread(&amp;#34;Begin onCreate&amp;#34;) launch(UI) { logThread(&amp;#34;Begin launch(UI)&amp;#34;) delay(10_000) logThread(&amp;#34;End launch(UI)&amp;#34;) } launch(CommonPool) { logThread(&amp;#34;Begin launch(CommonPool)&amp;#34;) delay(10_000) logThread(&amp;#34;End launch(CommonPool)&amp;#34;) } launch(Unconfined) { logThread(&amp;#34;Begin launch(Unconfined)&amp;#34;) delay(10_000) logThread(&amp;#34;End launch(Unconfined)&amp;#34;) } launch(newSingleThreadContext(&amp;#34;MyOwnThread&amp;#34;)) { logThread(&amp;#34;Begin launch(newSingleThreadContext)&amp;#34;) delay(10_000) logThread(&amp;#34;End launch(newSingleThreadContext)&amp;#34;) } logThread(&amp;#34;End onCreate&amp;#34;) } fun logThread(msg: String) { println(&amp;#34;$msg: ${Thread.</description>
    </item>
    
    <item>
      <title>Kotlin Coroutine API</title>
      <link>https://blog.simplypatrick.com/posts/2018/02-13-kotlin-coroutines-api/</link>
      <pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2018/02-13-kotlin-coroutines-api/</guid>
      <description>Kotlin Coroutine 的架構 Kotlin 從 1.1 版開始實驗性地支援 coroutine，主要的目標是簡化非同步編程的複雜度。Diving deep into Kotlin Coroutines 解釋了 coroutine 跟一般常用的 callback 及目前蠻多人在用的 reactive 模式有何不同。
由於目前 kotlinx-coroutines-core 的實現包含了不同抽象程度的 API，初學者建議可以用下面這張圖來學習如何使用 Kotlin coroutine：
範例分析 套用下面這個範例來理解:
suspend fun sendEmail(r: String, msg: String): Boolean { // 3  delay(2000) // 4  println(&amp;#34;Sent &amp;#39;$msg&amp;#39; to $r&amp;#34;) return true } suspend fun getReceiverAddressFromDatabase(): String { // 3  delay(1000) // 4  return &amp;#34;coroutine@kotlin.org&amp;#34; } suspend fun sendEmailSuspending(): Boolean { // 3  val msg = /* 1 */ async(CommonPool) { // 2  delay(500) &amp;#34;The message content&amp;#34; } val recipient = /* 1 */ async(CommonPool) { // 2  getReceiverAddressFromDatabase() } println(&amp;#34;Waiting for email data&amp;#34;) val sendStatus = /* 1 */ async(CommonPool) { // 2  sendEmail(recipient.</description>
    </item>
    
    <item>
      <title>Devdocs Desktop</title>
      <link>https://blog.simplypatrick.com/posts/2018/01-22-devdocs-desktop/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2018/01-22-devdocs-desktop/</guid>
      <description>寫(code)之前先讀(API) 當一個軟體開發者，需要花蠻多時間來閱讀文檔以便了解如何使用某個 API 以及各種情況下它會表現的行為，因此學習如何有效率地查詢及閱讀了解 API 是蠻重要的能力。基本上如果某個 library 是你工作上常用到的，我會建議你從頭到尾把所有文件至少讀一遍，而不是需要用到時才去查。
Dash 好用，但是&amp;hellip; 在 macOS 上，我過去是習慣使用 Dash 這工具來查詢 API，一是它整合了蠻多常用的 API 文檔，二來它查詢的速度還不錯，就個人使用上算是很好的投資，所以當時就在 App Store 買了正式版。然而好景不常，當 Dash 3 出來後，2.x 版本就常發生文件顯示不出來的問題，讓我有點惱火:angry:，這樣的品質再加上發生 被 App Store 下架 的事件，要我再付錢買 3.x 版本是不可能的事。
Zeal 是 Linux 或 Windows 上不錯的選擇 之前找到比較好的替代方案是 Zeal, 但是 Zeal 的 docset 是 Dash 提供的，道義上不能跟 Dash 打對台，因此官方並不提供 macOS 的版本。建議的解決方案是用 Wine 在 macOS 上執行 Windows 版本的 Zeal，我試過是可行的，搞定一些小問題後運作上還算正常。
devdocs.io 更棒 另一個更好的選擇是 devdocs.io，無須安裝直接網頁打開就可查詢。想要 desktop 版本? 沒問題! 這種網站最適合用 Electron 來包了: DevDocs Desktop。這是我目前最推薦的 API 文檔工具，跨 macOS, Linux, Windows 都可以使用且免費，太佛心了。</description>
    </item>
    
    <item>
      <title>Better Way to Request Runtime Permissions</title>
      <link>https://blog.simplypatrick.com/posts/2016/05-30-requesting-runtime-permission/</link>
      <pubDate>Mon, 30 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2016/05-30-requesting-runtime-permission/</guid>
      <description>If you are an Android developer, you definitely know an important change beginning in Android 6.0 (API 23) is run time permission: users grant permissions to apps while the app is running, not when they install the app. This official training guide explains clearly how you can check for permission and request them at runtime.
Let me list the sample code in the training guide so that you can understand what improvements I would like to do with them:</description>
    </item>
    
    <item>
      <title>The Elements of Good Commit Messages</title>
      <link>https://blog.simplypatrick.com/posts/2016/05-12-the-elements-of-good-commit-messages/</link>
      <pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2016/05-12-the-elements-of-good-commit-messages/</guid>
      <description>通常從 commit messages 就可以看出一個軟體開發團隊是否有紀律、注重品質、並且彼此溝通良好。
 The importance of commit messages Crafting Commits and the Importance of Commit Messages Why commit messages matter  如何寫好 commit message 這是我去年在公司內部做的一個 presentation，目的是讓大家知道要在 commit message 寫那些東西:
 負面範例 請至少避免寫這些沒有意義的 commit message。</description>
    </item>
    
    <item>
      <title>在 Android 上使用 OpenCV 的臉部偵測及辨識</title>
      <link>https://blog.simplypatrick.com/posts/2016/03-05-face-detection-with-opencv-on-android/</link>
      <pubDate>Sat, 05 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2016/03-05-face-detection-with-opencv-on-android/</guid>
      <description>兩年多前研究了一下在 Android 上如何用 OpenCV 做臉部偵測及辨識。主要的使用情境如下圖:
因為輸入來源是攝影機的視訊，當時的想法是初步的偵測及辨識還是由裝置執行，比較複雜的計算再上傳到 server 執行：
這幾年許多大廠例如 Google, Facebook, 及 Microsoft 都積極投入發展人工智慧及臉部辨識技術，現在臉部辨識已經是 Mobile OS 上的必備功能:
 Face API of Microsoft Project Oxford Face API of Mobile Video from Google Detecting Faces in an Image on Apple iOS  當時只是簡單弄了一個 prototype，現在回頭看，大致上設計沒有差太多，倒是 API 設計上可以多跟人家學習學習:
public class Tracker&amp;lt;T&amp;gt; { public Tracker() {} public void onNewItem(int id, T item) {} public void onUpdate(Detections&amp;lt;T&amp;gt; detections, T item) {} public void onMissing(Detections&amp;lt;T&amp;gt; detections) {} public void onDone() {} } </description>
    </item>
    
    <item>
      <title>Redesign Listener with RxJava on Android</title>
      <link>https://blog.simplypatrick.com/posts/2016/03-04-using-rxjava-on-android/</link>
      <pubDate>Fri, 04 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2016/03-04-using-rxjava-on-android/</guid>
      <description>Background In my Android app, I used the following typical Listener pattern to monitor updates from models:
public interface Listener { void onUpdate(List&amp;lt;Item&amp;gt; list); } public interface Model { void addListener(Listener l); void removeListener(Listener l); } Listeners are implemented by several Fragments that expect update notifications coming from a global model object. The updating may be triggered manually by user or periodically by a scheduler.
After learning RxJava, I would like to simplify the model interface and at the same time remove the boilerplate of maintaining listener list in model implementation:</description>
    </item>
    
    <item>
      <title>Running Android Studio with Custom JDK</title>
      <link>https://blog.simplypatrick.com/posts/2016/02-28-running-android-studio-with-custom-jdk/</link>
      <pubDate>Sun, 28 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2016/02-28-running-android-studio-with-custom-jdk/</guid>
      <description>IntelliJ is certainly the best Java IDE ever. However, IntelliJ-based Android Studio really bothers me much because it fails to render font antialiasing correctly compared with older version on OS X:
Google&amp;rsquo;s suggestion to this issue is to use Oracle JDK 1.6 but I don&amp;rsquo;t like the idea to stick with out-of-dated JDK.
Recently IntelliJ 15 fixed this issue by bundling custom JDK. After realizing the same fix is probably not on the priority list of Android Studio 2.</description>
    </item>
    
    <item>
      <title>GN (Generate Ninja) 使用入門</title>
      <link>https://blog.simplypatrick.com/posts/2016/01-23-gn/</link>
      <pubDate>Sat, 23 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2016/01-23-gn/</guid>
      <description>2018/06/30 補充: Brett Wilson 的 Using GN build 是我目前看過對 GN 最棒的介紹，強力推薦!
好久之前介紹過 Ninja, 當時有提到 Ninja 通常是搭配 meta-build system (例如 CMake 或是 GYP) 來使用，這次要介紹的 GN 則是 Chromium project 用來取代 GYP 的新工具。
由於 GN 是用 C++ 撰寫，比起用 Python 寫的 GYP 快了將近 20 倍，GN 新的 DSL 的語法也被認為是比較好讀及維護的。
安裝 GN 由於 gn 目前還依賴 Chromium 裡的一些函式庫，目前比較方便的方式還是從 source 編譯，Linux/Mac 上可以依照下列步驟：
 基本範例 建立 .gn 在 source project 的根目錄新增一個 .gn 檔，內容如下：
 .gn 檔所在的目錄會被 GN 工具認定是 project 的 source root，.</description>
    </item>
    
    <item>
      <title>CMake 筆記</title>
      <link>https://blog.simplypatrick.com/posts/2015/06-19-cmake-notes/</link>
      <pubDate>Fri, 19 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2015/06-19-cmake-notes/</guid>
      <description>動機 因爲某種原因，我最近又開始寫起 C++ 程式，除了要熟悉 C++ 11/14 的新特性外，比較頭疼的是 Makefile 的撰寫。
C/C++ 開發者了解基本的 Makefile 寫法是有必要的，但是大多數情況下，我認為使用 autotools 或是 CMake 這類 Makefile generator 是比較合理的選擇，因爲這些工具可以幫你產生出專家等級的 Makefile 並且處理可能的跨平台問題。至於 autotools 或是 CMake 的選擇，對我來說是很明顯的：autotools 是出了名的難用，而 CMake 是相對容易的。
本文嘗試整理一些網路上的 CMake 教學資源，並且加上自己的一些心得。
CMake 入門 我會建議先看 Eric Noulard 的 CMake tutorial presentation，相當地棒：
 然後你會需要實際動手演練一下，有下面幾個選擇：
 CMake 官網上的基本範例：文字說明比較少，但可以讓你先感覺一下 CMake 的運作方式。我自己根據這個範例建了這個 GitHub project 來練習。 維基教科書上的 CMake 入門 John Lamp 的 CMake Tutorial 提供了一個更實際的範例讓你練習，並且詳細解釋了每一行用到的 CMake 指令。  CMake 基礎知識 再來就是要花時間把官網的這篇 cmake-buildsystem(7) 讀一讀，有幾個重點要搞懂：
 如何使用 add_library 及 add_executable 來新增 build target － 了解 STATIC, SHARED, MODULE, 以及 OBJECT library 的差異 了解 build specification:  INCLUDE_DIRECTORIES, COMPILE_DEFINITIONS 以及 COMPILE_OPTIONS 的意義   了解 usage requirement:  INTERFACE_INCLUDE_DIRECTORIES, INTERFACE_COMPILE_DEFINITIONS 及 INTERFACE_COMPILE_OPTIONS 的意義   如何使用 target_include_directories(), target_compile_definitions() 及 target_compile_options() 來修改 build specification 及 usage requirement  了解 PRIVATE, PUBLIC 及 INTERFACE mode 的差異 跟 directory-scoped 命令的差異: include_directories(), add_definitions(), 及 add_compile_options()   常用的內建變數  CMAKE_CURRENT_SOURCE_DIR CMAKE_CURRENT_BINARY_DIR   如何使用 set_target_properties 來修改 target property 了解 generator expression 的用法  上面提到的這些重要觀念可以參考 Introduction to CMake in 30 Minutes 的說明。</description>
    </item>
    
    <item>
      <title>About Code Review</title>
      <link>https://blog.simplypatrick.com/posts/2015/06-12-about-code-review/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2015/06-12-about-code-review/</guid>
      <description>著重品質及效率的軟體開發團隊一定會做 code review，因為它是開發流程裡唯一讓開發人員有機會針對代碼進行深入討論的關鍵活動。
因爲不同的團隊會用不同的方式執行 code review，並沒有一套固定的方法可以適用所有情況，所以我試著根據過去的經驗，整理我心中認為理想的 code review 運作方式。
要用什麼工具？ 我認為使用 code review system 這類的工具是必須的，否則管理版本修改 (patches) 或是追蹤 reviewer 給的建議 (comments) 就會太過費力，反而削減了 code review 帶來的好處。
免費的選擇我會推薦 Gerrit 或是 Phabricator ，架設其實都蠻簡單的。
Gerrit 的使用建議可以參考：
 Gerrit and Code Review Best Practices Gerrit Best Practices  Review 那些東西？ 以下是我認為除了 bug 以外需要檢查的部分，依照重要程度列舉如下：
 符合原始架構設計 API 設計 易讀性及可維護性 安全性 代碼風格  有幾個原則可以遵循：
 團隊應該有一致的代碼標準 (coding standards)，這樣比較不會有爭議。 盡量使用代碼檢查工具 (static analysis) 來代替人工的檢查。 善用 astyle 或是 uncrustify 這類的 code formatting 工具來維持代碼風格的一致性。  如何有效溝通？  Commit message 很重要，好的 commit message 可以讓 review 快速理解為什麼這個改動是必要的。 Review 的改動不應該太大，一次改個上千行是很難仔細檢查的，所以 reviewer 有權利退回太大的改動。   Ask a programmer to review 10 lines of code, he&amp;rsquo;ll find 10 issues.</description>
    </item>
    
    <item>
      <title>Using OpenGrok on Mac OS X</title>
      <link>https://blog.simplypatrick.com/posts/2015/01-16-opengrok-on-mac-osx/</link>
      <pubDate>Fri, 16 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2015/01-16-opengrok-on-mac-osx/</guid>
      <description>OpenGrok is Awesome OpenGrok is an awesome and handy tool for analyzing complex software system. As it claims, it is a fast source code search and cross reference engine using famous Lucene. For Android developers, you may have known AndroidXref which is built using OpenGrok.
This short guide shows a minimized steps to get OpenGrok up and running on Mac OS X. I prefers this kind of quick-and-dirty way for browsing source code on my desktop or laptop.</description>
    </item>
    
    <item>
      <title>Useful Go Channel Types</title>
      <link>https://blog.simplypatrick.com/posts/2014/05-05-golang-channels/</link>
      <pubDate>Mon, 05 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/05-05-golang-channels/</guid>
      <description>CloudFlare 的 John Graham-Cumming 在 GopherCon 2014 給了一個 A Channel Compendium 的演講，其中介紹了:
 利用 channel 來通知事件 (Signalling) 利用 channel 來隱藏狀態 (Hide state) Nil channels 及 closed channels 的特性 利用 channel 來實現 timer  整個 talk 的結尾下的非常好：
 The Go Way: &amp;ldquo;small sequential pieces joined by channels&amp;rdquo;
 可以說 Go 的重點特色就是 concurrency programming 的支援，而善用 channel 則是實現 concurrency 的重要能力。
對於剛接觸 go concurrency programming 的開發者，分享一下兩個簡單但好用的 channel 類型: channel of error 及 channel of function。</description>
    </item>
    
    <item>
      <title>RubyMotion v.s. Xcode &#43; Objective-C</title>
      <link>https://blog.simplypatrick.com/posts/2014/03-27-rubymotion-vs-xcode-objective-c/</link>
      <pubDate>Thu, 27 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/03-27-rubymotion-vs-xcode-objective-c/</guid>
      <description>優點 RubyMotion 的優點說穿了就是儘量讓你不會碰到 Objective-C, Xcode, 及 iOS API 的摧殘：
使用 Ruby 語法 應該不是只有我覺得 Objective-C 的語法很醜，Cocoa/iOS 的 API 也都是囉嗦的長， 但相對地 Ruby 就有漂亮易讀的語法及好用的內建 library。
與其要寫：
NSMutableArray *array = [NSMutableArray arrayWithObjects: @&amp;#34;one&amp;#34;, @&amp;#34;two&amp;#34;, @&amp;#34;three&amp;#34;, @&amp;#34;four&amp;#34;, nil]; NSArray *newAdditions = [NSArray arrayWithObjects: @&amp;#34;a&amp;#34;, @&amp;#34;b&amp;#34;, nil]; NSIndexSet *indexes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(1,newAdditions.count)]; [array insertObjects:newAdditions atIndexes:indexes]; 我更喜歡寫：
array = %w{one two three four} newAdditions = %w{a b} array.insert(1, *newAdditions) 可利用 RubyMotion gems 在 RubyMotion Wrappers 可以找到許多專爲 RubyMotion 設計的 gem，通常是把 iOS API 或是有名 的 library (例如 AFNetworking 或 Cocos2D) 包裝成 Ruby 的慣用方式，例如 SugarCube 可以把：</description>
    </item>
    
    <item>
      <title>Book for Golang Learning</title>
      <link>https://blog.simplypatrick.com/posts/2014/03-19-go-book/</link>
      <pubDate>Wed, 19 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/03-19-go-book/</guid>
      <description>學習一個新的程式語言我習慣先看網路上的 tutorial 或 get started guide 入門，然後用看官方文件或是搜索網路資源的方式來學習，等到有了手感後，就會找本好的書來進一步提昇自己的程度，用畫的來表示大概是這樣：
就學習 Go 而言，我認爲那本書就是 Mark Summerfield 的 Programming in Go: Creating Applications for the 21st Century:
這本書不適合程式設計的初學者，而是適合已經精通其它程式語言的開發者。例如一般的 if 及 for 的用法直到第五章才有詳細介紹，但對有經驗的開發者絕對是 OK 的。
我推薦的原因是書中的範例程式都很高水準，看得出來是作者精心設計過的，示範如何用 Go 來解決實際會遇到的問題，解法都很漂亮並符合 Go 的風格。這種採用最佳示範的方法可以讓你快速學會 Go 的精華而不是一直停留在初學者階段。
另外書中也有提供了不少有用的建議做法：
 實現可選參數的推薦做法 實現泛型的替代做法 常用的並發模式  這本書也有簡中翻譯版本可以買，有一些翻譯、排版、拼字錯誤，但整體來說翻譯品質還不錯，不會影響你對 Go 的學習。</description>
    </item>
    
    <item>
      <title>第一次在淘寶上買書</title>
      <link>https://blog.simplypatrick.com/posts/2014/03-18-buying-books-in-taobao/</link>
      <pubDate>Tue, 18 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/03-18-buying-books-in-taobao/</guid>
      <description>分享一下在淘寶買書寄回臺灣的經驗。
之前到大陸出差就有到當當網買書的經驗，都是用貨到付款的方式。這次想寄回台灣，但當當網只有大陸當地的支付方式，所以就想試試看淘寶，因爲淘寶使用的支付寶是支援海外信用卡交易的，只是好像會被銀行收取海外交易手續費。
我想買的書主要是軟體開發相關技術書籍的中譯本，一來是比原文便宜，二來現在簡中翻譯的質量也都不錯，缺點就是書的用紙都是比較差的。
怎麼買呢？先上淘寶旗下的天貓直接搜尋你想買的書，我是選有包郵然後價格最低的：
這次我選了六本書，有一家因爲只剩一本但是破損了，經過用阿里旺旺聯繫後就取消交易：
選完書後結帳時，淘寶有個很貼心的功能就是合併快遞，貨物可以通通寄到轉運商那裡再一起轉運回臺灣。 我選擇的轉運商全家 PRoute，算算平均一本書運回台灣的成本是台幣 50 元：
所以這些包裹就會從大陸各地寄到深圳：
然後坐船到台灣，整個過程看起來可以在一到兩周內完成。：
收貨時全家送了一杯咖啡：</description>
    </item>
    
    <item>
      <title>RubyMotion</title>
      <link>https://blog.simplypatrick.com/posts/2014/03-16-rubymotion/</link>
      <pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/03-16-rubymotion/</guid>
      <description>使用 RubyMotion 來撰寫 iOS app 已經有一年多的時間，踩了不少坑後有了一些小心得可以分享，目前想到的題目有：
 相較於用 Xcode 開發的優缺點 RubyMotion Rakefile 的使用 與 Xcode 搭配的方法 開發環境的設定 推薦閱讀的書 用 Ruby 風格來架構 app Crash report 的機制 推薦使用的 gem 其他推薦閱讀&amp;hellip;  有一個需要先釐清的是：使用 RubyMotion 不表示你可以不用懂 Objective-C 及 Cocoa Touch， 相反地，學習原生 iOS 開發的方法對於有效駕馭 RubyMotion 是必要的。
有興趣的人可以先聽聽 Joseph Ku 在 TechTalk@TW 的專訪。另外也可以看 Jim Weirich 在 CincyCocoaDev 對 RubyMotion 的介紹：</description>
    </item>
    
    <item>
      <title>Page Scrapping By Go</title>
      <link>https://blog.simplypatrick.com/posts/2014/01-07-page-scrapping-by-go/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/01-07-page-scrapping-by-go/</guid>
      <description>分享一下怎麼用 Go 爬網頁：
先 import 之後步驟會用到的 package:
import( &amp;#34;code.google.com/p/cascadia&amp;#34; &amp;#34;code.google.com/p/go.net/html&amp;#34; &amp;#34;code.google.com/p/go.text/encoding/traditionalchinese&amp;#34; &amp;#34;code.google.com/p/go.text/transform&amp;#34; ) 第一步當然是用 http.Get 把網頁抓回來：
resp, err := http.Get(url) if err != nil { log.Println(&amp;#34;Failed to download:&amp;#34;, err.Error()) return } defer resp.Body.Close() 第二步: 如果網頁內容不是 UTF-8 encoding 要做一下轉換，go.text 包有提供編碼轉換及 Big 的支援，然後用 go.net/html 包提供的 HTML parser 來輸出(非標準) DOM tree：
big5Reader := transform.NewReader(resp.Body, traditionalchinese.Big5.NewDecoder()) doc, err := html.Parse(big5Reader) if err != nil { log.Println(&amp;#34;Failed to parse:&amp;#34;, err.Error()) return } 再來要從 doc 中撈出資訊則可以使用 cascadia 包提供的 CSS selector 來做：</description>
    </item>
    
    <item>
      <title>Using Native Libraries in Android</title>
      <link>https://blog.simplypatrick.com/posts/2014/01-04-using-native-libraries-in-android/</link>
      <pubDate>Sat, 04 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2014/01-04-using-native-libraries-in-android/</guid>
      <description>基本概念 開發 Android app 如果需要使用 native library，簡單地說其實不複雜，就是把 .so 檔放到 lib/&amp;lt;abi&amp;gt; 目錄，然後不管你是用 Eclipse ADT, Ant, 或是 Gradle 來產生 APK, 這些工具都會把這些 .so 包到 .apk 裡面，然後這些 .so 就可以在運作時期用 System.loadLibrary 或是 System.load 來載入。
接下來說明幾個常見的 .so 產生及載入方式：
使用 NDK 如果是自己開發自己使用，通常建議用 Android NDK，只要一個 ndk-build 命令就可以將 jni/ 目錄裡的 C/C++ code 編譯成 libs/&amp;lt;abi&amp;gt;/ 裡的 lib&amp;lt;name&amp;gt;.so。
載入方式就是直接使用 System.loadLibrary。
Third-party library 但如果角色換成是要提供 library 給 App 開發者使用，方法就比較多樣一點：
jni/ + src/ 也就是直接給 JNI 及 Java code 由 App 開發自己整合。
Library Project 如果你要提供的 library 有自帶的 resource，這是目前唯一可以用的方式。把 .</description>
    </item>
    
    <item>
      <title>Go on Heroku</title>
      <link>https://blog.simplypatrick.com/posts/2013/12-15-go-on-heroku/</link>
      <pubDate>Sun, 15 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2013/12-15-go-on-heroku/</guid>
      <description>要將 Go app 放到 Heroku 上執行基本上並不複雜，只要依照這篇 Getting Started With Go on Heroku 一步一步照著做就行了，如果出了問題可以查一下是否是下列幾個原因造成的：
 .godir 要設定成你的 package 路徑，例如你的程式是放在 $GOPATH/src/simplypatrick/flights，那 package 路徑就是 simplypatrick/flights。 Procfile 裡的 web:  後面是接執行檔的路徑，我目前試驗的結果是放在 bin/ 裡面，所以以我的例子要設定成 web: bin/flights Heroku 目前預設好像都不會把 web process 跑起來，所以需要執行 heroku ps:scale web=1 來啟動 web process。  話說回來，目前 Heroku 目前並沒有正式支援 Go，目前能夠放 Go app 上去跑其實是透過 custom buildpack 完成的。要怎麼創建自己的 buildpack 可以參考 Run Anything on Heroku with Custom Buildpacks，例如前面例子的 Go buildpack 是用 Go 1.1.2，如果你想改成用 Go 1.2 可以自己 fork 一份 buildpack 來改。</description>
    </item>
    
    <item>
      <title>My Go Development Environment</title>
      <link>https://blog.simplypatrick.com/posts/2013/12-14-my-go-development-environment/</link>
      <pubDate>Sat, 14 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2013/12-14-my-go-development-environment/</guid>
      <description>分享一下我的 Go 開發環境。
作業系統: Mac OS X 10.9 在 Mac 上要使用 Go 的最簡單方式是用 Homebrew 來安裝:
$ brew install go 安裝成功後，查看一下注意事項：
$ brew info go go: stable 1.2 (bottled), HEAD http://golang.org /usr/local/Cellar/go/1.2 (3980 files, 115M) * Poured from bottle From: https://github.com/mxcl/homebrew/commits/master/Library/Formula/go.rb ==&amp;gt; Options --cross-compile-all Build the cross-compilers and runtime support for all supported platforms --cross-compile-common Build the cross-compilers and runtime support for darwin, linux and windows --without-cgo Build without cgo ==&amp;gt; Caveats As of go 1.</description>
    </item>
    
    <item>
      <title>用 Scala 來開發 Android App 入門</title>
      <link>https://blog.simplypatrick.com/posts/2013/11-11-develop-android-app-with-scala/</link>
      <pubDate>Mon, 11 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2013/11-11-develop-android-app-with-scala/</guid>
      <description>最近想寫些 Android 的小程式，但是用 Java 實在是太無趣了，於是就想嘗試用 Scala 來做，分享一下怎麼入門的心得。
基本工具 我假設你已經安裝好下列工具 (標上我目前使用的版本):
 Scala (2.10.3) 及 SBT (0.13.0) IntelliJ 12  Scala plugin (0.22.302) SBT plugin (1.5.1)    產生一個基本的 Scala Android App  執行 android create project --target android-19 --path ./MyProject --package com.example.myproject --activity Main 在 project 目錄下新建 project/plugins.sbt，內容如下 (注意中間的空白行不可省略):  addSbtPlugin(&amp;#34;com.hanhuy.sbt&amp;#34; % &amp;#34;android-sdk-plugin&amp;#34; % &amp;#34;1.2.2&amp;#34;) addSbtPlugin(&amp;#34;com.hanhuy.sbt&amp;#34; % &amp;#34;sbt-idea&amp;#34; % &amp;#34;1.6.0&amp;#34;)  在 project 目錄下新建 build.sbt，同樣中間空白行不可省略:  android.Plugin.androidBuild name := &amp;#34;MyProject&amp;#34;  執行 sbt android:package-debug，到這一步應該就能把 APK 建立出來了  把 Java 轉成 Scala 然後你可以試著把 android 幫你產生的 Java 手動改寫成 Scala (副檔名也要改 .</description>
    </item>
    
    <item>
      <title>Scala: Under the Hood #1</title>
      <link>https://blog.simplypatrick.com/posts/2012/12-10-scala-under-the-hood-number-1/</link>
      <pubDate>Mon, 10 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/12-10-scala-under-the-hood-number-1/</guid>
      <description>我學一個東西向來喜歡盡量深入去瞭解它的運作原理，這兩天看了 Scala 覺得蠻有趣的，也會去想像如果翻譯成 Java 會是怎麼樣的做法。 如果想知道自己的想法跟 Scala 實作的差距，可以直接做些實驗來比對。例如下面就是個求解最大公因數的實驗，我寫了四個版本 (gcd1 .. gcd4)：
object GCD { def main(args: Array[String]) { def gcd1(m: Int, n: Int):Int = { if (n == 0) { return m } else { return gcd1(n, m % n) } } def gcd2(m: Int, n: Int):Int = { if (n == 0) { m } else { gcd2(n, m % n) } } def gcd3(m: Int, n: Int):Int = if (n == 0) m else gcd3(n, m % n) var gcd4: (Int,Int) =&amp;gt; Int = null gcd4 = (m: Int, n: Int) =&amp;gt; if (n == 0) m else gcd4(n, m % n) val Array(m, n) = args.</description>
    </item>
    
    <item>
      <title>Ruby&#39;s Object Model</title>
      <link>https://blog.simplypatrick.com/posts/2012/12-08-rubys-object-model/</link>
      <pubDate>Sat, 08 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/12-08-rubys-object-model/</guid>
      <description>Ruby 強大的 metaprogramming 能力就是來自於它簡單又優雅的 object model。
 </description>
    </item>
    
    <item>
      <title>Trying Scala on Android</title>
      <link>https://blog.simplypatrick.com/posts/2012/12-08-trying-scala-on-android/</link>
      <pubDate>Sat, 08 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/12-08-trying-scala-on-android/</guid>
      <description>Scala 是基於 Java 平台的多範式程式語言，最著名的使用者就是原本從 Ruby 起家的 Twitter。由於 Java 平台賦予的可攜性，除了應用於各式各樣的後端程式，Scala 也能用來撰寫 Android 的 app。
我嘗試的環境如下：
 Mac OS X 10.8.2 Android 4.2 SDK Scala 2.9.2  由於我習慣用 ant 來建置，需要先做的就是修改 build.xml 加入以下步驟：
&amp;lt;import file=&amp;quot;mac-shim.xml&amp;quot; /&amp;gt; &amp;lt;import file=&amp;quot;build-scala.xml&amp;quot; /&amp;gt; &amp;lt;target name=&amp;quot;-post-compile&amp;quot; depends=&amp;quot;-post-compile-scala&amp;quot; /&amp;gt; 重點在於加入 -post-compile-scala 這個步驟來編譯 src/ 下的 .scala 檔案。mac-shim.xml 是為了解決 Android SDK 的 ant script 在 Linux/MacOS 下的差異；build-scala.xml 則是包含可重複使用的 Scala 建置規則。
另外執行 ant 前要先用 android update project 把 local.properties 產生出來，並把 scala.dir 指向 Scala 的安裝位置：</description>
    </item>
    
    <item>
      <title>rb-appscript and iTunes</title>
      <link>https://blog.simplypatrick.com/posts/2012/12-02-rb-appscript-and-itunes/</link>
      <pubDate>Sun, 02 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/12-02-rb-appscript-and-itunes/</guid>
      <description>iTunes 11 出來了，界面變簡潔漂亮了，所以就比較有把音樂資料庫整理一下的動力。手上有很久以前下載的 Rolling Stone Magazine&amp;rsquo;s Top 500 Songs，可惜的是加入 iTunes 資料庫後由於沒有音軌數字的資訊，整個次序都不大對：
手動一個一個改對我來說是不可能的，於是想到了 iTunes 似乎是有提供 AppleScript API 界面的，但第一個問題就是我跟 AppleScript 不熟，於是在網路上搜尋發現有個 Ruby gem 叫 rb-appscript 可以用 Ruby 來做類似的功能，二話不說就 gem install rb-appscript 下來用了。
但接著第二個問題是我跟 iTunes 的 AppleScript API 也不熟，但也很快地發現可以從 AppleScript editor 裡面查到：
於是在 irb 裡小試了一下發現可以成功運作後，就直接動手寫了：
require &amp;#39;appscript&amp;#39; Appscript.app.by_name(&amp;#34;iTunes&amp;#34;).selection.get.each do |t| t.track_number.set $1 if t.name.get =~ /^(\d+)/ end 哈，大功告成。</description>
    </item>
    
    <item>
      <title>Good Software Development Practice from Facebook</title>
      <link>https://blog.simplypatrick.com/posts/2012/11-25-good-software-development-practice-from-facebook/</link>
      <pubDate>Sun, 25 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/11-25-good-software-development-practice-from-facebook/</guid>
      <description>在 Phabricator 文檔裡面，發現幾個不錯的軟體開發實務：
 Recommendations on Branching Recommendations on Revision Control Writing Reviewable Code Using Lint to Improve Code Review  個人認為是蠻有參考價值的，值得一看。</description>
    </item>
    
    <item>
      <title>Phabricator - Collaboration Tool from Facebook</title>
      <link>https://blog.simplypatrick.com/posts/2012/11-08-phabricator-collaboration-tool-from-facebook/</link>
      <pubDate>Thu, 08 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/11-08-phabricator-collaboration-tool-from-facebook/</guid>
      <description>對 Phabricator 的第一印象就是很 social network，使用界面上也很有 Facebook 風格：
Phabricator 是 Facebook 內部的線上協作開發工具，今年夏天開源出來讓外界使用，有些新興的網路公司如 Dropbox 或 Quora 等也有在使用，不過 open-source project 方面似乎只看到 LLVM 及 WikiMedia 有要採用它來做 code review 工具。
Phabricator 由以下幾個主要功能組成：
 Differential 是 code review 工具，可以搭配 SVN, Mercurial, Git, 或是直接貼 plain-text diff 來做 pre-push 的代碼審查。 Maniphest 用來做 defect tracking。 Diffusion 可以線上瀏覽程式碼修改歷史。 Phriction 是 Wiki 文件系統。 另外有些比較小的模組：  Phame 個人部落格 Ponder 線上 Q&amp;amp;A Herald 可以自定事件通知的處理方式 Owner 協助幫忙找到任意原始碼的負責人 Paste 可以張貼分享原始碼 Showvote 可以辦投票活動 Countdown 倒數計時器 File 線上檔案分享 Macro 有點惡搞的 image macro &amp;hellip;    因為 Facebook 是從 PHP 起家的，從 Phabricator 這名字不難猜出來這系統也是用 PHP 開發的，連它搭配的 client 端工具 Arcanist 也是用 PHP 做的，一整個 PHP 到底。</description>
    </item>
    
    <item>
      <title>SCRUM and PDCA</title>
      <link>https://blog.simplypatrick.com/posts/2012/10-14-scrum-and-pdca/</link>
      <pubDate>Sun, 14 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/10-14-scrum-and-pdca/</guid>
      <description>SCRUM 用 PDCA 的精神來闡述：
圖片出處：magia3e</description>
    </item>
    
    <item>
      <title>Inconsolata and Source Code Pro</title>
      <link>https://blog.simplypatrick.com/posts/2012/09-27-inconsolata-and-source-code-pro/</link>
      <pubDate>Thu, 27 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/09-27-inconsolata-and-source-code-pro/</guid>
      <description>Source Code Pro 是 Adobe 近日釋出的 open-source font:
跟我目前的最愛 Inconsolata：
比較一下：
兩個的設計其實很接近，但基於以下幾個原因我還是比較喜歡 Inconsolata：
 Source Code Pro 比例上比較寬，實際顯示字有點太胖 我比較喜歡加斜線的 0 Inconsolata 的符號稍微大了一點 不喜歡 Source Code Pro 的小寫 i 及 k  </description>
    </item>
    
    <item>
      <title>Ruby Singleton Class</title>
      <link>https://blog.simplypatrick.com/posts/2012/09-16-ruby-singleton-class/</link>
      <pubDate>Sun, 16 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/09-16-ruby-singleton-class/</guid>
      <description>今天花了點時間試著了解 Ruby Class/Object 的內部實現：
以及 singleton class 的創建機制：
 eval.c - eval.c: rb_extend_object activate eval.c eval.c - class.c: rb_singleton_class activate class.c class.c - class.c: singleton_class_of activate class.c class.c - class.c: rb_make_metaclass activate class.c class.c - class.c: make_singleton_class activate class.c class.c - class.c: rb_class_boot activate class.c class.c - class.c: rb_class_alloc activate class.c deactivate class.c deactivate class.c class.c - class.c: rb_singleton_class_attached activate class.c deactivate class.c deactivate class.c deactivate class.c deactivate class.c deactivate class.</description>
    </item>
    
    <item>
      <title>Terminal syntax highlight</title>
      <link>https://blog.simplypatrick.com/posts/2012/09-16-terminal-syntax-highlight/</link>
      <pubDate>Sun, 16 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/09-16-terminal-syntax-highlight/</guid>
      <description>由於會需要在 blog 裡分享命令列指令，所以模仿其他的 CodeRay plug-in 寫了一個新的來高亮命令行。
在 Octopress 的目錄裡只需要新增一個 plugins/coderay_term.rb:
require &amp;#39;coderay&amp;#39; module CodeRay module Scanners # Scanner for terminal commands class Term &amp;lt; Scanner register_for :term protected def scan_tokens encoder, options state = :initial until eos? case state when :initial if match = scan(/^\s*\$/) encoder.text_token match, :directive state = :command_found elsif match = scan(/.*[\n$]/) encoder.text_token match, :comment end when :command_found if match = scan(/.*[\n$]/) encoder.text_token match, :function state = :initial end end end encoder end end end end </description>
    </item>
    
    <item>
      <title>ACRA and BugSense</title>
      <link>https://blog.simplypatrick.com/posts/2012/08-19-acra-and-bugsense/</link>
      <pubDate>Sun, 19 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/08-19-acra-and-bugsense/</guid>
      <description>ACRA (Application Crash Report for Android) 是個很受歡迎的 Android library，因為當你的 app 掛點時，它可以送一份驗屍報告 (crash report) 到 server 保存，以便開發者能做事後分析並修正問題。
你需要做的只是下面簡短幾行設定：
@ReportsCrashes(formKey = &amp;#34;dGp6WmNqdXNMM2lkTkJiUmhHRlM014615&amp;#34;) // Add this line public class Globals extends Application { private static Airport sAirport; public static Airport getAirport(Context context) { if (sAirport == null) { sAirport = new TaoyuanAirport(context.getApplicationContext()); } return sAirport; } @Override public void onCreate() { ACRA.init(this); // Add this line  super.onCreate(); } } 然後 manifest 裡面加上以下設定：</description>
    </item>
    
    <item>
      <title>AQuery - JQuery-like library for Android App</title>
      <link>https://blog.simplypatrick.com/posts/2012/08-19-aquery-jquery-like-library-for-android-app/</link>
      <pubDate>Sun, 19 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/08-19-aquery-jquery-like-library-for-android-app/</guid>
      <description>Android Query 是個頗酷的 Android library，顧名思義就是給 Android 用但用法很像 jQuery 的東西。
跟 jQuery 一樣，AQuery 的目標是讓 Android developer 可以 write less and do more：
public void renderContent(Content content, View view) { AQuery aq = new AQuery(view); aq.id(R.id.icon).image(R.drawable.icon).visible().clicked(this, &amp;#34;someMethod&amp;#34;); aq.id(R.id.name).text(content.getPname()); aq.id(R.id.time).text(FormatUtility.relativeTime(System.currentTimeMillis(), content.getCreate())).visible(); aq.id(R.id.desc).text(content.getDesc()).visible(); } 也可以輕鬆地執行 AJAX:
public void asyncJson(){ // perform a Google search in just a few lines of code  String url = &amp;#34;http://www.google.com/uds/GnewsSearch?q=Obama&amp;amp;v=1.0&amp;#34;; aq.ajax(url, JSONObject.class, this, &amp;#34;jsonCallback&amp;#34;); } public void jsonCallback(String url, JSONObject json, AjaxStatus status) { if (json !</description>
    </item>
    
    <item>
      <title>PlantUML - Keep Knowledge in Plain Text</title>
      <link>https://blog.simplypatrick.com/posts/2012/08-19-plantuml-keep-knowledge-in-plain-text/</link>
      <pubDate>Sun, 19 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/08-19-plantuml-keep-knowledge-in-plain-text/</guid>
      <description>PlantUML 是個有趣的工具，因為它可以讓你用純文字的方式來表達視覺化的 UML，如以下的例子：
@startuml abstract class AbstractList abstract AbstractCollection interface List interface Collection List &amp;lt;|-- AbstractList Collection &amp;lt;|-- AbstractCollection Collection &amp;lt;|- List AbstractCollection &amp;lt;|- AbstractList AbstractList &amp;lt;|-- ArrayList class ArrayList { Object[] elementData size() } @enduml  能用來產生這張圖：
這樣的概念並不是新的，像 Graphvis 這套工具就是用 DOT language 來描述「圖」，PlantUML 只是將這概念套用在 UML 上。對 programmer 來說，這種表示方法是再自然不過了，因為這樣能將內容與呈現方式分離，而當要修改內容時你所需要的只是你最愛的文字編輯器。
有許多種方式來使用 PlantUML：
 手動撰寫內容，然後單純使用它來產生 UML 圖檔 (JPG, PNG, or SVG) 用程式自動產生內容，再經由 PlantUML 產生圖檔 將它嵌入其他文件 (程式碼、Word 文件、網頁) 裡，當呈現時再動態產生圖檔 因為是純文字，所以很容易可以在網站上直接編輯內容，產生唯一的 image URL，需要呈現時再從網站下載  非常地有彈性及符合 DRY 原則，這也是為什麼 Pragmatic Programmer 告訴你要用純文字來保存你的知識。</description>
    </item>
    
    <item>
      <title>Ninja - a small build system</title>
      <link>https://blog.simplypatrick.com/posts/2012/08-18-ninja-a-small-build-system/</link>
      <pubDate>Sat, 18 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/08-18-ninja-a-small-build-system/</guid>
      <description>快才是王道  Ninja is a small build system with a focus on speed. It differs from other build systems in two major respects: it is designed to have its input files generated by a higher-level build system, and it is designed to run builds as fast as possible.
 Ninja 非常簡約的首頁這樣地描述著自己。對我而言，它是絕佳的 make 替代品，因為它速度飛快而且語法簡潔易懂。
這是一個簡單的 build.ninja 範例:
cxx = g++ cflags = -g -Iinclude -Iout -I/usr/local/include -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -fno-exceptions -fno-rtti -fno-common -Woverloaded-virtual -Wcast-qual -L/usr/local/lib -lpthread -lm -lLLVMX86Disassembler -lLLVMX86AsmParser -lLLVMX86CodeGen -lLLVMX86Desc -lLLVMSelectionDAG -lLLVMAsmPrinter -lLLVMMCParser -lLLVMX86AsmPrinter -lLLVMX86Utils -lLLVMX86Info -lLLVMJIT -lLLVMExecutionEngine -lLLVMCodeGen -lLLVMScalarOpts -lLLVMInstCombine -lLLVMTransformUtils -lLLVMipa -lLLVMAnalysis -lLLVMTarget -lLLVMMC -lLLVMCore -lLLVMSupport rule flex command = flex -o $out $in rule bison command = bison -d -o $out $in rule cxx command = $cxx $cflags -o $out $in build out/tokens.</description>
    </item>
    
    <item>
      <title>Reference Counting in Android libutils</title>
      <link>https://blog.simplypatrick.com/posts/2012/08-12-reference-counting-in-android-libutils/</link>
      <pubDate>Sun, 12 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/08-12-reference-counting-in-android-libutils/</guid>
      <description>從事 Android native framework 層的開發一定會接觸到兩個 C++ template class: sp 及 wp，分別是 strong pointer 及 weak pointer 的簡稱，是兩個看似簡單但卻有著魔鬼細節的 utility class。
一個比較典型使用 weak pointer 的狀況就是 Listener pattern，例如:
class TimedTextPlayer { wp&amp;lt;MediaPlayerBase&amp;gt; mListener; } void TimedTextPlayer::postTextEvent(const sp&amp;lt;ParcelEvent&amp;gt;&amp;amp; parcel, int64_t timeUs) { sp&amp;lt;MediaPlayerBase&amp;gt; listener = mListener.promote(); if (listener != NULL) { // ...  listener-&amp;gt;getCurrentPosition(&amp;amp;positionMs); // ...  } } 這個例子如果使用 sp 來記錄 listener 很容易因為忘了移除 listener 而造成 memory leak。用了 wp 也就沒有這個困擾，不過額外的開銷就是 wp 必須先呼叫 promote() 拿到一個 sp 才能使用。</description>
    </item>
    
    <item>
      <title>Smart Pointers in WebKit</title>
      <link>https://blog.simplypatrick.com/posts/2012/04-29-smart-pointers-in-webkit/</link>
      <pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/04-29-smart-pointers-in-webkit/</guid>
      <description>上一篇講了 RefCounted，也講一下我看 RefPtr, PassRefPtr, OwnPtr, 及 PassOwnPtr 的心得：
 RefPtr 定義了一個轉換至 pointer to data member 的 conversion operator:  // This conversion operator allows implicit conversion to bool but not to other integer types. typedef T* (RefPtr::*UnspecifiedBoolType); operator UnspecifiedBoolType() const { return m_ptr ? &amp;amp;RefPtr::m_ptr : 0; } 這個轉換運算子回傳的值可以被 compiler 自動轉換成 bool (非空時為 true)，但不能被轉換成數值來被使用，主要是用來避免一些可能的誤用狀況，有興趣的人可以參考 &amp;ldquo;The Safe Bool Idiom&amp;rdquo; 這篇文章。
OwnPtr 運用了 type traits 的技巧來達到 OwnPtr 及 OwnPtr&amp;lt;T*&amp;gt; 都是宣告一個內含 T* 的 smart pointer：  typedef typename RemovePointer&amp;lt;T&amp;gt;::Type ValueType; typedef ValueType* PtrType; </description>
    </item>
    
    <item>
      <title>Reference Counting in WebKit</title>
      <link>https://blog.simplypatrick.com/posts/2012/04-28-reference-counting-in-webkit/</link>
      <pubDate>Sat, 28 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/04-28-reference-counting-in-webkit/</guid>
      <description>WebKit 裡物件的生命週期很多都是由引用計數 (reference count) 控制的，今天有空看了一下，發現幾個巧妙之處：
 RefCounted 是個 template class，並且繼承自 RefCountedBase:  template&amp;lt;typename T&amp;gt; class RefCounted : public RefCountedBase { WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED; public: void deref() { if (derefBase()) delete static_cast&amp;lt;T*&amp;gt;(this); } protected: RefCounted() { } ~RefCounted() { } }; 繼承 RefCountedBase 的技巧 (template hoisting) 是為了避免 template 實例化產生的 code bloating；而 destructor 裡的 delete static_cast&amp;lt;T*&amp;gt;(this); 則是為了避免不必要的 virtual table 產生，觀察 ~RefCountBase() 是個 non-virtual function 可以印證：
~RefCountedBase() { ASSERT(m_deletionHasBegun); ASSERT(!m_adoptionIsRequired); } RefCountedBase 的設計相當輕量化， release 版本裡實際只會佔用一個 integer 的空間，而 debug 版裡則多了幾個輔助除錯的欄位:  #ifndef NDEBUG  bool m_deletionHasBegun; bool m_adoptionIsRequired; ThreadRestrictionVerifier m_verifier; #endif m_deletionHasBegun 是用來確保當物件當參考計數已經小於 1 之後是不能再做 ref/deref 的動作的；m_adoptionIsRequired 是用來確保 adoptRef() 一定要被呼叫到，也就是 new 出來的物件一定要先用 PassRefPtr 來管理；而 m_verifier 則是用來確認物件不會同時被兩個以上的 thread 引用。</description>
    </item>
    
    <item>
      <title>Continuous Integration and Android</title>
      <link>https://blog.simplypatrick.com/posts/2012/04-07-continuous-integration-and-android/</link>
      <pubDate>Sat, 07 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2012/04-07-continuous-integration-and-android/</guid>
      <description>在 Jenkins 上設定 Android app 的持續整合 並不困難，而且是頗讓人愉快的一件事，因為這充分體現了工程師懶惰的美德，要我自己去弄這些可以自動化的工作會要我的命，而剩下唯一的問題就是需要架設 server，但在雲端運算盛行的今日，你可以大膽地賭有人已經提供這樣的服務了。
CloudBees 提供的正是 &amp;ldquo;Jenkins as a Service&amp;rdquo; 這種服務，講白了就是可以把 Jenkins server 架在 CloudBees 的 server 上，你要做的就是把 sourec code 推到它提供的的 git repository 或是 GitHub 上即可。
如果你是獨立的 Android app 開發者，CloudBees 提供的免費服務其實還不錯，非常值得考慮使用：
 附帶一提，Hudson/Jenkins 的創造人 Kohsuke Kawaguchi 目前就是在 CloudBees 擔任 Architect。
參考：
 7 Ways to Optimize Jenkins/Hudson White Paper  </description>
    </item>
    
    <item>
      <title>ARM Architecture for Mobile Developers</title>
      <link>https://blog.simplypatrick.com/posts/2011/12-24-arm-architecture-for-mobile-developers/</link>
      <pubDate>Sat, 24 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/12-24-arm-architecture-for-mobile-developers/</guid>
      <description>目前幾乎市場上所有的 mobile device 用的 processor 都是基於 ARM Architecture 的，而做為一位 Android 或是 iOS 平台的應用程序開發人員對於 ARM 有一定的認識雖非必要，但多了解一點對優化程序及偵錯問題是有很大幫助的。關於 ARM 的基本介紹，可以參考 Pierre Lebeaupin 的 A few things iOS developers ought to know about the ARM architecture。
最基本要知道的是 ARM Architecture 是有分版本的:
目前主流的 Smartphone 都是採用 ARMv7a 的架構。
而另一個需要了解的觀念是 ABI (Application Binary Interface)，要了解 ARM 的 ABI 最快的就是參考 Application Binary Interface for the ARM Architecture 裡的這張圖：
從圖上可以看到在 ABI for the ARM Architecure 實際涵蓋了許多範圍，各個平台的 ABI 通常就是參考標準的 ARM ABI 然後把不明確的地方或是有差異的部份定義清楚。</description>
    </item>
    
    <item>
      <title>Build iOS App with rake</title>
      <link>https://blog.simplypatrick.com/posts/2011/12-24-build-ios-app-with-rake/</link>
      <pubDate>Sat, 24 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/12-24-build-ios-app-with-rake/</guid>
      <description>上次說到 rake 是幫忙 iOS App 本地化的好用工具，但其實幾乎所有要自動化的事情都能請它幫忙， 例如寫 game 的人需要做的 sprite sheet 也能請 rake 自動產生。
除此之外，準備各種不同的 build 也是頗煩人的事，如果你也用 rake 的話就可以用 wox 這個 gem 來幫忙，下面的範例是 wox 文檔建議的方式：
# Rakefile Wox::Tasks.create :info_plist =&amp;gt; &amp;#39;Resources/Info.plist&amp;#39;, :sdk =&amp;gt; &amp;#39;iphoneos&amp;#39;, :configuration =&amp;gt; &amp;#39;Release&amp;#39; do build :debug, :configuration =&amp;gt; &amp;#39;Debug&amp;#39; build :release, :developer_certificate =&amp;gt; &amp;#39;iPhone Developer: Dangerous Dave (9GZ84DL0DZ)&amp;#39; do ipa :app_store, :provisioning_profile =&amp;gt; &amp;#39;App Store&amp;#39; ipa :adhoc, :provisioning_profile =&amp;gt; &amp;#39;Team Provisioning Profile&amp;#39; do testflight :publish, :api_token =&amp;gt; &amp;#39;nphsZ6nVXMl0brDEsevLY0wRfU6iP0NLaQH3nqoh8jG&amp;#39;, :team_token =&amp;gt; &amp;#39;Qfom2HnGGJnXrUVnOKAxKAmpNO3wdQ9panhtqcA&amp;#39;, :notes =&amp;gt; proc { File.</description>
    </item>
    
    <item>
      <title>Cheating on iOS games</title>
      <link>https://blog.simplypatrick.com/posts/2011/12-24-cheating-on-ios-games/</link>
      <pubDate>Sat, 24 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/12-24-cheating-on-ios-games/</guid>
      <description>其實我以前還蠻喜歡嘗試去破解一些軟體或是修改遊戲來作弊，純粹是想挑戰一下從中獲得一些樂趣。
最近的一次嘗試是修改 iOS 上的 Final Fantasy II，這遊戲應該是我剛上國中的時候玩的吧，忘了因為什麼原因沒有把它破關，一直是心裡的一個遺憾，畢竟我是從 Final Fantasy I 就開始玩的老玩家了。所以如今 Square Enix 在 iOS 上把它重製，但我已經沒有那個閒功夫再重頭從等級 1 慢慢練了，所以最快的方法就是破解作弊啦。
要在 iOS 上進行遊戲的作弊破解有幾個前提：
 首先你需要是一台已經 JB 過的 iPhone 或是 iPad，因為需要在 device 用 Cydia 上安裝 gdb 來追蹤遊戲的運行。 再來你需要有 ARM Assembly 的知識，因為要能看懂程序的邏輯然後做修改。 你需要會用反組譯的分析工作例如 IDA Pro。 你必須會基本的 gdb 操作。  我用的方法大致跟 用iPhone修改及调试游戏作弊版教程 是一樣的：
 在 device 上安裝 openssh 及 openssl 用 usbmuxd 裡的 python-client 透過 USB 跟 device 做 SSH 連線 我是用 iFile 把 FinalFantasy2.app 從手機抓出來用 IDA Pro 做靜態分析。 再來就是比較苦工的部份，要找出那一段是遊戲裡增加經驗值或是 HP 的地方，通常可以從 function 的名字來判斷，例如這個有 LV_UP 的 function 看起來就很像是處理等級提昇的地方：  找到可能的地方了，連上 device 來做實驗看看，我通常是直接設定中斷點，然後把 register 的值改掉：</description>
    </item>
    
    <item>
      <title>iOS App Localization using rake</title>
      <link>https://blog.simplypatrick.com/posts/2011/12-24-ios-app-localization-using-rake/</link>
      <pubDate>Sat, 24 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/12-24-ios-app-localization-using-rake/</guid>
      <description>一般要幫 iOS App 本地化，其中比較繁瑣的就是翻譯 xib 檔案中的字串，通常是需要下面三個步驟 (可參考 ICanLocalize 的教學)：
 使用 ibtool 把字串從 xib 中抓出來 找人翻譯字串 使用 ibtool 再把翻譯好的字串放到 xib 中  不過我是不能忍受這些工作要手動進行的，所以最好的方式是用 rake 來自動化這些事情：
DEF_LPROJ = &amp;#39;en.lproj&amp;#39; REGIONS = Dir[&amp;#39;*.lproj&amp;#39;].delete_if {|p| p == DEF_LPROJ}.map {|p| File.basename(p, &amp;#39;.lproj&amp;#39;)} XIBS = Dir[&amp;#34;#{DEF_LPROJ}/*.xib&amp;#34;].map {|x| File.basename(x)} namespace :l10n do task :regions do REGIONS.each {|region| puts region} end task :xibs do XIBS.each {|xib| puts xib} end desc &amp;#39;Generate strings file for XIB&amp;#39; task :genstrings do REGIONS.</description>
    </item>
    
    <item>
      <title>Git Workflow</title>
      <link>https://blog.simplypatrick.com/posts/2011/12-03-git-workflow/</link>
      <pubDate>Sat, 03 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/12-03-git-workflow/</guid>
      <description>由於 git 要開分支很容易，但要怎麼運用分支來管理就是一門學問了。在網路上最常看到的是 Git Flow：
除了這個方式外，另外一種常用的方法是如 git help workflows 所描述的。為了容易理解，我用 Pencil 畫了這張示意圖：
雖然前後兩張圖用的 branch 的名稱及用途不大一樣，但有些基本道理是相同的：
 平常只從穩定的分支 merge 到不穩定的分支。這裡的穩定及不穩定是相對的，例如第二張圖中 maint 比 master 穩定，而 master 又比 next 穩定；在第一張圖中，release 比 develop 穩定，hotfix 又比 develop 穩定。我說的 merge 是 git 中 branch to branch 的 merge，例如 merge A to B 是讓 branch A 所有的改動都合併到 branch B 中。 在適當的時候可以從不穩定分支合併改動到穩定分支，例如第一張圖中的 developer -&amp;gt; release -&amp;gt; master 的合併，又例如第二張圖中的 next -&amp;gt; master -&amp;gt; maint。 Bugfix 應該 check-in 到最舊且需要這個改動的分支，然後再根據上一條規則的作法傳佈到較新的分支上。這樣做可以確保不會有忘記 merge 的 bugfix。 新 feature 都應該在獨立的分支中開發。  不管是用那一種方式，善用分支來管理產品的開發及產品發佈已經是個軟體開發人員必備的技能了，如果你還不熟悉，趕快找個機會把這些方法用到你目前正在做的工作上吧。</description>
    </item>
    
    <item>
      <title>LiveReload and Octopress</title>
      <link>https://blog.simplypatrick.com/posts/2011/12-03-livereload/</link>
      <pubDate>Sat, 03 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/12-03-livereload/</guid>
      <description>雖然平常沒什麼時間寫 blog，但總是希望寫的時候能夠專注在所寫的內容，而不必被發佈 blog 的一些瑣事而干擾，例如現在雖然已經習慣用 Pow 了，然後把 rake watch 開著，但要預覽時還是要回 Chrome 按一下 Reload 才能預覽目前的內容，有點小煩，所以看到有 LiveReload 這種好東西當然要拿來用啊。
簡單描述一下安裝的步驟:
 安裝 guard-livereload:  $ gem install guard-livereload  修改 Gemfile 把下列這一行加進去 &amp;lsquo;guard-livereload&amp;rsquo;:  $ gem &amp;#39;guard-livereload&amp;#39;  再來是改完 Gemfile 後的標準步驟:  $ bundle install  產生一份基本的 Guardfile:  $ guard init livereload  再來要修改 Rakefile 把啟動 guard 的動作放到 rake watch 裡面:  desc &amp;#34;Watch the site and regenerate when it changes&amp;#34; task :watch do raise &amp;#34;### You haven&amp;#39;t set anything up yet.</description>
    </item>
    
    <item>
      <title>AppCode: Make you a happier iOS developer</title>
      <link>https://blog.simplypatrick.com/posts/2011/10-29-appcode-make-you-a-happier-ios-developer/</link>
      <pubDate>Sat, 29 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/10-29-appcode-make-you-a-happier-ios-developer/</guid>
      <description>&amp;ldquo;XCode doesn&amp;rsquo;t look like a software tool that&amp;rsquo;s developed by Apple at all. It is clear Steve Jobs was not involved creating this tool.&amp;rdquo;
 我完全同意這句話，從 XCode 3.2 用到現在 4.2 版還是覺得不順手。寫程式最怕的就是被其他事干擾而分心，IDE 如果有什麼地方讓我工作效率不彰，我通常很快就會受不了然後分心去解決效率問題先，因為不能馬上解決會一直困擾我，而 XCode 就是個會讓我一直要傷腦筋的工具，但是為了要在相對精美的 iOS 及 iPhone 上開發程式，XCode 是唯一的選擇。
Tom van Zummeren 在 AppCode: IntelliJ for Objective C! 裡把 AppCode 比 XCode 還好的地方都整理出來了。我自己試用 AppCode 後也覺得 JetBrains 是有備而來的，用起來跟 IntelliJ IDEA 一樣地流暢，讓寫 Objective C 也能是個愉快的過程。
AppCode 主要贏在程式編輯功能，但偵錯功能感覺弱了一點，例如:
 我找不到 NSLog 輸出的訊息會跑到那裡 Debug 時輸出的訊息沒有 XCode 完整 不會自動停在 first-chance exception  所以實際開發時還是要 AppCode 及 XCode 同時開啟，買個大螢幕會比較好：</description>
    </item>
    
    <item>
      <title>Git and SourceTree</title>
      <link>https://blog.simplypatrick.com/posts/2011/10-23-git-and-sourcetree/</link>
      <pubDate>Sun, 23 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/10-23-git-and-sourcetree/</guid>
      <description>由於 Git 在 Linux/Windows 上都沒有比較好用的 GUI client，我向來是習慣直接在命令列敲指令，好處是簡單而且快，比較大的缺點就是瀏覽歷史記錄時比較麻煩，陽春又醜的 gitk 我通常是不得已才會去開它，所以換到 Mac OS X 上後，簡單好用而且開源的 GitX 自然就成為我的最愛，但 GitX 的更新實在有點慢，愛嘗鮮的我便一直注意著是否有更好的選擇。
後來有試用過 Tower，整個 UI 比 GitX 漂亮許多，使用設計上也相當不錯，正想說可以&amp;rsquo;定居&amp;rsquo;下來，沒想到中間殺出個 SourceTree，而且因為這個產品被 Atlassian 收購了，在 Mac App Store 正免費大放送中，估計之後會有跟 BitBucket 更緊密的功能整合。
本來 Mac OS X 就是讓 programmer 感覺很舒服的開發環境，有了 SourceTree 之後變更棒了。</description>
    </item>
    
    <item>
      <title>C and Dennis Ritchie</title>
      <link>https://blog.simplypatrick.com/posts/2011/10-14-c-and-dennis-ritchie/</link>
      <pubDate>Fri, 14 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/10-14-c-and-dennis-ritchie/</guid>
      <description>我第一次接觸 C 語言應該是國二吧，那時在倚天雜誌上看到有人用 C 寫了一個程式獲得了程式比賽冠軍，當時看到這個用了各種括號 { ( [ ] ) } 來寫的語言實在是比 BASIC 酷太多了，馬上就被迷上了。剛開始，不記得去那裡拷貝到一個 C compiler 就開始自學起 C programming 了，但那個 compiler 實在是太陽春到一些正確的語法也會有編譯錯誤，一直等到 Borland Turbo C 2.0 這個產品出現後，自己才算真正地學起 C 語言:
C 從此成為我一窺 computer programming 奧妙的鑰匙，也是之後我會從事資訊業的主要原因，所以說 C 這個程式語言很大地影響了我人生也不為過。
眾所皆知，C 語言之父就是 Bell Labs K&amp;amp;R 的 R (Dennis Ritchie)，而他於很令人遺憾地於 10/8 過世了。Dennis 的主要貢獻 C 及 UNIX 幾乎是全面性地影響了整個資訊產業，你手上用的 iPhone 或是 Android 手機也是站在這個巨人的肩膀上才有可能被發明出來。
Dennis 曾經說過:
 UNIX is very simple, it just needs a genius to understand its simplicity.</description>
    </item>
    
    <item>
      <title>Importing wordpress.com Blog</title>
      <link>https://blog.simplypatrick.com/posts/2011/10-09-importing-wordpress-dot-com-blog/</link>
      <pubDate>Sun, 09 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/10-09-importing-wordpress-dot-com-blog/</guid>
      <description>今晚試著照 Jekyll 網站教的方法把 wordpress.com 的資料轉過來，遇到了一些問題，主要是 yaml 無法正確處理 UTF-8 資料以及原始檔名有包含 % 時會有重複 escape 的問題。花了一點功夫試出了解決方式如下：
修改 wordpressdotcom.rb:
--- a/source/_import/wordpressdotcom.rb +++ b/source/_import/wordpressdotcom.rb @@ -3,6 +3,7 @@ require &amp;#39;rubygems&amp;#39; require &amp;#39;hpricot&amp;#39; require &amp;#39;fileutils&amp;#39; +require &amp;#39;ya2yaml&amp;#39; require &amp;#39;yaml&amp;#39; require &amp;#39;time&amp;#39; @@ -16,7 +17,7 @@ module Jekyll  (doc/:channel/:item).each do |item| title = item.at(:title).inner_text.strip - permalink_title = item.at(&amp;#39;wp:post_name&amp;#39;).inner_text + permalink_title = item.at(&amp;#39;wp:post_name&amp;#39;).inner_text.delete(&amp;#39;%&amp;#39;)  # Fallback to &amp;#34;prettified&amp;#34; title if post_name is empty (can happen) if permalink_title == &amp;#34;&amp;#34; permalink_title = title.</description>
    </item>
    
    <item>
      <title>Hello Octopress!</title>
      <link>https://blog.simplypatrick.com/posts/2011/10-08-hello-octopress/</link>
      <pubDate>Sat, 08 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/10-08-hello-octopress/</guid>
      <description>看了 XDite 的介紹，由於 Rails 大概懂一點，前陣子也是有小玩過 Heroku，所以也仿效他把 blog 系統換成 Octopress 了。
由於預設 theme 的字型感覺有點太大，所以就試著調了一下，也小改了標題的字型：
body { font-size: 70%; } body &amp;gt; header h1 a, body &amp;gt; header h1 a:visited, body &amp;gt; header h1 a:hover { font-family: &amp;#34;Julee&amp;#34;; } body &amp;gt; header h2 { font-family: &amp;#34;Just Me Again Down Here&amp;#34;; font-size: 1.5em; } 幾點感想：
 Markdown 語法還蠻直覺的，只是之前用 Redmine 學了 Texttile 語法，後來寫技術文檔用 reStruturedText 格式，都很像但又有些不一樣，寫的時候要把腦袋調到正確的模式有點累。 Webfonts 真是個好東西，用起來很簡單，又可以很簡單地把網頁弄的有質感。 CSS 本來就不是很好搞，在加上 Sass 又變更複雜，真是要花時間才能學好。  </description>
    </item>
    
    <item>
      <title>Git and Jun</title>
      <link>https://blog.simplypatrick.com/posts/2011/06-17-git-and-jun/</link>
      <pubDate>Fri, 17 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/06-17-git-and-jun/</guid>
      <description>大家一般知道 Git 的發明者是 Linus Torvalds，但是實際上假如你常查閱 git help 的話，你會發現 Junio C Hamano 這個名字出現的次數實在比 Linus 多很多。如果說 Linus 是 Git 之父，Jun 應該就是 Git 之母了。
Jun 目前在 Google 工作，Android 或是 Chrome OS 都選擇用 Git 也算是支持自家人了。下面是他的在 Open Source At Google 接受訪談的影片：
 附記：
 Google 內部用的 VCS 應該不是秘密吧，聽說是修改過的 Perforce。 訪問者啕侃了一下 Jun 為什麼 Git 這麼難用不好學。 XD  </description>
    </item>
    
    <item>
      <title>好久沒碰的 Buildbot 改的還不錯</title>
      <link>https://blog.simplypatrick.com/posts/2011/05-30-buildbot/</link>
      <pubDate>Mon, 30 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/05-30-buildbot/</guid>
      <description>蠻久沒有碰 Buildbot 了，今天看到 Chromium project 在用，新增的這個 Console 界面還不錯，對於 Chromium 這種需要支援許多平台並且要執行許多測試項目的 project 是蠻適合的，整個狀況可以一目了然：
 有問題的部份也很明顯可以直接點進去看，比起之前要去拉長長的 waterfall 圖方便許多：</description>
    </item>
    
    <item>
      <title>多平台手機遊戲開發</title>
      <link>https://blog.simplypatrick.com/posts/2011/05-28-portable-mobile-game-development/</link>
      <pubDate>Sat, 28 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/05-28-portable-mobile-game-development/</guid>
      <description>昨天發現一個 Flash 遊戲: Jelly Cannon，相當地好玩，類型也是流行的物理益智遊戲：
 玩的過程發現他果凍的質感做得很好，看起來用的物理引擎還挺不錯的，不輸給 Box2D 或是 Chipmunk，查了一下是個叫 Nape 的物理引擎。
自從接觸 iOS programming 以來，一直都對這種小遊戲的設計還蠻有興趣的，仔細看了一下發現它是用 haXe (啥? 聽都沒聽過) 這個 programming language 寫的，而 haXe 的 compiler 是用 OCaml 寫的，一整個非主流 (法國風?) 實在是讓人很感興趣。
特別的是，haXe 是個 multiplatform language，目前可以把 code 編譯成 Flash, JavaScript (用來支援 HTML5?!), C++ (iOS 上看起來沒問題), 之後還會支援 C# (跑在 Windows Phone / Xbox360 上) 及 Java (Android 也行)，看起來相當有潛力用來開發支援多種平台 (看起來大家都這樣做吧) 的 mobile game。值得持續關注&amp;hellip;</description>
    </item>
    
    <item>
      <title>My preferred programming fonts on Mac OS X</title>
      <link>https://blog.simplypatrick.com/posts/2011/02-19-programming-fonts-on-mac-osx/</link>
      <pubDate>Sat, 19 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2011/02-19-programming-fonts-on-mac-osx/</guid>
      <description>Mac OS X 是非常棒的程式開發平台，有非常強的 CLI，也有非常漂亮的 GUI。
我個人對於程式字型的選擇頗為堅持，例如在使用較暗的背景下，我偏好使用 Menlo：

但如果是在白色的背景下，我覺得 Consolas 比較好看些：

關於怎麼在 Mac OS X 下安裝 Consolas 字型，Google 就能找到一堆。</description>
    </item>
    
    <item>
      <title>How to be a Star Engineer</title>
      <link>https://blog.simplypatrick.com/posts/2008/2008-07-21-415/</link>
      <pubDate>Mon, 21 Jul 2008 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2008/2008-07-21-415/</guid>
      <description>如何成為一位傑出的工程師
How to be a Star Engineer Robert E. Kelley, Carnegie Mellon University (Robert E. Kelley, &amp;ldquo;How to be a star engineer,&amp;rdquo; IEEE Spectrum, pp. 51-58, Oct. 1999.)
翻譯：馬仕毅
在1985年，我被問了一些問題,從那時起,我就開始找尋真正的答案。提出問題的是貝爾實驗室(那是仍然是AT&amp;amp;T的一部分，現在屬於Lucent Technologies Inc.)。貝爾實驗室由全世界最好的大學中聘用了最優秀，最聰明的畢業生,然而, 最後只有少數的人真正發揮他們的潛力而成為卓越的工程師。大部分的新進人員發展成可以穩定地完成任務的執行者，生產力並沒有特別突出，無法幫助貝爾實驗室在提昇AT&amp;amp;T的市場競爭力方面，做出顯著的貢獻。
貝爾實驗室想要知道的是：傑出的工程師和普通的工程師到底有什麼不同？ 傑出與否是由天份來決定？還是可以經由學習得來？可不可以設計一套提昇生產力的計畫來幫助表現平平的員工成為傑出的人才？
不只有公司才會尋求這些問題的答案。由1985年開始，幾乎所有我遇到的工程師都希望能夠增加自己的生產力。他們覺得自己也可以出類拔萃，他們不喜歡被同事的光芒所掩蓋。因此他們不斷地努力求進步。在現今的職場中，資源越來越少,工作的要求卻越來越多。
全球化的競爭，購併風氣,企業裁員使得每位員工所承擔的責任越來越重大，而可利用的資源卻比以前少。環顧你的四周，和五年前比較,那位不是比以前工作更努力，工時更長？ 誰不是待完成的工作一堆，好多的電話和電子郵件還沒回？ 大家都在暗自擔心，如果不能再提高生產力，下一個被裁員的會不會是自己？誰不希望能夠重新掌握自己的生活-在工作和個人生活中取得一個更好的平衡點？ 每個人都聽過：更聰明地工作(work smarter)，只是似乎沒人知道那是什麼意思。
我和我的同事從那時起就開始研究公司和個人生產力的問題。來自貝爾實驗室，3M，及惠普公司總計超過一千位工程師在這個研究的過程中，同時扮演了研究夥伴及受試者的角色。為了瞭解傑出工程師的秘密，我們使用了問卷調查，直接觀察，工作日記，焦點團隊(focus groups)，以及面試等方法來收集資料。並在適當的時候使用統計分析，內容分析(content analysis)，及反覆的模型建立(iterative model building)等方法。
許多其他的公司也都參與了這個過程，包含了以電機工程師為重心的Analog Devices, Fore Systems, Air Touch，以及一些包含其他領域工程師的公司如Shell Oil, Kimberly Clark等。這些公司採用了我們的生產力提昇計畫。有效地將表現普通的員工轉換成傑出的工程師，而在這個過程中，也讓我們對於產生傑出表現的關鍵因素有了更多的了解。
往傑出之路
Lai及Henry在進入貝爾實驗室時，兩人的背景近似。都是由頂尖的大學畢業，平均成績3.8(GPA)。都曾經在電腦公司做過暑期工讀，而且都獲得教授的全力推薦。然而，在剛進公司的前六個月，兩人採取了截然不同的態度來面對公司指派的工作。上午的時間，他們需要上有關電話技術以及貝爾實驗室工作流程的課。下午的時間則參與一些暖身計畫(break-in projects)，這是一些需要完成的次要工作，即使是做得很差也不至於對重要的計畫造成影響。
Henry像在寫畢業論文或是準備考試似的將自己關在辦公室中。他收集了許多的技術文件以深入了解最新的技術進展，只有在上廁所或是參加必要的會議時才會離開辦公室。他記得當時的想法是『最重要的事情是：我是否可以證明給我的同事看，在技術上我真的很行』 Lai每個下午安排的三個小時的時間來完成指派的工作以及增進技術上的技能。一有多出來的時間，她會向其他的同事自我介紹，同時了解一下他們正在進行的計畫。如果有同事需要幫忙或是時程的壓力很大，她會自告奮勇要幫忙。雖然她對新的工作環境文化不熟，她的同事們還是覺得很窩心。特別是這些本來不是她的問題。
有一天下午，有一位同事正在和一個困難的程式奮戰，而整個軟體計畫的時程只剩一週了。Lai以前在修一門高等課程時學過一個新的程式工具，她覺得應該可以應付這個程式，所以她主動提出要幫忙寫這個程式，這樣她的同事就可以專心應付更大的計畫。另一次，有一些複雜的軟體工具需要安裝在每個人的PC上。依照以前的作法，是由每個人自己在電腦上安裝，有問題自己解決。Lai在以前暑期工讀的時候也曾遇過類似的狀況，她覺得由一個人來安裝這個軟體到所有的電腦上比較合理。因此她主動建議由她來做。但是這個安裝的動作比想像中要困難，總共需要兩週的時間。比她原先估計的四天要多出很多。她原本可以放棄這個建議，但是她仍然將這個工作實行完成。雖然她有好幾天必須提早到公司並且加班到很晚，才不會影響到白天的上課及計畫的進度。
六個月之後，Henry和Lai都完成了他們的技術課程以及第一個任務。他們的計畫執行成效都被評估為良好而且具有技術上的競爭力。實際上，Henry的計畫成果在技術上可能要比Lai來的高明一些。 然而在同事之間的認同度方面，Henry顯然比較不足。雖然大家都覺得他還好相處，同事們還是認為他比較像獨行俠。對於技術的部份相當熟練，但是未必能將他的技能和其他的同事分享。他的行事態度還是和在學校時一樣，只在乎個別的表現。
在另一方面，Lai給別人的印象就比較主動積極。她肯主動發掘並解決問題，即使那並不在她的責任範圍內。同事們都覺得她好像進入實驗室不只六個月了。當然，經理們也注意到了Lai具有成為傑出工程師的特質。已經開始考慮要讓她參與更重要的計畫了。大部分的人(如Henry)都對於傑出工作能力的成因有自己的理論，然而，大多數都錯得很離譜。
過去14年來，我們對於傑出工程師的成因，有許多令人吃驚的發現，也打破了許多很普遍的迷思。我們的第一個發現是：老闆們和同事們眼中的傑出人才往往差異很大。我們首先請經理人列出他們心目中的傑出人選，然後再建議他們篩選這些人選，請他們想一想如果他們有很重要的計畫要執行，或是重大計畫有什麼緊急狀況，需要特種部隊來解決問題，或是自己要出來創業，需要聘請一些高手時，誰是最佳人選。當我們將這張表拿給表現傑出的工程師們看時，他們往往對老闆們的選擇嗤之以鼻。『Joe怎麼可能會入選？他已經好幾年沒做什麼事了。還有，Maria怎麼沒在上面？每個人有問題卡住了或是需要新點子時都會去找她。』
這個反應的差異讓我們停下來重新思索。我們往後退了一個步驟，重新要求經理人以及工程師中的高手分別列出那些人的績效比其他的同事高出許多。特別是做事方式讓其他人佩服的。我們想要排除那些不擇手段獲取績效的人，往往他們對組織造成的傷害大到可以抵銷他們所有的貢獻。
這個步驟的結果是：兩方所提出來的人選當中，只有大約百分之五十的人是重複的。優秀的工程師和經理人對於誰的表現比較好，大約有一半的機會是看法不一致的。
在我們最早在貝爾實驗室的研究中，我們對受試者做進一步的挑選。只有在經理人及同事們眼中都表現傑出的工程師才會成為我們的研究對象。(在之後研究3M公司時，我們把客戶的看法也考慮進去)。我們同時也考慮了他們所獲得的獎項，榮譽，及考績獎金的數目等。另外，專利及發表文章的數量也會列入考慮。這些條件都滿足的傑出工程師就構成我們研究的對象，由其中分析傑出表現的成因。
為了要分出表現平平的表現優異的員工的主要差異，我們請教了高階主管，中階主管，工程師，以及其他研究者的看法。由這些結果中，我們累積了45個主管們及工程師們都覺得會影響傑出表現的主要因素。大致上可以分為四大類：
一、認知類的因素：比較高的智商，邏輯推理能力，及創意。 二、個性因素：自信，野心，勇氣，以及是否相信可以控制自己的命運。 三、社交因素：人際關係，領導能力。 四、工作及組織因素：與主管的關係，工作成就感，對於薪資及獎金的態度。</description>
    </item>
    
    <item>
      <title>Software Simian</title>
      <link>https://blog.simplypatrick.com/posts/2008/2008-07-19-405/</link>
      <pubDate>Sat, 19 Jul 2008 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2008/2008-07-19-405/</guid>
      <description>呆伯特漫畫裡頗為經典的一篇：
如果現實裡能單純當個 Code Monkey 其實也不錯&amp;hellip; 呵&amp;hellip;</description>
    </item>
    
    <item>
      <title>工作與生活</title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-11-02-402/</link>
      <pubDate>Fri, 02 Nov 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-11-02-402/</guid>
      <description>今天同事分享的文章，寫的很棒，活出自己才是真正的成功：
HP中国前总裁孙振耀致大话IT网友：关于工作与生活
我有个有趣的观察，外企公司多的是25-35岁的白领，40岁以上的员工很少，二三十岁的外企员工是意气风发的，但外企公司40岁附近的经理人是很尴尬的。我见过的40岁附近的外企经理人大多在一直跳槽，最后大多跳到民企，比方说，唐骏。外企员工的成功很大程度上是公司的成功，并非个人的成功，西门子的确比国美大，但并不代表西门子中国经理比国美的老板强，甚至可以说差得很远。而进外企的人往往并不能很早理解这一点，把自己的成功90％归功于自己的能力，实际上，外企公司随便换个中国区总经理并不会给业绩带来什么了不起的影响。好了问题来了，当这些经理人40多岁了，他们的薪资要求变得很高，而他们的才能其实又不是那么出众，作为外企公司的老板，你会怎么选择？有的是只要不高薪水的，要出位的精明强干精力冲沛的年轻人，有的是，为什么还要用你？
从上面这个例子，其实可以看到我们的工作轨迹，二三十岁的时候，生活的压力还比较小，身体还比较好，上面的父母身体还好，下面又没有孩子，不用还房贷，也没有孩子要上大学，当个外企小白领还是很光鲜的，挣得不多也够花了。但是人终归要结婚生子，终归会老，到了40岁，父母老了，要看病要吃药，要有人看护，自己要还房贷，要过基本体面的生活，要养小孩……那个时候需要挣多少钱才够花才重要。所以，看待工作，眼光要放远一点，一时的谁高谁低并不能说明什么。
从这个角度上来说，我不太赞成过于关注第一份工作的薪水，更没有必要攀比第一份工作的薪水，这在刚刚出校园的学生中间是很常见的。正常人大概要工作35年，这好比是一场马拉松比赛，和真正的马拉松比赛不同的是，这次比赛没有职业选手，每个人都只有一次机会。要知到，有很多人甚至坚持不到终点，大多数人最后是走到终点的，只有少数人是跑过终点的，因此在刚开始的时候，去抢领先的位置并没有太大的意义。刚进社会的时候如果进500强公司，大概能拿到3k-6k/月的工资，有些特别技术的人才可能可以到8k/月，可问题是，5年以后拿多少？估计5k-10k了不起了。起点虽然高，但增幅有限，而且，后面的年轻人追赶的压力越来越大。
我前两天问我的一个销售，你会的这些东西一个新人2年就都学会了，但新人所要求的薪水却只是你的一半，到时候，你怎么办？ 职业生涯就像一场体育比赛，有初赛、复赛、决赛。初赛的时候大家都刚刚进社会，大多数都是实力一般的人，这时候努力一点认真一点很快就能让人脱颖而出，于是有的人二十多岁做了经理，有的人迟些也终于赢得了初赛，三十多岁成了经理。然后是复赛，能参加复赛的都是赢得初赛的，每个人都有些能耐，在聪明才智上都不成问题，这个时候再想要胜出就不那么容易了，单靠一点点努力和认真还不够，要有很强的坚忍精神，要懂得靠团队的力量，要懂得收服人心，要有长远的眼光……
看上去赢得复赛并不容易，但，还不是那么难。因为这个世界的规律就是给人一点成功的同时让人骄傲自满，刚刚赢得初赛的人往往不知道自己赢得的仅仅是初赛，有了一点小小的成绩大多数人都会骄傲自满起来，认为自己已经懂得了全部，不需要再努力再学习了，他们会认为之所以不能再进一步已经不是自己的原因了。虽然他们仍然不好对付，但是他们没有耐性，没有容人的度量，更没有清晰长远的目光。就像一只愤怒的斗牛，虽然猛烈，最终是会败的，而赢得复赛的人则象斗牛士一样，不急不躁，跟随着自己的节拍，慢慢耗尽对手的耐心和体力。赢得了复赛以后，大约已经是一位很了不起的职业经理人了，当上了中小公司的总经理，大公司的副总经理，主管着每年几千万乃至几亿的生意。
最终的决赛来了，说实话我自己都还没有赢得决赛，因此对于决赛的决胜因素也只能凭自己的猜测而已，这个时候的输赢或许就像武侠小说里写得那样，大家都是高手，只能等待对方犯错了，要想轻易击败对手是不可能的，除了使上浑身解数，还需要一点运气和时间。世界的规律依然发挥着作用，赢得复赛的人已经不只是骄傲自满了，他们往往刚愎自用，听不进去别人的话，有些人的脾气变得暴躁，心情变得浮躁，身体变得糟糕，他们最大的敌人就是他们自己，在决赛中要做的只是不被自己击败，等着别人被自己击败。这和体育比赛是一样的，最后高手之间的比赛，就看谁失误少谁就赢得了决赛。
根源
你工作快乐么？你的工作好么？ 有没有觉得干了一段时间以后工作很不开心？有没有觉得自己入错了行？有没有觉得自己没有得到应有的待遇？有没有觉得工作像一团乱麻每天上班都是一种痛苦？有没有很想换个工作？有没有觉得其实现在的公司并没有当初想象得那么好？有没有觉得这份工作是当初因为生存压力而找的，实在不适合自己？你从工作中得到你想要得到的了么？你每天开心么？
大话IT上愤怒的人很多，你有没有想过，你为什么不快乐？你为什么愤怒？ 其实，你不快乐的根源，是因为你不知道要什么！你不知道要什么，所以你不知道去追求什么，你不知道追求什么，所以你什么也得不到。
我总觉得，职业生涯首先要关注的是自己，自己想要什么？大多数人大概没想过这个问题，唯一的想法只是——我想要一份工作，我想要一份不错的薪水，我知道所有人对于薪水的渴望，可是，你想每隔几年重来一次找工作的过程么？你想每年都在这种对于工作和薪水的焦急不安中度过么？不想的话，就好好想清楚。饮鸩止渴，不能因为口渴就拼命喝毒药。越是焦急，越是觉得自己需要一份工作，越饥不择食，越想不清楚，越容易失败，你的经历越来越差，下一份工作的人看着你的简历就皱眉头。于是你越喝越渴，越渴越喝，陷入恶性循环。最终只能哀叹世事不公或者生不逢时，只能到大话IT上来发泄一把，在失败者的共鸣当中寻求一点心理平衡罢了。大多数人都有生存压力，我也是，有生存压力就会有很多焦虑，积极的人会从焦虑中得到动力，而消极的人则会因为焦虑而迷失方向。所有人都必须在压力下做出选择，这就是世道，你喜欢也罢不喜欢也罢。
一般我们处理的事情分为重要的事情和紧急的事情，如果不做重要的事情就会常常去做紧急的事情。比如锻炼身体保持健康是重要的事情，而看病则是紧急的事情。如果不锻炼身体保持健康，就会常常为了病痛烦恼。又比如防火是重要的事情，而救火是紧急的事情，如果不注意防火，就要常常救火。找工作也是如此，想好自己究竟要什么是重要的事情，找工作是紧急的事情，如果不想好，就会常常要找工作。往往紧急的事情给人的压力比较大，迫使人们去赶紧做，相对来说重要的事情反而没有那么大的压力，大多数人做事情都是以压力为导向的，压力之下，总觉得非要先做紧急的事情，结果就是永远到处救火，永远没有停歇的时候。（很多人的工作也像是救火队一样忙碌痛苦，也是因为工作中没有做好重要的事情。）那些说自己活在水深火热为了生存顾不上那么多的朋友，今天找工作困难是当初你们没有做重要的事情，是结果不是原因。如果今天你们还是因为急于要找一份工作而不去思考，那么或许将来要继续承受痛苦找工作的结果。
我始终觉得我要说的话题，沉重了点，需要很多思考，远比唐笑打武警的话题来的枯燥乏味，但是，天下没有轻松的成功，成功，要付代价。请先忘记一切的生存压力，想想这辈子你最想要的是什么？所以，最要紧的事情，先想好自己想要什么。
什么是好工作
当初微软有个唐骏，很多大学里的年轻人觉得这才是他们向往的职业生涯，我在清华bbs里发的帖子被这些学子们所不屑，那个时候学生们只想出国或者去外企，不过如今看来，我还是对的，唐骏去了盛大，陈天桥创立的盛大，一家民营公司。一个高学历的海归在500强的公司里拿高薪水，这大约是很多年轻人的梦想，问题是，每年毕业的大学生都在做这个梦，好的职位却只有500个。
人都是要面子的，也是喜欢攀比的，即使在工作上也喜欢攀比，不管那是不是自己想要的。大家认为外企公司很好，可是好在哪里呢？好吧，他们在比较好的写字楼，这是你想要的么？他们出差住比较好的酒店，这是你想要的么？别人会羡慕一份外企公司的工作，这是你想要的么？那一切都是给别人看的，你干吗要活得那么辛苦给别人看？另一方面，他们薪水福利一般，并没有特别了不起，他们的晋升机会比较少，很难做到很高阶的主管，他们虽然厌恶常常加班，却不敢不加班，因为“你不干有得是人干”，大部分情况下会找个台湾人香港人新加坡人来管你，而这些人又往往有些莫名其妙的优越感。你想清楚了么？500强一定好么？找工作究竟是考虑你想要什么，还是考虑别人想看什么？
我的大学同学们大多数都到美国了，甚至毕业这么多年了，还有人最近到国外去了。出国真的有那么好么？我的大学同学们，大多数还是在博士、博士后、访问学者地挣扎着，至今只有一个正经在一个美国大学里拿到个正式的教职。国内的教授很难当么？我有几个表亲也去了国外了，他们的父母独自在国内，没有人照顾，有好几次人在家里昏倒都没人知道，出国，真的这么光彩么？就像有人说的“很多事情就像看A片，看的人觉得很爽，做的人未必。”
人总想找到那个最好的，可是，什么是最好的？你觉得是最好的那个，是因为你的确了解，还是因为别人说他是最好的？即使他对于别人是最好的，对于你也一定是最好的么？
对于自己想要什么，自己要最清楚，别人的意见并不是那么重要。很多人总是常常被别人的意见所影响，亲戚的意见，朋友的意见，同事的意见……问题是，你究竟是要过谁的一生？人的一生不是父母一生的续集，也不是儿女一生的前传，更不是朋友一生的外篇，只有你自己对自己的一生负责，别人无法也负不起这个责任。自己做的决定，至少到最后，自己没什么可后悔。对于大多数正常智力的人来说，所做的决定没有大的对错，无论怎么样的选择，都是可以尝试的。比如你没有考自己上的那个学校，没有入现在这个行业，这辈子就过不下去了？就会很失败？不见得。
我想，好工作，应该是适合你的工作，具体点说，应该是能给你带来你想要的东西的工作，你或许应该以此来衡量你的工作究竟好不好，而不是拿公司的大小，规模，外企还是国企，是不是有名，是不是上市公司来衡量。小公司，未必不是好公司，赚钱多的工作，也未必是好工作。你还是要先弄清楚你想要什么，如果你不清楚你想要什么，你就永远也不会找到好工作，因为你永远只看到你得不到的东西，你得到的，都是你不想要的。
可能，最好的，已经在你的身边，只是，你还没有学会珍惜。人们总是盯着得不到的东西，而忽视了那些已经得到的东西。 普通人 我发现中国人的励志和国外的励志存在非常大的不同，中国的励志比较鼓励人立下大志愿，卧薪尝胆，有朝一日成富成贵。而国外的励志比较鼓励人勇敢面对现实生活，面对普通人的困境，虽然结果也是成富成贵，但起点不一样，相对来说，我觉得后者在操作上更现实，而前者则需要用999个失败者来堆砌一个成功者的故事。
我们都是普通人，普通人的意思就是，概率这件事是很准的。因此，我们不会买彩票中500万，我们不会成为比尔盖茨或者李嘉诚，我们不会坐飞机掉下来，我们当中很少的人会创业成功，我们之中有30％的人会离婚，我们之中大部分人会活过65岁……
所以请你在想自己要什么的时候，要得“现实”一点，你说我想要做李嘉诚，抱歉，我帮不上你。成为比尔盖茨或者李嘉诚这种人，是靠命的，看我写的这篇文章绝对不会让你成为他们，即使你成为了他们，也绝对不是我这篇文章的功劳。“王侯将相宁有种乎”但真正当皇帝的只有一个人，王侯将相，人也不多。目标定得高些对于喜欢挑战的人来说有好处，但对于大多数普通人来说，反而比较容易灰心沮丧，很容易就放弃了。
回过头来说，李嘉诚比你有钱大致50万倍，他比你更快乐么？或许。有没有比你快乐50万倍，一定没有。他比你最多也就快乐一两倍，甚至有可能还不如你快乐。寻找自己想要的东西不是和别人比赛，比谁要得更多更高，比谁的目标更远大。虽然成为李嘉诚这个目标很宏大，但你并不见得会从这个目标以及追求目标的过程当中获得快乐，而且基本上你也做不到。你必须听听你内心的声音，寻找真正能够使你获得快乐的东西，那才是你想要的东西。
你想要的东西，或者我们把它称之为目标，目标其实并没有高低之分，你不需要因为自己的目标没有别人远大而不好意思，达到自己的目标其实就是成功，成功有大有小，快乐却是一样的。我们追逐成功，其实追逐的是成功带来的快乐，而非成功本身。职业生涯的道路上，我们常常会被攀比的心态蒙住眼睛，忘记了追求的究竟是什么，忘记了是什么能使我们更快乐。
社会上一夜暴富的新闻很多，这些消息，总会在我们的心里面掀起很多涟漪，涟漪多了就变成惊涛骇浪，心里的惊涛骇浪除了打翻承载你目标的小船，并不会使得你也一夜暴富。“只见贼吃肉，不见贼挨揍。”我们这些普通人既没有当贼的勇气，又缺乏当贼的狠辣绝决，虽然羡慕吃肉，却更害怕挨揍，偶尔看到几个没挨揍的贼就按奈不住，或者心思活动，或者大感不公，真要叫去做贼，却也不敢。 我还是过普通人的日子，要普通人的快乐，至少，晚上睡得着觉。
跳槽与积累
首先要说明，工作是一件需要理智的事情，所以不要在工作上耍个性，大话IT上或许会有人觉得你很有个性而叫好，煤气公司电话公司不会因为觉得你很有个性而免了你的帐单。当你很帅地炒掉了你的老板，当你很酷地挖苦了一番招聘的HR，账单还是要照付，只是你赚钱的时间更少了，除了你自己，没人受损失。
我并不反对跳槽，但跳槽决不是解决问题的办法，而且频繁跳槽的后果是让人觉得没有忠诚度可言，而且不能安心工作。现在很多人从网上找工作，很多找工作的网站常常给人出些馊主意，要知道他们是盈利性企业，当然要从自身盈利的角度来考虑，大家越是频繁跳槽频繁找工作他们越是生意兴隆，所以鼓动人们跳槽是他们的工作。所以他们会常常告诉你，你拿的薪水少了，你享受的福利待遇差了，又是“薪情快报”又是“赞叹自由奔放的灵魂”。至于是否会因此让你不能安心，你跳了槽是否解决问题，是否更加开心，那个，他们管不着。
要跳槽肯定是有问题，一般来说问题发生了，躲是躲不开的，很多人跳槽是因为这样或者那样的不开心，如果这种不开心，在现在这个公司不能解决，那么在下一个公司多半也解决不掉。你必须相信，90%的情况下，你所在的公司并没有那么烂，你认为不错的公司也没有那么好。就像围城里说的，“城里的人拼命想冲出来，而城外的人拼命想冲进去。”每个公司都有每个公司的问题，没有问题的公司是不存在的。换个环境你都不知道会碰到什么问题，与其如此，不如就在当下把问题解决掉。很多问题当你真的想要去解决的时候，或许并没有那么难。有的时候你觉得问题无法解决，事实上，那只是“你觉得”。
人生的曲线应该是曲折向上的，偶尔会遇到低谷但大趋势总归是曲折向上的，而不是象脉冲波一样每每回到起点，我见过不少面试者，30多岁了，四五份工作经历，每次多则3年，少则1年，30多岁的时候回到起点从一个初级职位开始干起，拿基本初级的薪水，和20多岁的年轻人一起竞争，不觉得有点辛苦么？这种日子好过么？
我非常不赞成在一个行业超过3年以后换行业，基本上，35岁以前我们的生存资本靠打拼，35岁以生存的资本靠的就是积累，这种积累包括人际关系，经验，人脉，口碑……如果常常更换行业，代表几年的积累付之东流，一切从头开始，如果换了两次行业，35岁的时候大概只有5年以下的积累，而一个没有换过行业的人至少有了10年的积累，谁会占优势？工作到2-3年的时候，很多人觉得工作不顺利，好像到了一个瓶颈，心情烦闷，就想辞职，乃至换一个行业，觉得这样所有一切烦恼都可以抛开，会好很多。其实这样做只是让你从头开始，到了时候还是会发生和原来行业一样的困难，熬过去就向上跨了一大步，要知道每个人都会经历这个过程，每个人的职业生涯中都会碰到几个瓶颈，你熬过去了而别人没有熬过去你就领先了。跑长跑的人会知道，开始的时候很轻松，但是很快会有第一次的难受，但过了这一段又能跑很长一段，接下来会碰到第二次的难受，坚持过了以后又能跑一段，如此往复，难受一次比一次厉害，直到坚持不下去了。大多数人第一次就坚持不了了，一些人能坚持到第二次，第三次虽然大家都坚持不住了，可是跑到这里的人也没几个了，这点资本足够你安稳活这一辈子了。
一份工作到两三年的时候，大部分人都会变成熟手，这个时候往往会陷入不断的重复，有很多人会觉得厌倦，有些人会觉得自己已经搞懂了一切，从而懒得去寻求进步了。很多时候的跳槽是因为觉得失去兴趣了，觉得自己已经完成比赛了。其实这个时候比赛才刚刚开始，工作两三年的人，无论是客户关系，人脉，手下，和领导的关系，在业内的名气……还都是远远不够的，但稍有成绩的人总是会自我感觉良好的，每个人都觉得自己跟客户关系铁得要命，觉得自己在业界的口碑好得很。其实可以肯定地说，一定不是，这个时候，还是要拿出前两年的干劲来，稳扎稳打，积累才刚刚开始。
你足够了解你的客户吗？你知道他最大的烦恼是什么吗？你足够了解你的老板么？你知道他最大的烦恼是什么吗？你足够了解你的手下么？你知道他最大的烦恼是什么吗？如果你不知道，你凭什么觉得自己已经积累够了？如果你都不了解，你怎么能让他们帮你的忙，做你想让他们做的事情？如果他们不做你想让他们做的事情，你又何来的成功？
等待 这是个浮躁的人们最不喜欢的话题，本来不想说这个话题，因为会引起太多的争论，而我又无意和人争论这些，但是考虑到对于职业生涯的长久规划，这是一个躲避不了的话题，还是决定写一写，不爱看的请离开吧。
并不是每次穿红灯都会被汽车撞，并不是每个罪犯都会被抓到，并不是每个错误都会被惩罚，并不是每个贪官都会被枪毙，并不是你的每一份努力都会得到回报，并不是你的每一次坚持都会有人看到，并不是你每一点付出都能得到公正的回报，并不是你的每一个善意都能被理解……这个，就是世道。好吧，世道不够好，可是，你有推翻世道的勇气么？如果没有，你有更好的解决办法么？有很多时候，人需要一点耐心，一点信心。每个人总会轮到几次不公平的事情，而通常，安心等待是最好的办法。
有很多时候我们需要等待，需要耐得住寂寞，等待属于你的那一刻。周润发等待过，刘德华等待过，周星驰等待过，王菲等待过，张艺谋也等待过……看到了他们如今的功成名就的人，你可曾看到当初他们的等待和耐心？你可曾看到金马奖影帝在街边摆地摊？你可曾看到德云社一群人在剧场里给一位观众说相声？你可曾看到周星驰的角色甚至连一句台词都没有？每一个成功者都有一段低沉苦闷的日子，我几乎能想象得出来他们借酒浇愁的样子，我也能想象得出他们为了生存而挣扎的窘迫。在他们一生最中灿烂美好的日子里，他们渴望成功，但却两手空空，一如现在的你。没有人保证他们将来一定会成功，而他们的选择是耐住寂寞。如果当时的他们总念叨着“成功只是属于特权阶级的”，你觉得他们今天会怎样？
曾经我也不明白有些人为什么并不比我有能力却要坐在我的头上，年纪比我大就一定要当我的领导么？为什么有些烂人不需要努力就能赚钱？为什么刚刚改革开放的时候的人能那么容易赚钱，而轮到我们的时候，什么事情都要正规化了？有一天我突然想，我还在上学的时候他们就在社会里挣扎奋斗了，他们在社会上奋斗积累了十几二十年，我们新人来了，他们有的我都想要，我这不是在要公平，我这是在要抢劫。因为我要得太急，因为我忍不住寂寞。二十多岁的男人，没有钱，没有事业，却有蓬勃的欲望。
人总是会遇到挫折的，人总是会有低潮的，人总是会有不被人理解的时候的，人总是有要低声下气的时候，这些时候恰恰是人生最关键的时候，因为大家都会碰到挫折，而大多数人过不了这个门槛，你能过，你就成功了。在这样的时刻，我们需要耐心等待，满怀信心地去等待，相信，生活不会放弃你，机会总会来的。至少，你还年轻，你没有坐牢，没有生治不了的病，没有欠还不起的债。比你不幸的人远远多过比你幸运的人，你还怕什么？路要一步步走，虽然到达终点的那一步很激动人心，但大部分的脚步是平凡甚至枯燥的，但没有这些脚步，或者耐不住这些平凡枯燥，你终归是无法迎来最后的那些激动人心。
逆境，是上帝帮你淘汰竞争者的地方。要知道，你不好受，别人也不好受，你坚持不下去了，别人也一样，千万不要告诉别人你坚持不住了，那只能让别人获得坚持的信心，让竞争者看着你微笑的面孔，失去信心，退出比赛。胜利属于那些有耐心的人。
在最绝望的时候，我会去看电影《The Pursuit of Happyness》《Jerry Maguire》，让自己重新鼓起勇气，因为，无论什么时候，我们总还是有希望。当所有的人离开的时候，我不失去希望，我不放弃。每天下班坐在车里，我喜欢哼着《隐形的翅膀》看着窗外，我知道，我在静静等待，等待属于我的那一刻。
原贴里伊吉网友的话我很喜欢，抄录在这里： 每个人都希望，自己是独一无二的特殊者 含着金匙出生、投胎到好家庭、工作安排到电力局拿1w月薪这样的小概率事件，当然最好轮到自己 红军长征两万五、打成右派反革命、胼手胝足牺牲尊严去奋斗，最好留给祖辈父辈和别人 自然，不是每个吃过苦的人都会得到回报 但是，任何时代，每一个既得利益者身后，都有他的祖辈父辈奋斗挣扎乃至流血付出生命的身影 羡慕别人有个好爸爸，没什么不可以 问题是，你的下一代，会有一个好爸爸吗？ 至于问到为什么不能有同样的赢面概率？我只能问：为什么物种竞争中，人和猴子不能有同样的赢面概率？ 物竞天择。猴子的灵魂不一定比你卑微，但你身后有几十万年的类人猿进化积淀。
入对行跟对人 在中国，大概很少有人是一份职业做到底的，虽然如此，第一份工作还是有些需要注意的地方，有两件事情格外重要，第一件是入行，第二件事情是跟人。第一份工作对人最大的影响就是入行，现代的职业分工已经很细，我们基本上只能在一个行业里成为专家，不可能在多个行业里成为专家。很多案例也证明即使一个人在一个行业非常成功，到另外一个行业，往往完全不是那么回事情，“你想改变世界，还是想卖一辈子汽水？”是乔布斯邀请百事可乐总裁约翰·斯考利加盟苹果时所说的话，结果这位在百事非常成功的约翰，到了苹果表现平平。其实没有哪个行业特别好，也没有哪个行业特别差，或许有报道说哪个行业的平均薪资比较高，但是他们没说的是，那个行业的平均压力也比较大。看上去很美的行业一旦进入才发现很多地方其实并不那么完美，只是外人看不见。
说实话，我自己都没有发大财，所以我的建议只是让人快乐工作的建议，不是如何发大财的建议，我们只讨论一般普通打工者的情况。我认为选择什么行业并没有太大关系，看问题不能只看眼前。比如，从前年开始，国家开始整顿医疗行业，很多医药公司开不下去，很多医药行业的销售开始转行。其实医药行业的不景气是针对所有公司的，并非针对一家公司，大家的日子都不好过，这个时候跑掉是非常不划算的，大多数正规的医药公司即使不做新生意撑个两三年总是能撑的，大多数医药销售靠工资撑个两三年也是可以撑的，国家不可能永远捏着医药行业不放的，两三年以后光景总归还会好起来的，那个时候别人都跑了而你没跑，那时的日子应该会好过很多。有的时候觉得自己这个行业不行了，问题是，再不行的行业，做得人少了也变成了好行业，当大家都觉得不好的时候，往往却是最好的时候。大家都觉得金融行业好，金融行业门槛高不说，有多少人削尖脑袋要钻进去，竞争激励，进去以后还要时时提防，一个疏忽，就被后来的人给挤掉了，压力巨大，又如何谈得上快乐？也就未必是“好”工作了。
太阳能这个东西至今还不能进入实际应用的阶段，但是中国已经有7家和太阳能有关的公司在纽交所上市了，国美苏宁永乐其实是贸易型企业，也能上市，鲁泰纺织连续10年利润增长超过50%，卖茶的一茶一座，卖衣服的海澜之家都能上市……其实选什么行业真的不重要，关键是怎么做。事情都是人做出来的，关键是人。
有一点是需要记住的，这个世界上，有史以来直到我们能够预见得到的未来，成功的人总是少数，有钱的人总是少数，大多数人是一般的，普通的，不太成功的。因此，大多数人的做法和看法，往往都不是距离成功最近的做法和看法。因此大多数人说好的东西不见得好，大多数人说不好的东西不见得不好。大多数人都去炒股的时候说明跌只是时间问题，大家越是热情高涨的时候，跌的日子越近。大多数人买房子的时候，房价不会涨，而房价涨的差不多的时候，大多数人才开始买房子。不会有这样一件事情让大家都变成功，发了财，历史上不曾有过，将来也不会发生。有些东西即使一时运气好得到了，还是会在别的时候别的地方失去的。
年轻人在职业生涯的刚开始，尤其要注意的是，要做对的事情，不要让自己今后几十年的人生总是提心吊胆，更不值得为了一份工作赔上自己的青春年华。我的公司是个不行贿的公司，以前很多人不理解，甚至自己的员工也不理解，不过如今，我们是同行中最大的企业，客户乐意和我们打交道，尤其是在国家打击腐败的时候，每个人都知道我们做生意不给钱的名声，都敢于和我们做生意。而勇于给钱的公司，不是倒了，就是跑了，要不就是每天睡不好觉，人还是要看长远一点。很多时候，看起来最近的路，其实是最远的路，看起来最远的路，其实是最近的路。
跟对人是说，入行后要跟个好领导好老师，刚进社会的人做事情往往没有经验，需要有人言传身教。对于一个人的发展来说，一个好领导是非常重要的。所谓“好”的标准，不是他让你少干活多拿钱，而是以下三个。</description>
    </item>
    
    <item>
      <title>Michael Barr </title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-09-03-399/</link>
      <pubDate>Mon, 03 Sep 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-09-03-399/</guid>
      <description>初次知道 Michael Barr 是因為讀了他寫的 Programming Embedded Systems in C and C++ 這本關於 embedded system programming 的書。後來陸陸續續在網路上找到蠻多他寫的技術文章，才發現他是 Embedded Systems Programming magazine (現已改名叫 Embedded Systems Design) 的前總編輯，難怪文筆相當不錯。我還蠻喜歡看他寫的東西，主要是他的文章都有假設讀者的程度，因此不會有一堆太基本的內容，或是過於複雜難懂的技術細節。
現在任職於顧問公司的 Michael 將他以前的一些文章集結整理起來在這裡，裡面內容對於從事 embedded system programming 的技術人員應該都頗有幫助。尤其是今天看完這篇 The Perils of Preemption配合下面這張圖，雖然內容都是已經熟悉的東西，經由 Michael 這樣的整理與講解，還是讓整個人有打通任督二脈的感覺：</description>
    </item>
    
    <item>
      <title>Beautiful Code</title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-08-18-394/</link>
      <pubDate>Sat, 18 Aug 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-08-18-394/</guid>
      <description>我想我最近這幾個月遇到人，大概第一件想做的事就是問他：『喂，你看了那本書了嗎？』 (路人：關我什麼事啊？)
看起來這本書在 Amazon.com 上蠻熱銷的，目前在 Software Development 類別的銷售排行榜上是第一名的，或許跟它的書名有些關係，這本書叫 &amp;ldquo;Beautiful Code&amp;rdquo;，畢竟 programmers 都忍不住會幻想讀了這本書後，功力大進，被人家稱讚 &amp;ldquo;Oh! Your code is beautiful.&amp;quot;。話說回來，這當然是不可能的事，programming 這件事雖然稱不上是藝術，但要達到一定的境界也需要一些天份、知識、經驗、與技巧，做的好的人當然夠資格被稱為大師或是達人。這本書基本上就是這些達人們描述他們遇到的問題，以及如何構思 beautiful code來解決這些問題。
另外一個吸引我的地方就是本書的作者群實力堅強，例如有大家熟悉的老牌技術作家如 Brian Kernighan, Jon Bentley, 及 Charles Petzold，也有 XML 的專家 Time Bray，Ruby 的作者 Yukihiro Matsumoto, Perforce 的 Laura Wingerd 及 Christopher Seiwald, Subversion 的 Karl Fogel, 推廣 JSON 的 Douglas Crockford, Greg Kroah-Hartman 是著名的 Linux kernel hacker，以及其他在不同領域有名的技術人員。
這本書雖然講的都是 coding，但是涵蓋的主體很廣，也是我這覺得這本書最獨特的地方，因為唯有從不同的角度來印證，你才能真正地了解什麼是 beautiful code。學校不會教你怎麼去欣賞好的 code，但是要成為一個好的 programmer，我認為這是必要的能力，畢竟我們不是天才，我們都是站在巨人的肩膀上看這世界。
不過別期待能很快看完這本書，每篇文章都需要蠻多時間去細讀及思考的 (我也只讀完幾篇而已)。</description>
    </item>
    
    <item>
      <title>Subversion 1.5 is coming</title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-08-05-389/</link>
      <pubDate>Sun, 05 Aug 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-08-05-389/</guid>
      <description>Subversion 要出 1.5 版了，我所期待的兩個重要功能： merge tracking 及 changelist 到時都會支援。
有了這兩個功能之後，Subversion 跟 Perforce 之間的主要差距就剩下了一個好用的 client application，TortoiseSVN 雖然還不錯，但離我心目中的理想境界還有一段差距啊。</description>
    </item>
    
    <item>
      <title>與所有的開發人員共勉之</title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-08-05-390/</link>
      <pubDate>Sun, 05 Aug 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-08-05-390/</guid>
      <description>引述自 Adam Barr 在 MSDN 的專欄文章：
我還是大四的學生時， 我記得有一位即將到投顧銀行上班的電腦科學系同學所說的話。他表示他只會參與軟體的設計，但是不會實際加入程式碼的撰寫工作，因為那太無趣。如此的工作應 該要交給程式撰寫人員 -- 顯然他認為程式撰寫人員是身分比較低等。當初那指的當然就是我囉。如此的談話發生在一所破解程式碼是最高榮耀的大學而言，讓我感到被羞辱的情緒。
然而，他也沒說錯。當初我只是一名程式撰寫人員 (雖然他的程式撰寫能力不見得比我好)。如今，就像 Mike Gunderloy 的書 Coder to Developer 所示，我已經從一般的程式撰寫人員晉升到開發人員。我不但知道如何撰寫可以順利編譯的程式碼；我創造的軟體產品還可以有：執行速度敏捷、可靠、通過完善測 試、安全、可維護性佳且易於全球化…以及其他高品質程式碼應有的特點。一般而言，整個軟體產業的龐大程式編寫人員組織，正在成長與演進為龐大的開發人員組 織。 但是，如果您詢問開發人員專業生涯的下一步，他們的答案 可能會是想要成為「架構設計人員 (Architect)」。所謂的「架構/結構設計」會令人聯想到鈦合金骨架和毛玻璃，而且相對的會把開發人員的身分影射成營建工人的角色。那麼我是否也 想要躍升到下一個理論性的階層，讓自己成為架構設計人員呢？答案是否定的。
這並非因為我瞧不起架構設計人員的職責：在軟體開發過程中協調所有系統元件的互動，同時考慮到整體目標 &amp;ndash; 這的確需要有人擔任。然而，身為開發人員我深感榮耀，而且我也誠懇地希望每一位開發人員都能感受到這樣的榮耀。
但是萬一有人仰慕實體架構設計師 Frank Gehry 或 Rem Koolhaas 在設計上享有的知名氣和自由度呢？我的回應會是，軟體工程設計的領域目前還不夠成熟，無法以這麼概念性的方式運作。架構設計人員可以設計如 Bilbao Guggenheim Museum 以及 Seattle Public Library 等的之名建築物，因為土木工程的領域已經累積有數百年的知識和經驗做為基礎和後盾。但是軟體產業無法一下子讓所有人都晉升到這個層次；畢竟我們大多數都還 在建構一棟不會在用力甩門既倒塌的平房。
當Microsoft 檢查程式的錯誤 (Bug) 時，發現設計性的錯誤 (亦即，架構設計人員審閱設計文件時會發現的錯誤) 佔據的比率很低，而且程式編寫錯誤 (亦即，程式碼無法根據程式設計人員的用意執行) 的比率也不高。會產生居中的類別，是因為雖然來源程式碼可以根據程式設計人員的用意執行，但是用意在進行當地語系化時發生錯誤 (應譯為：但是這些用意有些區域性的錯誤)：問題包括傳遞給方法的旗標有誤，或是曲解了組態參數的意思。而這些都不屬於架構設計人員可以處理的領域。這都是開發人員必須自行修正的事項。
Fred Brooks 在他的著名文章 &amp;ldquo;No Silver Bullet&amp;rdquo; 中有間接提到這項重點：「軟體的本質涉及連鎖概念的結構：資料集、資料項目的關係、演算法，以及函數的呼叫」，其中還包括：「我相信建構軟體最困難的部 分，在於擬定這些連鎖概念的詳細規格、設計以及測試，而非結構的呈現或精確度的測試。」由此可見，他認為關鍵並非在於結構設計人員，而是開發人員的工作。 換句話說，他認為程式編寫人員的工作不是很困難，但是開發人員的工作就有許多挑戰。因此，我們應該要肯定我們的價值。
我知道或許我們的工作不是整體程式設計的最高層次。能夠設計完美的結構，以精簡地封裝所有變數並因應未來的擴充需求，的確是一件令人振奮的成就。畢竟程式設 計人員都講求精確度，所以能夠讓所有組件順暢合併就是理想。但是軟體的創造其時有很多部分需要我們向熟練的工匠看齊：例如程式碼的審閱、撰寫單元的測試， 以及註解的清理。客戶或許無法直接認定是我們的辛勞，才能確保他們的隱私以及系統的防禦，但是我們都知道我們所提供的價值和重要性十足。此外，若要最佳化系統效能和電源管理，更需要黑手藝術的真材實料：這需要近距離接觸、以技能和經驗解決問題的實力，而非高階概念性的結構設計所能。
我要大聲說：身為開發人員而非結構設計人員是我的榮幸。或許在未來的某一天，所有的軟體工程問題都將獲得解決，讓我們都可以成為結構設計人員。在此之前，我們還是專注於如何持續加強軟體開發吧。</description>
    </item>
    
    <item>
      <title>XNA Game Studio Express</title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-05-20-388/</link>
      <pubDate>Sun, 20 May 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-05-20-388/</guid>
      <description>今天下載了 XNA Game Studio Express 來玩玩，不過微軟還是有點不乾脆啊，開發出來的遊戲要下載到 XBox 360 上還要繳 $99 的年費。 :-(
目前 Game Studio Express 只支援用 C# 搭配 XNA Framework 來開發遊戲 (或者其他應用程式)。</description>
    </item>
    
    <item>
      <title>BuildBot on Windows</title>
      <link>https://blog.simplypatrick.com/posts/2007/2007-05-06-387/</link>
      <pubDate>Sun, 06 May 2007 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2007/2007-05-06-387/</guid>
      <description>好久沒在 blog 上寫東西了，原因是忙著在新工作上進入狀況，這週末有點空就先寫一篇偷偷 po 上來，Jecky 接好囉&amp;hellip;
繼 TinderBox 後，最近玩了一下頗受歡迎的 BuildBot，架構比起 TinderBox 更有彈性，也更容易擴充。有興趣的可以參考這份簡報。
雖然 BuildBot 是用 Python 寫的，理論上在 Windows 上面跑應該是完全沒問題。試了一下，還是發現沒有想像中的順利，不過費了一番功夫，還是把它搞定了，想玩玩的人可以參考我寫的這份指引：buildbot p4 windows。</description>
    </item>
    
    <item>
      <title>The Best Programming Language</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-12-06-384/</link>
      <pubDate>Wed, 06 Dec 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-12-06-384/</guid>
      <description>UnSpun by Amazon: Best Programming Language
Ruby 遙遙領先第二名 Java，不過現在會去 UnSpun 逛的人大概都是 Ruby 迷吧，所以這樣的投票實在是不太公平了，就像是在德國投票選誰是史上最偉大賽車手一樣。 :-)</description>
    </item>
    
    <item>
      <title>OpenStreetMap</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-30-381/</link>
      <pubDate>Thu, 30 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-30-381/</guid>
      <description>Main Page - OpenStreetMap
使用 GPS 其中的一個問題就是地圖資訊的更新太慢了，我之前就有想過是否可以用 Wikipedia 的模式來維護一份全世界街道圖，沒想到真的有這樣的 project，看來離這樣的理想並不遠了。
台灣這麼地小，應該集眾人之力很快就可以完成吧。</description>
    </item>
    
    <item>
      <title>Encounter with the 20th Century Microelectronics</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-24-377/</link>
      <pubDate>Fri, 24 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-24-377/</guid>
      <description>11/27: 加了演講投影片的連結
今天公司請了施敏教授來演講『 Encounter with the 20th Century Microelectronics』，施教授不時幽默地猛打自己的廣告，給了大家許多笑點，但實際演講的內容也非常精采，讓人印象深刻的就是他的五個故事及五個體會：
以下摘自: IEEE Student Branch at National Taiwan University, Newsletter, April 2004 ■ NUMBER 2
故事一：施敏教授提到他年輕時，做有關於 Dielectric Constant 的實驗，發現所得的數值總 和文獻上所記載的 Dielectric Constant 不同，那時，心中有許多疑惑，然而，仍然 很堅信自己的實驗結果是對的，後來，發表了一篇有關於 Dielectric Constant 的文 章，自那篇 Paper 開始，往後做相關研究的人，都採用施敏教授所提的 Dielectric Constant。 體會一：不要盲從專家的結論。
故事二：博士畢業後，到 AT&amp;amp;T Bell Laboratories 工作，因為主管的因素，未能很順利的升 遷，因此，決定開始寫“Physics of Semiconductor Devices”一書，這一本書，深深影 響了全世界從事微電子領域的人，在 ISI Press 之中，引用超過 13000 次以上。 體會二：不要因為一些挫折而心灰意懶，殊不知這些挫折會帶來意想不到的機遇。
故事三：施敏教授回臺灣之後，與林培元先生、王常裕先生、邱在新先生成立了國內第一家 半導體公司－環宇電子公司，雖然後來並未繼續經營，但是栽培了許多重要的人， 例如羅益強先生、魏哲和教授都是環宇電子公司草創之初的人員。 體會三：某方面是失敗了，但另一面可能有更大的收穫。
故事四：臺灣在發展微電子產業之初，國內有許多反對的聲音，當時的孫運璿部長堅持這個 決定，後來立法院及國民大會都同意了這項決定。因為當年的堅持，臺灣的微電子 產業開始蓬勃發展起來，時至今日，臺灣在微電子領域，佔有非常重要的地位。 體會四：要有先見及信心，如果正確的事，不要因為太多人反對而改變。
故事五：西元 1967 年，施敏先生發明了“非揮發記憶體”，這在微電子的歷史中，佔有非常 重要的地位，“非揮發記憶體”為 20 世紀，四大半導體元件的一。今日，所有可攜 式的電子產品(如手機)，都不可缺少這個元件。 體會五：要實現你的目標，最重要是要有好奇心，要對自己正在做的事感興趣，而且要勤奮 工作。</description>
    </item>
    
    <item>
      <title>Farewell, again. :-)</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-10-371/</link>
      <pubDate>Fri, 10 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-10-371/</guid>
      <description>今天是在工作崗位上的最後一天，有點難過沒有辦法一一跟各位說聲再見。心裡實在是很感謝這半年來大家的照顧與指導，雖然大家走上不同的道路，還是希望彼此都能快樂地享受自己的旅程。
我一點也不會訝異我們會在某時某地巧遇的。</description>
    </item>
    
    <item>
      <title>Recursive Descent Parser in Ruby</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-08-368/</link>
      <pubDate>Wed, 08 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-08-368/</guid>
      <description>嗯嗯嗯&amp;hellip; 用 Ruby 來寫 recursive descent parser 真是妙，因為所有的 grammar 都可以用 Ruby 的語法來寫，換句話說，就是把 code 當成 data 來使用，例如：
start :expr do match(:expr, &amp;#39;+&amp;#39;, :term) {|a, op, b| a + b} match(:expr, &amp;#39;-&amp;#39;, :term) {|a, op, b| a - b} match(:term) end 要增刪一條 rule 非常地直覺與簡單，同樣的方式要用 C 來寫就麻煩多了。本來是想自己寫一份新的，但是看了 Dennis Ranke 的方法後，不知不覺就跟著他的方法一直抄了，我覺得不太可能寫得比他的版本更好了。下面是我的版本：
class Parser class Lexer TokenMatch = Struct.new(:name, :pattern, :eval) attr_accessor :pos attr_reader :matches def initialize @matches = [] end def add_match(name, pattern, eval) @matches &amp;lt;&amp;lt; TokenMatch.</description>
    </item>
    
    <item>
      <title>Ruby Quiz</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-06-364/</link>
      <pubDate>Mon, 06 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-06-364/</guid>
      <description>今天才發現原來有個 Ruby Quiz 網站，在上面每週會提供一個題目讓你思考及練習 Ruby programming 的技巧，對於有 programming language 的經驗但是沒有接觸過 Ruby 的人應該是不錯的學習方式。正如同網站所述：We use the Ruby Quiz to learn more about the Ruby programming language, not as a race. 就把它當作遊戲來玩玩吧。
這是我對 Quiz #28: Mad Libs 的解答：
class MadLibs def ask(word) print &amp;#34;Give me #{word}: &amp;#34; $stdin.gets.chomp end def play(file) keywords = {} story = file.read.gsub(/\(\((.+?)\)\)/) do word = $1 if word =~ /(.+):(.+)/ keywords[$1] = ask($2) elsif keywords.include?(word) keywords[word] else ask(word) end end puts print story end end raise &amp;#34;No template is given!</description>
    </item>
    
    <item>
      <title>My Second Ruby Program</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-05-363/</link>
      <pubDate>Sun, 05 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-05-363/</guid>
      <description>今天寫的一個 Ruby 程式，解 Interpreter 這個問題：
# PC/UVa IDs: 110106/10033 class Computer def initialize(file) @regs = Array.new(10, 0) @ram = Array.new(1000, 0) load_inst(file) end def load_inst(file) pc = 0 file.each_line do |line| line.chomp! line.strip! if line.length &amp;gt; 0 then @ram[pc] = line pc += 1 elsif pc &amp;gt; 0 break end end end MAX_INST = 1000 def execute executed = 0 pc = 0 opcodes = { &amp;#39;1&amp;#39; =&amp;gt; Proc.new { return executed }, &amp;#39;2&amp;#39; =&amp;gt; Proc.</description>
    </item>
    
    <item>
      <title>My First Ruby Program</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-03-361/</link>
      <pubDate>Fri, 03 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-03-361/</guid>
      <description>最近在學 Ruby，而要學一個 programming language 最快的方法就是動手去寫，可是工作之餘我又沒太多時間可以寫大一點的程式，因此我通常會找 Programming Challenges 裡面的題目來自娛。
下面的程式就是我的第一個 Ruby 程式： 解 Check The Check 這個問題：
class Chess @@capture = { &amp;#39;p&amp;#39; =&amp;gt; [[-1, 1, 1], [ 1, 1, 1]], &amp;#39;P&amp;#39; =&amp;gt; [[-1, -1, 1], [ 1, -1, 1]], &amp;#39;r&amp;#39; =&amp;gt; [[ 1, 0, 8], [-1, 0, 8], [0, 1, 8], [ 1, 0, 8]], &amp;#39;b&amp;#39; =&amp;gt; [[-1, 1, 8], [ 1, 1, 8], [1, -1, 8], [-1, -1, 8]], &amp;#39;n&amp;#39; =&amp;gt; [[-2, -1, 1], [-1, -2, 1], [1, -2, 1], [ 2, -1, 1], [2, 1, 1], [1, 2, 1], [-1, -2, 1], [-2, -1, 1]], &amp;#39;k&amp;#39; =&amp;gt; [[-1, 1, 1], [ 1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 0, 1], [0, 1, 1], [-1, 0, 1], [ 0, -1, 1]], &amp;#39;q&amp;#39; =&amp;gt; [[-1, 1, 8], [ 1, 1, 8], [1, -1, 8], [-1, -1, 8], [1, 0, 8], [0, 1, 8], [-1, 0, 8], [ 0, -1, 8]], } @@capture.</description>
    </item>
    
    <item>
      <title>Microsoft iPod</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-11-01-360/</link>
      <pubDate>Wed, 01 Nov 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-11-01-360/</guid>
      <description>從 Indigo 看來的：
 有夠好笑！</description>
    </item>
    
    <item>
      <title>Windows 1.0</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-31-358/</link>
      <pubDate>Tue, 31 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-31-358/</guid>
      <description>這&amp;hellip; 真的是 Steve Ballmer 嗎？</description>
    </item>
    
    <item>
      <title>Goodbye XAML</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-30-357/</link>
      <pubDate>Mon, 30 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-30-357/</guid>
      <description>Goodbye XAML, Hello AvalonBuilder
使用 RubyCLR 或是 IronPython 來跟 WPF 搭配應該是蠻有趣的，或許以後有人會為 WPF 搞個類似 Rails 的 framework 喔。</description>
    </item>
    
    <item>
      <title>Green Thread</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-29-356/</link>
      <pubDate>Sun, 29 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-29-356/</guid>
      <description>jGuru: What is the difference between green threads and native threads?
突然看到 green thread 這個詞愣了一下，想說那時候有這種東西的。說穿了，就是 Sun JVM 裡的 user-level thread。</description>
    </item>
    
    <item>
      <title>Getting Real</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-27-354/</link>
      <pubDate>Fri, 27 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-27-354/</guid>
      <description>因為 Ruby on Rails 而聲名大噪的 37signals 出了一本書叫《Getting Real》來宣傳他們如何快速地開發小型 web application 的方法，內容涵蓋組織、市場、需求、流程、設計、實作、宣傳、定價、客戶支援等等。
我只有大致瀏覽過內容，不過就可以感受到 Getting Real 的精神其實也正反映在 RoR 的設計上，也跟 Agile Methodology 的理念相當契合。 讓我不禁想起這句話『It&amp;rsquo;s not the gig that eat the small&amp;hellip;It&amp;rsquo;s the fast that eat the slow』。 我個人相當推薦閱讀，但我不建議盲目地遵循這些規則，我向來認為如果這些東西能刺激一些新的思考，進而造成實際工作的改進，那就值得了。
37signals 真是頗屌的一家小公司。</description>
    </item>
    
    <item>
      <title>Tinderbox3</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-22-352/</link>
      <pubDate>Sun, 22 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-22-352/</guid>
      <description>我也算是 Tinderbox 的愛用者了，從難裝地要命的第一版、大幅改寫的 Tinderbox2、到最新的 Tinderbox3 我都玩過。John Keiser 設計的第三版架構上蠻不錯的，幾乎所有的客製化都只需要修改用戶端，只要會寫 Perl script 很快就可以上手修改成想要的樣子。
Tinderbox 主要的目的當然就是用來實現 Continuous Integration，因為我們的產品是同一份 code 必須同時編譯成在不同 Windows Mobile/Desktop 平台的執行碼，很容易就有人﹝其實是我﹞不小心 check-in 一份只能在某個平台上編譯成功的 code。例如下面這畫面就是有人不小心加入了在 Windows Desktop 不能成功編譯的 code：
我做的更改主要是是讓它可以偵測 Perforce 上的 check-in 動作，一旦有任何的更改，負責建置版本的機器馬上會醒過來為各個平台重新編譯最新的程式碼，如果一旦發現有任何編譯或是聯結的問題，它就會自動發信來提醒有嫌疑的更改者。另外一個小更改就是把 nightly build 的功能加上去，其實只是在每天深夜會自動醒來並重新編譯所有的 code，編譯成功後把可安裝的版本依日期放置到固定的地方，QA 就能夠每天拿到熱騰騰的版本來進行各種測試啦。
設置這些東西所需要花的時間及資源其實很少，但之後省下的麻煩就是讓我願意花時間從第一版試到第三版的最重要原因。</description>
    </item>
    
    <item>
      <title>git: content addressable filesystem</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-17-351/</link>
      <pubDate>Tue, 17 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-17-351/</guid>
      <description>今天花了點時間玩了一下 git，頗有趣，我想 git 應該會成為 subversion 之外的另一個主流。因為 git 的版本號碼不再是傳統的數字編號，而是如 e2659fcf690ec693c04c82b03202fc5530d50960 這樣的十六進位數字，真是有點不習慣，還好這樣的版本號碼只要沒重複到是可以簡稱的，例如 e2659f，不然的話光打這些字就會被搞死了。
不過還是有點概念沒搞清楚，這幾天再練習看看囉。</description>
    </item>
    
    <item>
      <title>Bad Comments in Code</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-16-349/</link>
      <pubDate>Mon, 16 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-16-349/</guid>
      <description>推薦讀一下我學弟的這篇文章《Use SVN as local repository》，強調是我學弟當然是我想沾一點光，不過文中的 Patrick 不是我啦。 :-)
我個人是對於在程式裡留下一堆被註解掉的 code 是相當感冒的，原因是這些 code 根據個人經驗有 99.9% 的機率不會再被用到，那幹嘛放在那裡混淆後來讀這份 code 的人？尤其是用了版本控制系統後，這種作法更是沒有必要。
另外一種類似的問題就是有人特別喜歡在程式碼裡面簽名，例如 /* 06-01-01 modified by XXX */ 這類的，尤其是在那種有很多人可能會一起改到的或是歷史悠久的檔案，這些人名比程式碼還顯目刺眼，尤其當每個人的簽名格式都不一樣，甚至個人的簽名風格還會隨時間改變時 (暈&amp;hellip;)。背後的原因不外是能夠在發生問題的時候能找到原作者來解決，問題是這種類似 CVS blame 的功能絕大多數的版本控制系統都有提供 (你可以丟了這個系統，假如它沒有這個功能的話) ，加上這些註解只是妨礙程式閱讀的流暢度罷了。
所以老實說，讀起許多 open-source project 的程式碼實在是比工作時讀的舒服多了，因為至少大家都還有 &amp;ldquo;code should be written for readability.&amp;rdquo; 的觀念。</description>
    </item>
    
    <item>
      <title>Every Software Project Needs: MPUT</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-16-350/</link>
      <pubDate>Mon, 16 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-16-350/</guid>
      <description>一份關於軟體開發的 presentation by Jim Kent，是 google 時無意發現的，寫的很棒，主題是任何成功的軟體專案都需要下面四個條件：
 A sense of the users Wise managers Pragmatic programming Thorough testing  </description>
    </item>
    
    <item>
      <title>Embedding Grapics in RTF</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-13-347/</link>
      <pubDate>Fri, 13 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-13-347/</guid>
      <description>今天發現用 docbook2rtf 做出來的 RTF 檔不支援內嵌圖片，google 了一下，發現了有個 Perl script 可以做這樣的轉換：RE: Embedding graphics in RTF
有需要的自行剪下程式存檔執行即可：
# Perl # $Header: /usr/local/cvs/test/dde/publish/Scripts/word-update-all.pl,v 1.3 1999/06/17 15:21:58 Andrei Exp $ my $no_list_file = 0; while ( $#ARGV &amp;gt; 0 ) { $_ = $ARGV[0]; SWITCH: { /^\-\?$/ &amp;amp;&amp;amp; do { usage (); return -1; }; /^\-f$/ &amp;amp;&amp;amp; do { shift; $list_file = shift; last SWITCH; }; /^\-f\-$/ &amp;amp;&amp;amp; do { shift; $no_list_file = 1; last SWITCH; }; /^\-i$/ &amp;amp;&amp;amp; do { shift; $in_path = shift; last SWITCH; }; /^\-o$/ &amp;amp;&amp;amp; do { shift; $out_path = shift; last SWITCH; }; /^\-v$/ &amp;amp;&amp;amp; do { shift; $visible = 1; last SWITCH; }; usage (); print &amp;#34;Unknown command line argument.</description>
    </item>
    
    <item>
      <title>Google /* Code Search */</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-12-345/</link>
      <pubDate>Thu, 12 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-12-345/</guid>
      <description>呵呵&amp;hellip; 這個 programmer 看了應該都不覺莞爾吧：Funny results from Google Code Search ? shakalaca
不過以後要找 sample code 就容易多了吧&amp;hellip; :-)</description>
    </item>
    
    <item>
      <title>Management By Objectives</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-10-11-344/</link>
      <pubDate>Wed, 11 Oct 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-10-11-344/</guid>
      <description>原來 MBO 就是杜拉克搞出來的：
 觀點4：目標管理與自我控制　Management by Object and Self Controls 在杜拉克的「發明清單」中，最常被提及、或許也可說是最重要及影響最深遠的一個概念，就是目標管理（management by objectives）；而透過目標管理，經理人便能做到自我控制（self-control），訂定更高的績效目標和更宏觀的願景。不過，杜拉克也認為，由於企業績效要求的是每一項工作都必須以達到企業整體目標為目標，因此經理人在訂定目標時，還必須反映企業需要達到的目標，而不只是反映個別主管的需求。 目標管理之所以能促使經理人達到自我控制，是因為這個方式改變了管理高層監督經理人工作的常規，改由上司與部屬共同協商出一個彼此均同意的績效標準，進而設立工作目標，並且放手讓實際負責日常運作的經理人達成既定目標。乍看之下，目標管理和自我控制假設人都想要負責、有貢獻和獲得成就，而非僅是聽命行事的被動者。然而，雖然經理人有權、也有義務發展出達成組織績效的諸多目標，但是杜拉克也認為高階主管仍需保留對於目標的同意權。
這種「上對下」的思維，使得目標管理到了 1980 年代初期，開始陷入陰影，有些人則認為這樣的管理方式太過理性與僵硬，因為如果所有的指令最終仍舊來自於最上面的少數高階主管，將使得真正了解市場與產品的一般員工產生無力感。例如，品質管理大師戴明（W. Edward Deming）便將杜拉克所說的「目標」解讀為「配額」（quota），認為那就好像「交通警察每天都要開出一定數量的違規罰單」。
杜拉克自己在往後也修正了自己的看法，主張透過減少組織決策層級與賦權（empowerment），將決策權交還給員工。甚至到了 1990 年代，他還自嘲目標管理只是一個工具而已，並無法解救管理上的效率不彰。他說，「當你清楚知道目標為何時，目標管理才會奏效管用，但十次裡面有九次，人們根本就不知道目標為何。」
雖然目標管理遭受批評，但是這個概念和賦予員工決策權並非全然對立，因為他在主張高階主管應該要為部屬訂定目標的同時，也鼓勵部屬有權決定如何達成目標，其目的乃是在於剔除全面的控制與監督，對於經理人將重心從努力工作、提升專業，轉移至專注於提升生產力與產出，極有貢獻。
資料來源：Manager Today 經理人月刊
 為什麼公司不把早就流於形式的 MBO 廢掉呢？</description>
    </item>
    
    <item>
      <title>Josh Bloch on Design</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-09-25-342/</link>
      <pubDate>Mon, 25 Sep 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-09-25-342/</guid>
      <description>不是什麼新的技術，Joshua Bloch 談的是更基本但也更重要的 API Design：How to Design a Good API and Why it Matters。
其實軟體開發者的大部分工作就是和一大堆的 API 打交道，我是最討厭使用那種設計不良的 API，因為往往要用更多的 client code 來完成功能或者避過設計的缺陷。怎麼去設計“良好的 API”正是所有軟體開發者要必備的技巧，Joshua 所提出的這些設計準則，都是相當值得參考學習的。
另一篇 Joshua 的訪談：Josh Bloch on Design。</description>
    </item>
    
    <item>
      <title>ARM&#39;s way</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-09-24-341/</link>
      <pubDate>Sun, 24 Sep 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-09-24-341/</guid>
      <description>ARM 除了產品的設計優異之外，主要的成功之道大家都曉得是在於他們只提供 IP core 的授權，而不從事實體 chip 的製造。這篇刊登於 Electronics Weekly 1998 四月號的文章描述了 ARM 的起源：ARM&amp;rsquo;s way。</description>
    </item>
    
    <item>
      <title>Embedded Programming with Eclipse</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-09-24-340/</link>
      <pubDate>Sun, 24 Sep 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-09-24-340/</guid>
      <description>James P. Lynch 寫了一本圖文並茂、詳細到不行的 ARM 與 Eclipse 開發指南：ARM Cross Development with Eclipse，主要著重在開發環境的安裝、設置、與使用。由於 Eclipse 具有免費、跨平台、開放的架構、強大的開發社群，embedded system 的開發環境慢慢移至 Eclipse 平台相信將會是大勢所趨。
不管你是從事甚麼樣的軟體開發工作，精通手頭上的開發工具絕對是做好事情的必要條件，而 Eclipse 就是個值得投資時間去熟習的工具，強力推薦這篇文章給有興趣於 embedded programming 的初學者。</description>
    </item>
    
    <item>
      <title>IVII, Goodbye!</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-09-04-338/</link>
      <pubDate>Mon, 04 Sep 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-09-04-338/</guid>
      <description>從學校畢業不久後，因緣際會地加入了高速成長中的 InterVideo，從事與多媒體相關的軟體開發工作。雖然它從未達到自己心目中理想軟體公司的標準，但自己在其中也投入了不少心血。六年下來，不管是好的或是壞的經驗，我都從中學到了許多東西。如今 InterVideo 即將於年底被 Corel 收購而走入歷史，雖然有點感傷，但何嘗不是自己工作生涯的另一個轉換契機。</description>
    </item>
    
    <item>
      <title>Programmer&#39;s Font</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-09-03-337/</link>
      <pubDate>Sun, 03 Sep 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-09-03-337/</guid>
      <description>我一直是那種對於程式碼字型很挑剔的那種人，因此這幾年都是 Courier New 的愛用者，因為它在不開 ClearType 的情況下還是能顯示非常清晰的程式碼，雖然ㄧ直覺得它給人的感覺硬了一點：
當然程式碼字型的美醜是有點見仁見智的問題，我甚至也看過用非固定寬度字型的 programmer，他說這樣同一行就可以顯示更多的程式碼。不過我還是喜歡傳統固定寬度的字型，程式排列起來比較有條理也容易看清楚。Courier New 好是好，但我總想找一個更漂亮的程式碼字型。直到有次到某家合作夥伴去討論一些技術細節，發現他用的程式碼字型非常好看，我也就跟著變心用起 Bitstream Vera Sans Mono 這個字型了：
但是 Bitstream Vera Sans Mono 唯一的缺點是必須在打開 ClearType 的狀況下才會漂亮。
另外一個值得推薦的是 Microsoft 即將於 Vista 中提供的 Consolas。</description>
    </item>
    
    <item>
      <title>On New Web Applications...</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-08-21-336/</link>
      <pubDate>Mon, 21 Aug 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-08-21-336/</guid>
      <description>Joel 跟 Paul Graham 分別對一些新興 web application 的看法：
Joel on Software - Too Many Ajax Calendars
 They&#39;re building calendar companies to sell to Yahoo!, which, for some reason, has given up on the old concept of hiring programmers to write code, and is going with this new age concept of buying entire companies on the hopes that they might contain a good programmer or two, which, by the way, is a sure sign of trouble for a technology company.</description>
    </item>
    
    <item>
      <title>從台大與Google看資訊世界</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-05-06-334/</link>
      <pubDate>Sat, 06 May 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-05-06-334/</guid>
      <description>李開復在臺大的演講：從台大與Google看資訊世界。關於 Google 的東西大家已經聽的太多，難得的是可以一睹這位傳奇人物的風采。</description>
    </item>
    
    <item>
      <title>無限的你</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-05-06-333/</link>
      <pubDate>Sat, 06 May 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-05-06-333/</guid>
      <description>原文出自： http://www.montejade.org/images/SVA/83/images/MJ_January_2006.pdf
 勵志篇-燃起心中那把火 發揮“無限的你”
燃起心中那把火 發揮“無限的你”
吳田玉博士對工研院菁英團演講文(美西玉山科技協會通訊第194期 / 2006年1月號)
本會理事吳田玉博士，是臺灣著名封裝公司日月光公司的美國及歐洲總裁，2005 年底剛被發表為日月光公司營運長。他於十二月九日受邀對來訪矽谷的工研院菁英團演講「無限的你」，言談輕鬆幽默，帶動全場陣陣笑聲，內容精彩，相當具啟發與鼓舞性，令每一位聆聽的人都印象深刻。本會特整理該演講成文，以分享讀者。──編者
「大家是臺灣科技研究界的菁英，」吳田玉的第一句話就帶起菁英團員們一陣快樂的笑聲，「你們不要笑，菁英的定義不就是你比其他人懂的多一些嗎？」從事研究多年出身的吳田玉博士在一個半小時的演講中，以自身為例子，語重心長的鼓勵在座的研究界青年菁英要好好發揮自己才華，點燃心中那把火，發揮無限量的自己。
吳田玉演講全文如下：
日月光集團今年的營業額是27 億美金，有三個事業群，封裝、測試和材料。日月光從高雄起家，逐漸擴展至中壢、韓國、馬來西亞、新加坡、北美、日本，也在大陸積極佈局，目前有五千名員工在上海，如果政府可以在2006 年核准在大陸做substrate，則公司會有另一番新的佈局。目前，日月光集團在全球有三萬六千位員工。
我是台大畢業，在陸戰隊服役兩年後，留學美國在賓州大學念碩、博士，教了一年書，於1989 年加入IBM 研發中心，待了六年，寫了二十多篇報告，有十二個專利。忽然覺得做研究沒意思，人生乏味，我想這樣的日子下去，再二十年，再寫三十個專利，五十篇報告，對人生有何意義與貢獻？我就去找老闆談我的人生規劃。
老闆問我：「你知道你想做什麼？」我說我不知道。「為何你不想做現在的事？」他問。他要我回去想兩星期。兩週後，我再去看他，我告訴他我做研發、寫專利，雖然寫的很好，但並不快樂，也許這個世界上有更吸引我的東西，我必須走出目前的框框。去那裡？我不知道，但東西南北都好。
老闆派我去做生產，我就到製造部門做了二年，啟發很大，在英國一年，在義大利一年。以前做研發，覺得我是世界上最聰明的人，一台電腦、一支鉛筆、一張紙，可以做出許多東西，在我看來在工廠生產的人都是當年數學沒學好的人。但我真的到工廠做生產，才發現自己是手無縛雞之力。一個生產線機器壞了，我還要看操作手冊，要調溫度、調距離的，我一個星期修不好，但一個技工來，二分鐘就調好了。在生產部門，廿四小時隨時有電話召喚，壓力很大，生產一個產品，萬一機器中途停機造成斷線怎麼辦？
在生產部門這兩年，我學了兩件事。第一就是人不分高低貴賤，你數學好、你物理好，不代表你過人一等，以前研發的東西，無法進行實際生產，在實驗室、在紙上做的很漂亮，但卻無法賣。我忽然發現自己數學、物理再好，從小父母師長再稱讚都沒用了。我學的第二件事就是實際的世界與自己的認知有所差距。以前以為英國人道貌岸然，但我實際接觸發現並非如此，人就是人，英國人不是中國人，但英國人也決不是我們在小說中、教科書、義和團事件所認知的英國人。義大利人不是英國人，也不是中國人，他們熱情洋溢，生活中所喜好的與英國人、與中國人並不一樣。例如同一句”請”字，三國的人聽到的確是不一樣的意思。
二年在歐洲的生活使我感到世界之大，必須走出去，否則自己的知識領域與生活經驗是脫節的，我們沒能把真正的生命活出來。二年之後，我再去找老闆說這兩年我很投入、很喜歡這工作，但這工作不適合我，壓力太大。既然東邊去過了，我就向西走，老闆就送我去亞洲當銷售。我飛到台灣，臺灣的老闆問我「你會不會喝酒？」我說我不會，而且會昏倒。「你會不會打高爾夫球？」我說不會，沒打過。「你會不會卡拉OK？」我說不會。他說：「那你為何來亞洲做銷售工作？」我說我有研發經驗、有生產經驗，有對人的敏感，我知美國人如何想，也部份知道歐洲人如何想？也許與一般銷售人員不一樣。這位臺灣老闆就試用我。
我在IBM 亞太地區做了四年的銷售工作，我所屬之部門從7 個人變成49 個人。四年之中，營業額從330Million 到1Billion，有三倍的成長。四十歲那年，我人在新加坡住著大房子，有司機、有佣人、有游泳池，薪水兩倍，又有生活加給，認為錢不是一回事，我又不快樂了，決定又要換工作。這樣一個表現傑出又忠誠，而且待遇優厚的人，IBM 問我為何要離開？
當時日月光亞太區的營業額是十億美金，IBM 有八百八十億美金，我自己的事業群有七十億。日月光要我做行銷 (Marketing)，只有我一個人。我認為在美國公司做事有「玻璃天花板｣，不論如何努力，總覺不太對。結果，我在2000 年毅然離開IBM，到了日月光擔任銷售副總裁。
接著， 吳田玉以「無限的你」(Theunlimited you)為題發表演講。
無限的你 (The Unlimited You) 今日我們來討論三件事：Who are you? The Unlimited You, Food for Thought
Who are you? 你是誰？當我們去任何一個會議時，人家會問你是誰？要你自我介紹。一般人往往交換名片，其實這個名片介紹你的只是一個job，並不是你，但因只有兩秒鐘介紹也只好如此，沒關係，但三十分鐘後，人家記得你什麼呢？所以你腦中必須要有一個故事來介紹你自己，這是要點，要讓別人對你印象深刻。
你知道你是誰嗎？以我為例，我今年48 歲，小學時，爸爸要我這樣介紹自己，我是吳田玉，將來要進大同中學、建中、臺大，要留學拿博士。30 歲時，我拿了博士，有一天我問自己拿博士幹什麼？有何意義？後來我在IBM 工作，我有很多專利，我年年得獎，但我問自己我為何要做專利？到新加坡後，賺了一筆錢，我又在問我自己是誰？今天在日月光，我還在問自己這個問題。「這個工作真的是我喜歡的嗎？」要探討這個問題，解決了後，接下來的問題就不是那麼大。
The Unlimited You 臺灣教育是個極端矛盾的教育，我母親每天與人介紹她兒子多聰明、她女兒多漂亮，但當我拿個99 分回去，我媽就打我；我說我考第一名，我媽說他不管我第一名、第二名，但就是打我99 分。我媽在同事面前就說：「我兒子很笨」，可是我不在時，她就說她兒子多聰明。臺灣的父母如此、老師如此、長官也如此，在背後稱讚，但不在當面稱讚。很少有人在會議中誠心稱讚對方，說「你的確比我高明」，對同事、對屬下、對老闆都要常當面的稱讚。你說我太太只會生小孩，其他都不會，你的婚姻能存在多久？
我們從小所受的教育是很受限制的，我小學六年級騎腳踏車去遠足，我媽不讓我去，她說萬一我發生什麼事，她怎麼活？這話你一定聽的很多，父母說、妻子也說。臺灣的教育是：你這個不能做，那個不能做，因為你還沒長大、你還沒成熟、你會被騙。但在美國的教育就是將小孩放出去，像野狗一樣，可是能活著回來的就很厲害。所以在臺灣兩個極端式的教育就把我們局限在框框裡。今天我要跟你們說的是「你們不是研發的人，你一定要從研發為基礎走出你的路，因為你是無限的你，你不是只有研發的你。」
Food for Thought 我常看書及節錄一些東西，看看前人講的話常給我一些啟迪。以前看孟子「吾日三省吾身」，我不明白，現在我天天做這件事。我每天待人接物，常反省自己是否講錯話？做錯事？這些錯有些很微小，不仔細想就不知道。舉例來說，你有沒有發現你對某些人喜歡，對某些人不喜歡，你喜歡某些餐廳(也許那餐廳又貴又遠)、你不喜歡某些餐廳(縱然那餐聽又便宜又好吃)。因為，當你與那人接觸時，已經在所做的事情之前預先加了正號或是負號。各位都有交女朋友的經驗，有些女孩子又漂亮，家中又有錢，又有修養，皮膚又白，但你就是不喜歡她，或她就是不喜歡你。有時那個男孩又矮又胖又醜，太太卻很漂亮，為什麼？因為這個女孩子或男孩子在那個關鍵時刻裏，做了一件對的事，於是在所有的事情前面被加了正號或是負號。所以，「我如何待人接物，讓我所有以後的事情都加上正號？」
一個最淺顯的例子，你看見一個女孩，「喂，妳好像胖了？」那妳以後都是負號了，這是很簡單的道理。有人無法見到別人的好，例如孔雀開屏時，你要因為美麗而多稱讚，不要跑到後面去說：「屁股上沒毛」。一個工程師花了三年做了一個研究報告，你跑去說那個數字不對、那個符號不對。人家在向你陳述一件事情時，你不要在雞蛋裡挑骨頭，不要見樹不見林，不要做一些事在所有的事情上面加一個負號。所以要常常反省自己。</description>
    </item>
    
    <item>
      <title>Books on Embedding System Programming</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-04-01-329/</link>
      <pubDate>Sat, 01 Apr 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-04-01-329/</guid>
      <description>在辭掉工作短暫休息的這段時間，我讀完了這本《MicroC OS II: The Real Time Kernel 》。會想要去讀它的原因是因為既然要做嵌入式系統的開發，那就必須對 RTOS 的特性有相當程度的掌握，而最快的方式莫過於直接去深入了解一個 RTOS 的實作，而短小精幹的 MicroC/OS-II 因為有原作者的詳細解說，當然是最適合學習的目標。老實說，讀這本書前，自己對於即時系統的一些概念是似懂非懂，但是看完這本書之後卻是豁然開朗。我覺得這本書更適合作為一般學校基礎 OS 的教材，之前大學上的 OS 課程都太理論性了，有點後悔當時沒有去修即時系統的課。強力推薦這本給想要自修學習 RTOS 的人。
另外一本的入門好書則是 David E. Simon 寫的《An Embedded Software Primer》。這本書關於 RTOS 的部分我是覺得沒有前一本講的清楚，但是可讀性倒是高了些，畢竟這本書就是要給入門者看的。後面關於 embedded software design, development, 及 debugging 的觀念我覺得寫的相當不錯，一樣推薦給想要了解 embedded system programming 的人。</description>
    </item>
    
    <item>
      <title>Andrew S. Tanenbaum on Teaching Computer Science</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-03-27-327/</link>
      <pubDate>Mon, 27 Mar 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-03-27-327/</guid>
      <description>從 iSee&amp;rsquo;s Blog! 看到的：在 1997 年的 SIGCSE，Andrew S. Tanenbaum 的演說 TEN GOLDEN RULES FOR TEACHING COMPUTER SCIENCE：
 Think long term Emphasize principles, not facts Expect paradigm shifts Explain how things work inside Show students how to master complexity Computer science is not science Think in terms of systems Keep theory under control Ignore hype Don&amp;rsquo;t forget the past  這是他近十年前講的東西了，到今天看起來還是很對，其中的道理更是每天可以用在工作上的。以前讀書的時候就很喜歡 Andrew 寫的書，例如《Computer Networks》及《Modern Operating Systems》都是我心目中的經典之作。
聽說他最近又開始搞 Minix3 了，主要是作為開發手持行動設備及嵌入式環境的作業系統。或許有人說作業系統已經是老掉牙的題材了，因為我們已經有了 Windows 或 Linux，搞作業系統還有前途嗎？喔喔，至少在各式各樣嵌入式裝置盛行的今天，我不這樣認為。我並不是要你去發明一個新的作業系統 (那是需要一點天份的)，但是至少要搞清楚它的運作原理。Andrew 也告訴我們 &amp;ldquo;Don&amp;rsquo;t forget the past&amp;rdquo;，不是嗎？</description>
    </item>
    
    <item>
      <title>kludge</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-03-24-325/</link>
      <pubDate>Fri, 24 Mar 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-03-24-325/</guid>
      <description>這種東西就叫 kludge: klumsy, lame, ugly, dumb, but good enough。</description>
    </item>
    
    <item>
      <title>Catch-22</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-03-04-318/</link>
      <pubDate>Sat, 04 Mar 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-03-04-318/</guid>
      <description>正如朋友所說的，最近的際遇好像陷入了 Catch-22 循環了：『我找不到工作因為沒有相關經驗，但我沒有工作怎麼會有相關經驗』，用 programming 的術語說也就是遇到 deadlock 了。
不過實際狀況也沒那麼慘啦，履歷才投了一家公司，而且又是很多人想去的公司，因為沒經驗被拒絕是正常的。雖然如此，我還是要為自己辯解一下，引自從『A 到 A+』這本書：
 在決定誰才是適合的人才時，從優秀到卓越的公司重視個性甚於教育背景、專業知識、技能、或工作經驗。這並不表示，專業知識和技能不重要，但是，他們認為專業知識與技能都是可以傳授的(或可以學習的)，然而個性、工作倫理、基本智商、能否堅守承諾，和價值觀等卻早已深植人心，很難改變。
 從我工作這幾年的經驗，我是相當認同這個理念。或許是自己太信心滿滿了，對於第一次求職被拒絕感到有點錯愕，不管如何，只好繼續努力囉。</description>
    </item>
    
    <item>
      <title>New Stuff for Programtic Programmers</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-02-26-313/</link>
      <pubDate>Sun, 26 Feb 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-02-26-313/</guid>
      <description>Pragmatic Bookshelf 又有一些新書了：
 Behind Closed Doors: Secrets of Great Management (Pragmatic Programmers) by Johanna Rothman, Esther Derby Ship it! A Practical Guide to Successful Software Projects by Jared Richardson, William Gwaltney My Job Went to India: 52 Ways to Save Your Job (Pragmatic Programmers) by Chad Fowler  這三本似乎蠻有趣的，評價也不錯。我應該會買下來，趁著最近離職的空檔讀一讀。</description>
    </item>
    
    <item>
      <title>珍重再見！</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-02-25-312/</link>
      <pubDate>Sat, 25 Feb 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-02-25-312/</guid>
      <description>感謝大家在我臨走前還送我東西，而且就是我一直想買的 iPod nano！心裡實在是感動，還有人願意送禮物給自認為做人不太成功的我。
在 IVI 的這兩千多個日子，心裡一直是認為『做事』重於『做人』，一方面是因為自己個性使然，一方面是想說大家把事情做好了，有了成就感、工作心情愉快、個人跟公司都發財，實在是比任何事更重要。如今，臨別在即，如果以前有任何做的不好的地方，就請大家多擔待了。
職場上的來來去去難免，重點不在於你今天在那裡，而是在於你做了什麼。回頭想想，除了程式碼外，自己是否留下了什麼東西給大家？如果有那麼一點點的痕跡的話，我會希望是『對工作的熱情』：做你所愛，愛你所做。如果今天自己有任何小成就，那都是因為我對軟體開發的熱情所致。今天離開了公司，並不是這份熱情有任何稍減，反而是激勵自己以後要做的更好，不然就對不起自己與大家了。
對於跟我關係最密切的幾名工作夥伴：Aris, Wayne, Evan, Eric, 及 Kimi，謝謝你們過去容忍我的許多缺點，也期許你們在工作上精益求精，持續保持我們小組當時做 WinDVD Creator 時的衝勁，別讓我失望喔。</description>
    </item>
    
    <item>
      <title>MeWare, ThemWare, and UsWare</title>
      <link>https://blog.simplypatrick.com/posts/2006/2006-02-09-306/</link>
      <pubDate>Thu, 09 Feb 2006 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2006/2006-02-09-306/</guid>
      <description>Eric Sink 另外一篇有趣的文章《Yours, Mine and Ours》，講的是軟體開發者與使用者之間的認知落差。</description>
    </item>
    
    <item>
      <title>C# 3.0</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-10-02-296/</link>
      <pubDate>Sun, 02 Oct 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-10-02-296/</guid>
      <description>Ian Griffiths 對於 C# 3.0 新功能的介紹：
C# 3.0 and LINQ - Expression Trees C# 3.0 - Extension Methods C# 3.0 - Var Isn&amp;rsquo;t Object</description>
    </item>
    
    <item>
      <title>Microsoft Campus</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-29-295/</link>
      <pubDate>Thu, 29 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-29-295/</guid>
      <description>這次的美國行，除了洛杉磯及舊金山，也意外地必須造訪 Microsoft 位於西雅圖的總部。其實大概三四年前就曾經跟朋友到西雅圖遊覽過一次，本來是有計畫要去 Microsoft 園區逛逛，不過似乎是除了我之外的其他人都認為這樣的行程實在太過無趣、太沒有文化層次，當時只好作罷。那時的我覺得大家的想法頗奇怪，難道他們都不會好奇嗎？或者其實真正奇怪的人是我。 :-)
不過這次總算有機會跟 David 一起去看看了，David 或許因為常常去的關係，並不覺得那裡有什麼特別的，我倒是頗為期待能瞧瞧 Microsoft 園區長什麼樣子。我想大家一定認為我這麼好奇應該會拍一堆照片回來吧，很不幸地，因為我的相機居然只拍了一張就沒電了！希望很快又會有機會一遊。
如果你跟我之前一樣好奇，可以瞧瞧Dylan Greene 的 Microsoft 遊記。</description>
    </item>
    
    <item>
      <title>.NET Performance Tuning</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-23-292/</link>
      <pubDate>Fri, 23 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-23-292/</guid>
      <description>我向來相信 managed code 可以讓 programmer 把事情做的更快更好，但這一切美好事物的背後是要付出其他代價的，因此這次去 PDC 特別挑了 Rico Mariani 主講的兩個 session 來聽：
 FUNL04 Tips &amp;amp; Tricks: Writing Performant Managed Code FUNL05 Tips &amp;amp; Tricks: Common Memory Management Pitfalls and Profiling for Managed Applications  如果你問 Rico &amp;ldquo;在開始 performance tuning 之前，最重要的三件準備工作是什麼？&amp;quot;，他的答案肯定是 &amp;ldquo;measure, measure, measure&amp;rdquo;。這幾乎是每個專家、每本書都會跟你強調的重點，但是很多 programmer 卻總是喜歡憑自己的直覺判斷來決定怎麼做，似乎他們就是刻意或者下意識地忘掉這件事，為什麼？因為 measure 實在是件麻煩事，有時甚至不可能做到。相反地，如果有一些工具程式的輔助，measure &amp;amp; performance tuning 可以是件頗有趣的事。除此之外，因為 managed code 有 metadata 可以輔助這些工具的分析，做起來其實比 native code 的 tuning 容易多了。
這兩場 session 都蠻短的，Rico 並沒有足夠的時間能夠用實際的例子 demo 怎麼使用這些工具並分析其結果，所以我就拿自己寫的一些程式來練習使用 vadump 及 SOS，我向來認為花點時間熟悉這些基本的工具使用可以在將來幫你省下更多的時間。</description>
    </item>
    
    <item>
      <title>在公牛身上擠奶</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-23-293/</link>
      <pubDate>Fri, 23 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-23-293/</guid>
      <description>咦？獨孤木出書了？《在公牛身上擠奶》？
最近好像有點跟不上新消息，還是因為看到 CNET 的這篇文章才知道這件事。不過聽說出版社編輯水準很差，請自行判斷是否值得購買。</description>
    </item>
    
    <item>
      <title>Mini Microsoft</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-18-291/</link>
      <pubDate>Sun, 18 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-18-291/</guid>
      <description>Mini-Microsoft 似乎引起很大的迴響。我還沒有時間去仔細讀讀看，只是大概瞄過去，原來 Microsoft 的員工有六萬人，而不是我記得的兩萬人，哇！</description>
    </item>
    
    <item>
      <title>PDC Sessions</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-17-290/</link>
      <pubDate>Sat, 17 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-17-290/</guid>
      <description>PDC 2005 順利落幕了，此行收穫頗豐，我想每個與會的人都是這樣認為的：雖然 Microsoft 多年的工作只要再一年就會可以收穫，但我們 (developers) 的工作才剛要開始呢。
如果你不能親自參加 PDC 2005 的話，可以到這裡下載課程內容。</description>
    </item>
    
    <item>
      <title>9/16 Anders Hejlsberg on C# 3.0</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-16-289/</link>
      <pubDate>Fri, 16 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-16-289/</guid>
      <description>呵呵，今天去聽 Anders Hejlsberg 講 C# 3.0，內容真的是很精采啊。Anders 本人有一種說不上來的獨特魅力，不會讓你因為覺得他非常聰明而不敢接近他，感覺是個很有親和力的人。在這個 session 他很有條理、循序漸進地告訴你為什麼這些 C# 的新功能需要被加進來：
 Lambda expressions Extension methods Local variable type inference Object initializers Anonymous types Query expressions Expression trees  本來我一直以為 C# 3.0 只是新增了 query language 的語法 (Microsoft 所謂的 Language Integrated Query, 簡稱 LINQ)，今天才知道 C# 為了實現 LINQ 也新增了許多令人興奮的新功能。這段 code 真是越看越酷：
var contacts = from c in customers where c.State == &amp;#34;WA&amp;#34; select new { c.Name, c.Phone }; 有興趣的可以參考 Overview of C# 3.</description>
    </item>
    
    <item>
      <title>9/13 Bill Gates Keynote</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-14-288/</link>
      <pubDate>Wed, 14 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-14-288/</guid>
      <description>今天的重頭戲當然就是 Bill Gates 跟 Jim Allchin 的 keynote，有興趣的可以看看現場轉播，其中 Don Box 跟 Anders Hejlsberg 的雙簧演出很精采喔。 接下來的一些 session 內容要等我這週末有空整理好再跟大家報告囉。</description>
    </item>
    
    <item>
      <title>9/12 The Sleepy Day</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-13-287/</link>
      <pubDate>Tue, 13 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-13-287/</guid>
      <description>&amp;ldquo;C++ Internals&amp;rdquo; Jim Hogg, Stan Lippman, Bob Davidson, Brandon Bray This is the talk that only the C++ Product Unit could give, and they&amp;rsquo;re here to give it. While understanding the internals of C++ is fascinating from a purely intellectual perspective, the Visual C++ team has found the set of internal knowledge that will also help you become the expert C++ developer. This talk will cover issues such as the C++ object model (managed and unmanaged), the complexity of app domains when the whole world is not managed, performance internals, and much much more.</description>
    </item>
    
    <item>
      <title>9/11 The First Day of PDC 2005 Pre-Conference</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-12-286/</link>
      <pubDate>Mon, 12 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-12-286/</guid>
      <description>這篇是我因為時差的關係，凌晨三點爬起來寫的東西：
第一天的巴士居然只有 6:45 - 7:15 的班次，不過這對還有時差的我是沒有任何問題。一大早坐巴士趕到會場完成報到手續後，我擺了烏龍掉了一些東西，幸虧有現場的 Microsoft 工作人員幫忙，事情雖然順利解決了，但是我的免費早餐也就來不及吃了。匆忙進入研討間時課程正好要開始，幾乎全部的座位都有人坐了，有些人覺得要穿越人群擠到中間去做太麻煩乾脆就坐在兩旁的走道上。雖然如此，我還是找到了一個座位，擠在兩個看起來有上百公斤的老外中間。
Jeffrey 首先自我介紹並談到了他是數本技術書籍的作者時：『我最新的 Applied .NET Framework Programming 有分成 C# 及 VB.NET 版本，但是 VB.NET 這一版總共只賣出了四本 (引起哄堂大笑)。』接下來他表示正在跟 Stanley Lippman 合作 C++/CLI 的版本，但這有可能是他最後的作品，因為要兼顧家庭及小孩的關係沒辦法花太多時間寫書 (我可以體會)。
接下來就進入主題 &amp;ldquo;What&amp;rsquo;s New in C# and the .NET Framework 2.0&amp;rdquo;，Jeffrey 的上課方式跟他寫書的風格一樣，非常善於用範例程式碼來輔助說明他要表達的東西，所以你可以看到他講了幾張投影片之後，就會切換到 Visual Studio 2005 來示範他剛講的東西，就算你之前不知道 C# 2.0 增加的新功能，應該也能很快地跟上他的節奏。C# 2.0 的這個部份沒有太多讓人驚訝的地方，因為新增的東西在之前就已經公開了並且有 beta 版可以測試，不過我自己很喜歡這些 2.0 新增的功能例如 Generics, Anonymous Method, Iterator, Nullable Types, Partial Types，因為他們補足了原來 C# 1.0 為人詬病的一些地方。當然這些新東西不只影響 C# 的編譯器，例如 Generics 及 Nullable Types 就需要底層的 CLR 做相對應的修改。這些改變的受惠者除了 C# programmer 外，FCL 也善用這些特性增加了不少的 Generics class 及 interface (這世界似乎越來越美好了)。</description>
    </item>
    
    <item>
      <title>9/10 The Day Before PDC 2005</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-09-11-285/</link>
      <pubDate>Sun, 11 Sep 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-09-11-285/</guid>
      <description>這第一天的流水帳頗無聊，純粹只是紀念用，沒興趣的不用繼續看下去了。:-)
雖然老婆不開心我又要出差了，兒子也哭著說要跟我ㄧ起去，颱風帶來的風雨也不小，我還是跳上計程車往機場出發了。老婆大人妳就別再生氣了，我很快就回來了&amp;hellip;
經過十三個小時的飛行，一走出 LA 機場，居然遇見了公司的同事，我不知道她請假回美國，她也不知道我要到洛杉磯，兩個人照面時都嚇了一大跳，這種不期而遇實在是太巧了。聊了一會了跟她說再見後，就照預定的計畫找台 shuttle 往旅館出發。
在等 shuttle 的時候，我東瞧西瞧，看到了幾個拿著 PDC 看板的人也在等車，應該是 PDC 現場的工作人員，也就沒有像剛才的那種偶遇了。坐上 shuttle 後，往 download 出發，裡面有個傢伙看起來很像是蓄長髮長鬍的 Don Box (應該是我想太多了)，坐在我旁邊白白胖胖有點靦腆的老外看起來就像是典型的 programmer，拿了印有 PDC 05 的 Yahoo Map 一直看。從聊天的內容聽來，整車的人包括我都是要去參加 PDC 的。到旅館的路上，剛好就有經過 LA Convetion Center，上面高高掛起了一個 PDC 05 的大看板，感覺跟 PDC 03 的一模一樣，從外面看起來好像不是很大的樣子，不過應該是我的錯覺，明天進去看就知道了。後來車上有四個人在 Wilshire Grand (看起來比我要去住的那家好)下車，只剩下我跟另外一個老外要往 The New Otani Hotel，他問我有沒有住過這家，因為他聽說還不錯，但我倒是沒有太高的期待，到了之後一看&amp;hellip;果然&amp;hellip;頗遜。
進旅館後發現這裡日本人特別多，櫃檯的服務小姐也是日本人，還有日式餐廳及日式庭園佈景，走在裡面三不五時就聽到有人講日文，我真的是在 LA 嗎? 進了房間拿了網路線一接後居然發現網路不通，實在是太爛了，打電話反應給櫃檯，他們居然要我直接跟合作的廠商聯繫，拜託這是他們的旅館耶&amp;hellip; 想想算了，明天到會場再處理郵件好了。因為沒網路實在是太無聊，加上在飛機上沒睡好的緣故，躺在床上迷迷糊糊就睡著了，一直到八點才醒來。肚子餓的我這時就出去搜尋食物了，沒想到旅館的後面賣的還是日本定食及拉麵&amp;hellip;
這就是第一天到 LA 的情況啦&amp;hellip;</description>
    </item>
    
    <item>
      <title>4 Weeks before PDC 05</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-08-16-281/</link>
      <pubDate>Tue, 16 Aug 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-08-16-281/</guid>
      <description>在 PDC 2005 Pre-Conference Sessions 中我選了 &amp;ldquo;What’s New in C# and the .NET Framework 2.0&amp;rdquo;，沒有什麼特別的理由，完全因為是 Jeffrey Richter 主講。另外一天的課程就有點令人難以抉擇，因為我想去參加有 Brandon Bray 及 Stan Lippman 的 &amp;ldquo;C++: Internals&amp;rdquo;，同時也想聽 Brad Abrams 的 &amp;ldquo;Framework Design Guidelines: The Art of Building a Reusable Class Library&amp;rdquo;，在傷腦筋的情況下就隨便選了 Framework Design Guidelines，希望不是單純地就講一堆 guideline，否則在有時差的情況下肯定會聽到打瞌睡。</description>
    </item>
    
    <item>
      <title>Reading Joel on Software</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-08-16-280/</link>
      <pubDate>Tue, 16 Aug 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-08-16-280/</guid>
      <description>持續地閱讀 Joel on Software 應該也有兩年以上的時間了。雖然幾乎所有的文章我都已經在電腦螢幕前翻閱過了，但是當 Joel 將他的文章集結出書時，我還是忍不住買了一本，畢竟我還是很享受把書拿在手上翻了一遍又一遍的感覺。
我將書裡面的內容歸納為『當你無可救藥地要創立自己的軟體公司前，你一定要知道的事』或是『除了你書架上那一拖拉庫關於程式設計的書外，你一定要讀的一本書』。然而我並不是要你去相信 Joel 講的每一件事，而是去學習他的思考方式，正如同書背上的這段介紹：
He eduated us, he entertained us, and, yes, sometimes he infuriated us, but he has always made us think about what it is we are doing when we sit down in front of that blank computer screen&amp;hellip;</description>
    </item>
    
    <item>
      <title>Jack Welch - Winning</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-07-18-268/</link>
      <pubDate>Mon, 18 Jul 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-07-18-268/</guid>
      <description>颱風來了，躲在家裡看書倒也不賴，而《致勝》這本書就是我這個禮拜的選擇！不過我想在接下來的這一年，這本書應該會長期佔據我的床頭，因為它實在是太棒了，讓我忍不住想一讀再讀。事實上，我的書櫃並不乏其它關於威爾許的書，但只有《致勝》是讓我覺得受益最多的，而且我還只讀了前幾章而已。
讀起這本書我的速度不快，原因是每讀一章就會引發我許多共鳴與想法，就會翻回去前面再讀一遍，跟著腦中這幾年的工作經驗比較及印證。威爾許真的是很有魅力的領導人，光是閱讀書中的文字就不禁讓人感受他的熱情，頓時熱血澎湃，忍不住想大喊『我們正應該這麼做』！</description>
    </item>
    
    <item>
      <title>PDC 2005</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-07-17-266/</link>
      <pubDate>Sun, 17 Jul 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-07-17-266/</guid>
      <description>今年終於有機會去參加 PDC 了！相信這場盛會又將掀起一波 blog 的熱潮。
這次去的必備裝置當然就是 Notebook 及數位相機。Notebook 可以用來隨時隨地 blog 最新的消息以及這次的所見所聞。數位相機當然就是用來捕捉當時的盛況以及拍照留念。
此行的最主要目的當然就是了解 Microsoft 最新的技術進展，額外的收穫就是可以親眼目睹我的偶像 Anders Hejlsberg 及 Microsoft 技術圈的一些名人如 Don Box, Jeffrey Richter, Raymond Chen, Brad Abrams, Stan Lippman, Mark Russinovich 等等。我想應該也有機會看到 Bill Gates 或 Jim Allchin，不過老實說，我會更期待看到 Steve Ballmer 再度上台又跳又唱地表演 developers, developers, developers&amp;hellip;，雖然那不大可能。 :-)
 </description>
    </item>
    
    <item>
      <title>The Best Software Writing I</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-21-256/</link>
      <pubDate>Tue, 21 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-21-256/</guid>
      <description>The Best Software Writing I: Selected and Introduced by Joel Spolsky 是 Joel 編輯的新書，書裡蒐集了許多很棒的文章，都是關於軟體開發的。這些文章很容易地都可以在作者的個人網站裡找到 (感謝這些樂於分享知識的 bloggers)：
 Ken Arnold - Style Is Substance Leon Bambrick - Award for the Silliest User Interface: Windows Search Michael Bean - The Pitfalls of Outsourcing Programmers Rory Blyth - Excel as a Database Adam Bosworth - ICSOC04 Talk danah boyd - Autistic Social Software Raymond Chen - Why Not Just Block the Apps That Rely on Undocumented Behavior?</description>
    </item>
    
    <item>
      <title>Counting Semaphore in .NET</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-19-254/</link>
      <pubDate>Sun, 19 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-19-254/</guid>
      <description>另一篇在 CSDN 也是有問題的程式，程式的目的是限制一定數量的 threads 同時執行某項工作。我的想法是用 System.Threading.Monitor 就可以很優雅地解決這問題：
class Program { static void Main(string[] args) { Program p = new Program(); Thread[] threads = new Thread[10]; for (int i = 0; i &amp;amp;lt; threads.Length; i++) { threads[i] = new Thread(p.Run); threads[i].Name = &amp;#34;Thread(&amp;#34; + i.ToString() + &amp;#34;)&amp;#34;; threads[i].Start(); Thread.Sleep(1000); } foreach (Thread t in threads) { t.Join(); } Console.ReadLine(); } private int allowed = 3; public void Run() { Thread t = Thread.</description>
    </item>
    
    <item>
      <title>Implement Singleton Pattern by Generic (in C#  2.0)</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-19-253/</link>
      <pubDate>Sun, 19 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-19-253/</guid>
      <description>在 CSDN 看到的這個範例有兩個問題：
 不是 thread-safe 假如 T 沒有公開無參數的建構函數，會在 runtime 時拋出異常。事實上，這個問題可以使用 generic constraint 在 compiler time 時避免。  所以下面是改良過的版本：
public class Singleton where T : new() { private static T _instance = new T(); // to disable beforefieldinit flag  static Singleton() {} public static T Instance { get { return _instance; } } } </description>
    </item>
    
    <item>
      <title>Cdecl Calling Convention for Delegates</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-15-248/</link>
      <pubDate>Wed, 15 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-15-248/</guid>
      <description>如何使用 C# 建立 cdecl callback 給 unmanaged code 使用？
SQLite.NET 所採用的方法如下：
 用 ildasm 反組譯 DLL 產生 IL 碼 用 Perl script 為 delegate 的 Invoke() 加上 modopt([mscorlib]System.Runtime.CompilerServices.CallConvCdecl) 再用 ilasm 組譯出新的 DLL  參考下列詳細的方法 (摘自 SQLite.NET 的文件檔)：
 The C# does not allow you to specify the calling convention of the callback. It is just one of the C# limitations. IL, managed C++ and the runtime itself supports the cdecl calling convention for delegates through modopt([mscorlib]System.</description>
    </item>
    
    <item>
      <title>Cdecl Calling Convention for Delegates, Part II</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-15-249/</link>
      <pubDate>Wed, 15 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-15-249/</guid>
      <description>想了一下，前一篇文章裡的方法似乎有點麻煩。雖然 C# 的實作有這樣的限制，但是我們應該可以用 System.Reflection.Emit.TypeBuilder 來動態產生一個使用 cdecl 的 delegate。理論上，透過 dynamic code generation 這種方式是可以突破任何語法上或是實作上的限制。因此參考下列的這兩篇文章，其實這問題是可以用更優雅的方式來解決：
 Creating delegate types via Reflection.Emit, Joel Pobar Calling Code Dynamically, Eric Gunnerson  下列的程式列出了新的作法，產生出來的 delegate 跟用 ildasm/perl/ilasm 是一樣的效果 (注意 new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) } 的使用)，酷！
using System; using System.Collections.Generic; using System.Text; using System.Reflection; using System.Reflection.Emit; namespace EmitCdeclDelegate { class Program { static void Main(string[] args) { Program program = new Program(); program.TestCdeclDelegate(); } private void TestCdeclDelegate() { MethodInfo methodInfo = typeof(Program).</description>
    </item>
    
    <item>
      <title>Erich Gamma on Design Patterns</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-11-245/</link>
      <pubDate>Sat, 11 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-11-245/</guid>
      <description>談到 Design Patterns，有興趣的人可以看看這一系列對 Erich Gamma 的訪談：
 Part I: How to Use Design Patterns Part II: Erich Gamma on Flexibility and Reuse Part III: Design Principles from Design Patterns  Erich Gamma 談到如何使用 DP 以及經過這十年他想法的一些改變。DP 固然是 programmer 設計程式時的一大利器，然而水可載舟亦可覆舟，誤用 DP 往往會造成過度的設計以及沒有必要的彈性。例如下面這個我很久以前看過的一個實際例子：
class Toy {}; class Barbie : public Toy {}; class Lego : public Toy {}; class ToyFactory { public: static ToyFactory* Instance(); virtual Toy* CreateToy(LPCTSTR id); protected: ToyFactory(); virtual ~ToyFactory(); private: static ToyFactory* m_pToyFactory; }; ToyFactory * ToyFactory::m_pToyFactory = NULL; ToyFactory::ToyFactory() {} ToyFactory::~ToyFactory() {} ToyFactory * ToyFactory::Instance() { if (!</description>
    </item>
    
    <item>
      <title>Head First Design Patterns</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-06-09-241/</link>
      <pubDate>Thu, 09 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-06-09-241/</guid>
      <description>蔡學鏞要翻譯《Head First Design Patterns》這本近來熱賣到不行的書。
翻譯這本書跟翻譯一般的技術書籍有點不一樣，相對地也比較難，就看蔡學鏞能否一戰成名或是砸了自己的招牌囉。目前網站上沒提供試讀的章節，所以不曉得翻譯的品質如何。但如果翻譯的品質不錯，我肯定會掏腰包去買。</description>
    </item>
    
    <item>
      <title>Start a Startup</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-05-25-237/</link>
      <pubDate>Wed, 25 May 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-05-25-237/</guid>
      <description>Joel Spolsky, Eric Sink, 及 Paul Graham 這三個人有什麼共同點？
 他們都是技術圈裡有名的 blogger 及 programmer。 比起一般人，他們顯然聰明許多。 他們都創立了自己的軟體公司。  事實上，我對他們的尊敬多半來自於第三點，原因是他們成功地做到了，而我卻連第一步都還不敢踏出。對我來說，創業最大的誘因是我可以用我認為對的方式及態度來做事，其次才是它有可能帶來的財富，當然最慘的下場可能是落的一文不值。另一方面，即將滿三十歲的我也怕這樣的熱情與精力會隨著年紀的增長而日漸消卻。
如果你也是對創業有興趣的軟體人，可以好好地讀讀這兩篇對我影響頗深的文章：
 Guy Kawasaki 的《the Art of the Start》 Paul Graham 的《How to Start a Startup》  你絕對不能放棄，我對自己這麼說。</description>
    </item>
    
    <item>
      <title>Windows Internals Guru - Mark Russinovich</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-04-12-236/</link>
      <pubDate>Tue, 12 Apr 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-04-12-236/</guid>
      <description>Mark Russinovich 也開始 blog 了。對 Windows 內部運作有興趣的人可以持續關注他的文章。</description>
    </item>
    
    <item>
      <title>The First Recorded Computer Bug</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-04-11-235/</link>
      <pubDate>Mon, 11 Apr 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-04-11-235/</guid>
      <description>The First Recorded Computer Bug</description>
    </item>
    
    <item>
      <title>developer-centric or not</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-04-10-234/</link>
      <pubDate>Sun, 10 Apr 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-04-10-234/</guid>
      <description>Eric Sink 在《Geeks Rule and MBAs Drool》中提出的這些論點真的是說進我的心坎裡：
Virtually all decisions in a small ISV should be made with the involvement of technology person.
The skills of a developer are applicable to many other tasks besides coding.
Companies should not be afraid to let developers get involved in activities other than software construction.
Developers should work very hard to remember that the world does not revolve around them.  Joel 之前在《Rick Chapman is In Search of Stupidity》也曾提出相同的看法。我認為這種 developer-centric 的文化是判斷一家軟體公司是否會成功的關鍵，至少全世界最大的軟體公司 Microsoft 就是個實例。然而真正困難的地方是：隨著公司組織的成長與擴張，保持這種精神不被稀釋。如果在你的軟體公司裡，programmers 的角色往往是沉默聽令的一群，或者意見總是無法上達天聽，如同 Joel 的建議，趕快準備履歷換公司吧。</description>
    </item>
    
    <item>
      <title>Learning Economics</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-04-08-233/</link>
      <pubDate>Fri, 08 Apr 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-04-08-233/</guid>
      <description>Joel Spolsky 的《Advice for Computer Science College Students》值得正在念資訊科系的學生參考。
不過 Joel 的建議對我來說有點晚了，否則當年我的經濟學就不會被當了，哈！以前唸的經濟學教科書是台大四人幫寫的那本，只記得書裡有一堆奇怪的供給需求交叉線，那時的我實在是提不起興趣來念。雖然如此，前陣子我還是找了兩本讀起來比較輕鬆的經濟學入門書來看：《經濟學的第一堂課》及《聰明學經濟的12堂課》。
你或許會問，學經濟學真的有用嗎？心存懷疑的你可以先讀讀 Joel 的這篇文章《Strategy Letter V》，然後再想想：為什麼 Apple 要在 Windows 上提供免費的 iTune？ 或是 Google 正嘗試著 commoditize 什麼東西？</description>
    </item>
    
    <item>
      <title>BitKeeper &amp; Linux</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-04-07-232/</link>
      <pubDate>Thu, 07 Apr 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-04-07-232/</guid>
      <description>Linux Kernel Development 要和 BitKeeper 脫鉤了。詳情可以看 fa.linux.kernel 的討論，不過 subversion 的粉絲難免要失望了。
老實說我一點也不喜歡 BitKeeper，它在 Windows 上的 UI 實在是很憋腳。</description>
    </item>
    
    <item>
      <title>SCM Branch</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-04-05-231/</link>
      <pubDate>Tue, 05 Apr 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-04-05-231/</guid>
      <description>如果你有用過一些 source control tool，卻從沒用過 branch 的機制，可以讀讀 Eric Sink 的這篇文章：Source Control HOWTO Chapter 7: Branches。
就我的觀點，可以從三個方面來評量 source control tool 的好壞：穩定性、速度、branch 機制。老實說，前兩個條件是最基本的要求，如果你認為某個版本控制系統不穩定或是速度太慢，別用它！因為它帶來的麻煩會比好處還要多，況且你應該有其他更好的選擇。如果穩定性及速度都能符合要求，要比較的就是 branch 機制是否好用。
事實上，談到 branch 不可能不談到 merge，而且那才是麻煩的地方。諷刺的是，所有的版本控制系統都誇稱產生一個新的 branch 有多容易，branch 可以帶來多少多少的好處，卻絕口不提在 branch 間 merge code 有多麼地麻煩。正如同 Eric 的比喻，一個新的 branch 就如同一個小孩，如果有人跟你說生個小孩有多快多方便，卻沒告訴你照顧一個小孩有多麻煩，你會相信他的話去生個小孩嗎？
目前我知道的版本控制系統只有 AccuRev 針對另人頭痛的 merge 問題提出獨有的 stream-based architecture。我最喜歡的 Perforce 不知道是否會在這方面做改進，而對於 subversion 就只能期待有一些 open-source project 來實作這方面的功能。</description>
    </item>
    
    <item>
      <title>The Ten Rules of Performance</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-03-31-229/</link>
      <pubDate>Thu, 31 Mar 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-03-31-229/</guid>
      <description>Eric Gunnerson 的 Design for Performance vs. Tune for performance 讓我想起之前讀過 Paul Vick 的這篇文章 The Ten Rules of Performance。
我自己歸納了幾個了幾個重點:
 Don&amp;rsquo;t guess, do profiling. Fix performance problem as early as possible. Performance should be designed in. Memory access is more expensive than CPU cycle. Develop a &amp;ldquo;performance culture&amp;rdquo; in the team/company.  </description>
    </item>
    
    <item>
      <title>Jolt Awards 2005</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-03-21-227/</link>
      <pubDate>Mon, 21 Mar 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-03-21-227/</guid>
      <description>Subversion 拿下 Change and Configuration Management Tools 的首獎。毫無意外地，Eclipse 仍然蟬連 Languages and Development Environments 的寶座。
新增的 Test – Defect Tracking Tools 獎項則是由 FogBugz 3.1 獲得，Joel Spolsky 應該感到驕傲，因為他的書《Joel on Software》及產品 FogBugz 同時都得獎了。</description>
    </item>
    
    <item>
      <title>How to be a good programmer?</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-03-14-226/</link>
      <pubDate>Mon, 14 Mar 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-03-14-226/</guid>
      <description>I want to be a good programmer&amp;hellip; How???
我多加一條:
 Read a lot of code: for example, you can choose an open-source project you are interested in and try to understand how it works by reading its source code. You can always learn new things from that because every programmer thinks differently for the same thing and their solution may be better than yours.  </description>
    </item>
    
    <item>
      <title>Exception Handling Best Practices in .NET</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-03-12-225/</link>
      <pubDate>Sat, 12 Mar 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-03-12-225/</guid>
      <description>Daniel Turini 寫的這篇《Exception Handling Best Practices in .NET》相當不錯，內容正好跟 Brad Abrams 的《Exception handing and Memory Management》相呼應。
我不明白的是，為什麼 Brad Abrams 會認為 &amp;ldquo;catch (Exception e) is your friend&amp;rdquo;？ 因為 catch {&amp;hellip;} 中我所能想到最好的處理方式就是 &amp;ldquo;log the Exception, rethrow it, and let the program terminate&amp;rdquo;；如果不這樣做而把這個 Exception 忽略掉，反而會造成以後偵錯的困難。
有興趣的人可以參考 Is &amp;ldquo;throw new Exception(&amp;hellip;)&amp;rdquo; a good practice 這個討論，我喜歡 David Levine 給我的答案。</description>
    </item>
    
    <item>
      <title>Bug Reporting Best Practices</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-03-10-224/</link>
      <pubDate>Thu, 10 Mar 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-03-10-224/</guid>
      <description>軟體測試的工作往往是軟體開發流程中較容易被輕忽的一環，而軟體測試的唯一產出就是 bug report，好的 bug report 可能讓你在幾分鐘內就把問題解決。有興趣的可以參考以下這幾篇關於如何做好 bug report 的文章：
 Bug Reporting Best Practices [PDF] The Fine Art of Writing a Good Bug Report Hallmarks of a Great Tester  </description>
    </item>
    
    <item>
      <title>Knuth &amp; TAOCP</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-02-15-220/</link>
      <pubDate>Tue, 15 Feb 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-02-15-220/</guid>
      <description>唸過 computer science 的人大多對 Knuth 有份莫名的崇敬，而大多數人的崇敬源自於 The Art of Computer Programming 這部不知何時才能全部完成的巨著，而大家最常開的笑話就是『 Knuth 能在有生之年把七大冊全部寫完嗎？』。但對我而言，Knuth 這名字卻有著更不同的意義：他是我的師祖，也就是老師的老師的老師。
我自己幾年前買下 vol.1-3 這一套供在書架上，卻從來沒能夠把這幾本書看完，畢竟自己的數學基礎不夠扎實，出來工作後也沒有時間及熱情來研讀了。有時候覺得愧對師祖時就會拿出來翻一翻再放回架上去。 XD
師祖預計於 2007 年完成 vol.4，在這之前，將先出版一系列的 fascicle 為它鋪路：
 Volume 1, Fascicle 1: MMIX &amp;ndash; A RISC Computer for the New Millennium Volume 4, Fascicle 2: Generating All Tuples and Permutations Volume 4, Fascicle 3: Generating All Combinations and Partitions  不熟悉 Knuth 的人可以看看這篇簡介《高德納的二十年計畫》。</description>
    </item>
    
    <item>
      <title>Stallman, Torvalds, Knuth, and Dijkstra</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-02-14-219/</link>
      <pubDate>Mon, 14 Feb 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-02-14-219/</guid>
      <description>取自 Knuth&amp;rsquo;s Art of Computer Programming Vol. 4 這篇在 Slashdot 的消息：
 Richard M. Stallman, Linus Torvalds, and Donald E. Knuth engage in a discussion on whose impact on Computer Science was the greatest.
Stallman: &amp;ldquo;God told me I have programmed the best editor in the world!&amp;quot;
Torvalds: &amp;ldquo;Well, God told me that I have programmed the best operating system in the world!&amp;quot;
Knuth: &amp;ldquo;Wait, wait - I never said that.</description>
    </item>
    
    <item>
      <title>Acronym: IIRC</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-02-01-218/</link>
      <pubDate>Tue, 01 Feb 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-02-01-218/</guid>
      <description>這是我今天第二次看到 IIRC 這縮寫了，就搜尋了一下，只是 YHGMTPOTG 或 BTDTGTTSAWIO 有點惡搞吧？</description>
    </item>
    
    <item>
      <title>What is LLP64?</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-02-01-217/</link>
      <pubDate>Tue, 01 Feb 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-02-01-217/</guid>
      <description>談到 64-bit programming，難免就會看到這幾個縮寫：LP64 ILP64 LLP64 ILP32 LP32，關於這些模式的差異可以參考《64-Bit Programming Models: Why LP64?》。
附帶一提：Win64 採用 LLP64</description>
    </item>
    
    <item>
      <title>Async is hard</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-01-27-216/</link>
      <pubDate>Thu, 27 Jan 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-01-27-216/</guid>
      <description>今天跟同事討論一個問題： &#34;Is asynchronous interface good?&#34;
我的觀點是『server interface 應該採用 synchronous model，而由 client 來決定是否採用 asynchronous model 』。會有這樣的結論是因為我認為 &#34;async is hard&#34;。asynchronous model 強迫 client 去做許多不同於 synchronous model 的特別處理才能確保程式的正確性；但是根據我的觀察，大多數 programmer 的思考邏輯都習慣了 synchronous model，要他們突然換成 asynchronous model 來思考非得花一番時間嘗試及偵錯才能達到 100% 的正確性。換句話說，我認為一個容易讓 client 端出錯的 interface 並不是好的 interface。
我向來是 &#34;Make simple things easy and hard things possible&#34; 這句話的信徒。</description>
    </item>
    
    <item>
      <title>NDepend &amp; NAnt</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-01-20-215/</link>
      <pubDate>Thu, 20 Jan 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-01-20-215/</guid>
      <description>因為讀 Patrick Smacchia 的這篇文章 Introduction to C# Anonymous Methods 而發現 NDepend (Mike Clark 之前就已經為 Java 實作了 JDepend) :
 NDepend analyses .NET assemblies of an application and generates design quality metrics. NDepend allows you to automatically measure the quality of a design in terms of its extensibility, reusability and maintainability to effectively manage and control the assemblies’ dependencies of your .NET applications. Moreover, NDepend helps you to get a thorough view of the topology of your application, at component at type and at member level.</description>
    </item>
    
    <item>
      <title>Writing Exception-Safe Code</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-01-17-214/</link>
      <pubDate>Mon, 17 Jan 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-01-17-214/</guid>
      <description>The Old New Thing 中關於 exception-safe 的相關討論：
 Cleaner, more elegant, and wrong How did MS-DOS report error codes? Cleaner, more elegant, and harder to recognize  如同我以前在 Assertions and Error Handling 這篇文章中的觀點，我還是認為 exception 帶來的好處多於它帶來的問題。大家都知道 &amp;ldquo;writing error handling code is hard&amp;rdquo;，不表示我們就可以忽略這個議題而不做 error handling；正如同 &amp;ldquo;writing bug-free code is hard&amp;rdquo; 不是你程式裡有一堆臭蟲的好理由。
關於 exception-safe 或是 failure atomicity 這個問題，常見的五個解決方法可以參考 Effective Java 中的 Item 46: Strive for failure atomicity：
 design immutable objects check parameters for validity before performing the operation order the computation so that any part that may fail takes place before any part that modifies the object write recovery code perform the operation on a temporary copy  </description>
    </item>
    
    <item>
      <title>Installing CruiseControl.NET</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-01-12-213/</link>
      <pubDate>Wed, 12 Jan 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-01-12-213/</guid>
      <description>突然發現有人已經寫了一篇非常詳細的 CruiseControl.NET 的安裝指南，我想我也不可能寫的比他還詳細。有興趣的人可以先看這一篇，再跟我的設定對照參考。
我的機器上安裝了下列相關軟體：
 .NET Framework v1.1 Visual Studio .NET 2003 Perforce 2004.2 CruiseControl.NET 0.7 NAnt 0.85 NAntContrib 0.85 NUnit 2.2 NDoc 1.3 FxCop 1.312  CruiseControl.NET 設定的重點就是 server\ccnet.config：
&amp;lt;cruisecontrol&amp;gt; &amp;lt;project name=&amp;quot;PViewer&amp;quot;&amp;gt; &amp;lt;webURL&amp;gt;http://baby.homeip.net/ccnet/&amp;lt;/webURL&amp;gt; &amp;lt;workingDirectory&amp;gt;d:/temp/ccnet/&amp;lt;/workingDirectory&amp;gt; &amp;lt;triggers&amp;gt; &amp;lt;pollingInterval seconds=&amp;quot;60&amp;quot; /&amp;gt; &amp;lt;forceBuildSchedule time=&amp;quot;05:00&amp;quot; /&amp;gt; &amp;lt;/triggers&amp;gt; &amp;lt;labeller type=&amp;quot;defaultlabeller&amp;quot;&amp;gt; &amp;lt;prefix&amp;gt;ccnet-pviewer-&amp;lt;/prefix&amp;gt; &amp;lt;/labeller&amp;gt; &amp;lt;modificationDelaySeconds&amp;gt;10&amp;lt;/modificationDelaySeconds&amp;gt; &amp;lt;sourcecontrol type=&amp;quot;p4&amp;quot;&amp;gt; &amp;lt;view&amp;gt;//depot/src/main/...&amp;lt;/view&amp;gt; &amp;lt;executable&amp;gt;C:\Program Files\Perforce\p4.exe&amp;lt;/executable&amp;gt; &amp;lt;client&amp;gt;CCNET&amp;lt;/client&amp;gt; &amp;lt;user&amp;gt;Patrick&amp;lt;/user&amp;gt; &amp;lt;port&amp;gt;10.10.1.6:1666&amp;lt;/port&amp;gt; &amp;lt;autoGetSource&amp;gt;true&amp;lt;/autoGetSource&amp;gt; &amp;lt;/sourcecontrol&amp;gt; &amp;lt;build type=&amp;quot;nant&amp;quot;&amp;gt; &amp;lt;executable&amp;gt;NAnt.exe&amp;lt;/executable&amp;gt; &amp;lt;buildFile&amp;gt;src\main\PViewer\PViewer.build&amp;lt;/buildFile&amp;gt; &amp;lt;targetList&amp;gt; &amp;lt;target&amp;gt;all&amp;lt;/target&amp;gt; &amp;lt;/targetList&amp;gt; &amp;lt;/build&amp;gt; &amp;lt;publishers&amp;gt; &amp;lt;xmllogger /&amp;gt; &amp;lt;/publishers&amp;gt; &amp;lt;tasks&amp;gt; &amp;lt;merge&amp;gt; &amp;lt;files&amp;gt; &amp;lt;file&amp;gt;src\main\PViewer\Test\bin\release\*.</description>
    </item>
    
    <item>
      <title>Continuous Integration on .NET platform</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-01-09-212/</link>
      <pubDate>Sun, 09 Jan 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-01-09-212/</guid>
      <description>最近把這兩本書看完：
Pragmatic Unit Testing in C# with Nunit (Pragmatic Programmers) by Andy Hunt, Dave Thomas
Pragmatic Project Automation: How to Build, Deploy, and Monitor Java Apps by Mike Clark
因為自己空閒時會用 C# 寫一些小程式，也就花了點時間把書中建議的開發環境架設起來，這兩天有空再把詳細的步驟分享給大家。
Continuous Integration 是 XP 的重要程序之一，藉由持續的整合測試可以將錯誤更正的反應時間降至最低，更進一步地提昇團隊的效率。然而如同 Martin Fowler 文章中的建議，實行 Continuous Integration 的關鍵是自動化，沒有自動化工具的輔助，實行這項程序其實是相當困難的。Ant, CruiseControl, 及 JUnit 是 Java 平台上建立 Continuous Integration 環境的利器；很幸運地在 .NET 環境下也有相對應的 NAnt, CruiseControl.NET 及 NUnit 可以使用。
除了上面提到的那兩本書，TheServerSide.NET 的這兩篇文章也可以參考：Managing .NET Development with NAnt and Continuous Integration with CruiseControl.NET and Draco.</description>
    </item>
    
    <item>
      <title>CodeProject</title>
      <link>https://blog.simplypatrick.com/posts/2005/2005-01-06-211/</link>
      <pubDate>Thu, 06 Jan 2005 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2005/2005-01-06-211/</guid>
      <description>我有訂閱 CodeProject 的 newsletter，原因是在裡面總是可以發現一些新奇有趣的程式小品如 ASCII art with C#。</description>
    </item>
    
    <item>
      <title>New Books about Agile Development</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-12-10-208/</link>
      <pubDate>Fri, 10 Dec 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-12-10-208/</guid>
      <description>似乎是兩本很有趣的書:
Agile and Iterative Development: A Manager&amp;rsquo;s Guide by Craig Larman
Balancing Agility and Discipline: A Guide for the Perplexed by Barry Boehm, Richard Turner
Agile Methodology 近年來已經成為軟體開發的顯學，每個人都在討論，確實對傳統軟體開發的觀念有許多衝擊。但是改變個人的觀念容易，改變一個團隊的觀念難，改變整個公司的觀 念更難，如何導入 Agile Methodology 將考驗決策者的智慧。問題是這種開發流程的改造能夠由下而上地進行嗎？或者是需要高層主管的支持才行？思考中&amp;hellip;</description>
    </item>
    
    <item>
      <title>John Lam on CLI Metadata</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-12-08-207/</link>
      <pubDate>Wed, 08 Dec 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-12-08-207/</guid>
      <description>John Lam 的 Metadata Internals 實在是太棒了，單單看這份簡報就可以對 CLI metadata 的結構有了清楚的認識，可以看出來 John 是個很會教導的老師。
我想大部分的 .NET programmer 也只要了解到這個程度就夠了，如果想要更深入才需要去看 CLI Partition II - Metadata and File Format 這份長達174頁的正式規格。
John 的 iunknown.com blog 也很值得去看喔。</description>
    </item>
    
    <item>
      <title>Stan Lippman on C&#43;&#43;/CLI</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-12-06-205/</link>
      <pubDate>Mon, 06 Dec 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-12-06-205/</guid>
      <description>我一直很好奇為什麼在 C++ 領域赫赫有名的 Stan Lippman 及 Herb Sutter 會加入 Microsoft?
從孟岩對 Stan 的訪談或許可以一窺其究竟。從文中可以看出，透過 C++/CLI 一方面可以實現 Stan 個人對 C++ 改進的期許，一方面也大大增強了 C++ 在 .NET 平台上的實用性。或許有許多人認為 Stan 這樣的作法是叛離 C++ 的正統道路，我倒是很樂觀其成。如果今天 Microsoft 不做 C++ 與 .NET 的 Interop，一定會有其他的公司或開放原始碼的專案會去做，畢竟有需求就會有人想辦法供給。
看看訪談文章的評論，發現有些人總是喜歡把別人當成笨蛋或是認為別人做任何事都是出於自私的目的，胸襟及眼光實在是小了些。人們所以為的往往是自己想法的反射。</description>
    </item>
    
    <item>
      <title>Windows Forms Programming Tips</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-12-03-204/</link>
      <pubDate>Fri, 03 Dec 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-12-03-204/</guid>
      <description>在 jfo&amp;rsquo;s coding 有一些 Windows Forms 的技術文章，內容頗為實用而且都是一般市面的 Windows Forms 書籍沒討論到的課題：
 Picking your base class wisely All About Handles in Windows Forms How When Where and Why to use Dispose Painting Best Practices Understanding DockLayout and Splitters Building NotifyIcon Applications/Understanding the Application class How to make a readonly controls collection  </description>
    </item>
    
    <item>
      <title>Don&#39;t throw System.Exception directly!</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-27-203/</link>
      <pubDate>Sat, 27 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-27-203/</guid>
      <description>在寫下列這一段程式時，發現 System.Drawing.Graphics.FromImage 居然會直接拋出 System.Exception：
public class AddImageInfo : BaseImageOp { private Font _drawFont = new Font( &amp;#34;Verdana&amp;#34;, 10); private SolidBrush _drawBrush = new SolidBrush(Color.White); public AddImageInfo(ImageOp innerOp) : base(innerOp) { } public override Image Execute(Image image) { using (Graphics g = Graphics.FromImage(_innerOp.Execute(image))) { string info = String.Format( &amp;#34;{0}x{1}&amp;#34;, image.Width, image.Height); g.DrawString( info, _drawFont, _drawBrush, 10, 10); } return image; } } 用 Reflector 查了 System.Drawing.Graphics.FromImage() 的實作：
public static Graphics FromImage(Image image) { if (image == null) { throw new ArgumentNullException(&amp;#34;image&amp;#34;); } if ((image.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Coding Standards</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-23-202/</link>
      <pubDate>Tue, 23 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-23-202/</guid>
      <description>預覽 Herb Sutter 及 Andrei Alexandrescu 的新書《C++ Coding Standards》。
還沒有機會去書店買，但從 Amazon.com 裡的評論看來，這本書與 Effective C++ 似乎頗有互補作用。
Don’t sweat the small stuff. (Or: Know what not to standardize.) 2 Compile cleanly at high warning levels. 4 Use an automated build system. 7 Use a version control system. 8 Invest in code reviews. 9 Give one entity one cohesive responsibility. 12 Correctness, simplicity, and clarity come first. 13 Know when and how to code for scalability.</description>
    </item>
    
    <item>
      <title>Zero Bug Bounce</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-18-201/</link>
      <pubDate>Thu, 18 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-18-201/</guid>
      <description>期望有一天自己的產品也能達到 ZBB 的程度。</description>
    </item>
    
    <item>
      <title>beforefieldinit</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-16-200/</link>
      <pubDate>Tue, 16 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-16-200/</guid>
      <description>兩篇文章讓你可以把 static initializer, static constructor, 及 beforefieldinit 的觀念搞清楚：
 Implementing the Singleton Pattern in C# C# and beforefieldinit  兩篇文章都是出自於 Jon Skeet 的網站，裡面還有一些很不錯的 .NET 技術文章。</description>
    </item>
    
    <item>
      <title>IanG on .NET Multi-thread Programming</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-14-199/</link>
      <pubDate>Sun, 14 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-14-199/</guid>
      <description>Ian Griffiths 寫了不少關於 .NET multi-thread programming 的文章：
《What Locks Are You Holding Right Now?》 解釋了 deadlock 發生的時機，以及兩個常用的規則來避免之：
 avoid blocking the UI thread. avoid making other threads wait for the UI thread to do something.  《Monitor.TryEnter, lock, using, and Deadlock》解釋如何用 using 語法來實作限時的等待。類似的手法也可以應用在 ReaderWriterLock。(參考 Stupid &amp;ldquo;using&amp;rdquo; Tricks)
《ReaderWriterLock vs Monitor》解釋了為什麼使用 ReaderWriterLock 通常是一種過早的最佳化 (premature optimization)。
《Locking, Anonymous Delegates, and Interrupts》說明了一般同步機制所使用的 &amp;ldquo;acquire, do, release&amp;rdquo; 模式的缺點，也順帶點出 KeSynchronizeExecution 存在的原因。
《When Synchronous Locking Goes Bad》是前一篇的延續，點出另一個 &amp;ldquo;acquire, do, release&amp;rdquo; 不適用的時機，以及 ISynchronizeInvoke 模式如何弭補這缺陷。簡而言之，ISynchronizeInvoke 是個比 &amp;ldquo;acquire, do, release&amp;rdquo; 更抽象、適用範圍更廣的同步模式。</description>
    </item>
    
    <item>
      <title>Knowing x86 machine code</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-13-198/</link>
      <pubDate>Sat, 13 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-13-198/</guid>
      <description>有 crack 過一些軟體的人應該都知道這樣的技巧吧：Advantages of knowing your x86 machine code。Comment 中提到的 Ctrl-F11 切換 source code 與 disassembly code 的技巧還蠻方便的。</description>
    </item>
    
    <item>
      <title>MIT OCW 中文化</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-11-196/</link>
      <pubDate>Thu, 11 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-11-196/</guid>
      <description>之前有提過 MIT OpenCourseWare，沒想到有人正在進行課程內容的中文化：
http://www.mitocw.net
 轉寄一個充實知識的好站, 不用到麻省理工學院就能上麻省理工學院之課程,且全部都是中文喔! 希望各位能善加利用.......也感謝台灣還有這樣這些熱心的人....... 統合知識的力量勝於單一天才提到朱學恒，多數人會聯想到《魔戒》，因為他是魔戒小說中文版的譯者，而魔戒在台灣造成的瘋狂程度，朱學恒扮演了重要的推手。不過，現在他的最新職稱是麻省理工學院開放式課程中文翻譯計畫主持人，他找了幾位志同道合的朋友，將麻省理工學院（MIT）在網路上的７百多門公開課程，陸續翻譯為中文並架設網站，這個將美國名校課程中譯化的線上學習計畫，竟是在他不到幾坪的窄室內動員網路上看不到的近百位義工進行。目前，這套課程的中文化已完成約460門，每天約有2千多位上網者瀏覽，在不花任何學費的狀況下享受到常春藤名校的師資與課程。問：當初為何會參與此計畫？答：我很喜歡看《WIRED》雜誌，去年9月號有一篇文章談到，麻省理工學院花了 3年多的時間將校內700多門課程全部公開上線，有的做成影音課程，有的是老師的研究報告，甚至連多年的考古題都放到網路上。我很好奇就上網去看，竟然看到我大學時代的「線性代數」教科書作者Gilbert Strang在網路上親自授課，這真是讓我大為震 憾，有整整６個月的時間，我幾乎天天上網去看各種課程，我一直在想，這麼棒的線上教學一&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 定會有國內的學術單位把它中文化，可惜時間一點一點的過去，都沒有人有動靜於是，我決定自己搞吧，找了幾個懂電腦的朋友開始架設網站，把這套課程一點一點 的貼上網，然候我開始將第一層資料，例如課程大綱等翻譯成中文。 問：如何取得麻省理工學院的同意？答：根本不需要他們同意，因為他們將這些課程公開在網路上時，就注明歡迎大家取用，但設定３個原則：不准用這些資料來謀利、引用資料之後不准佔為己有，最後是要註明出處，只要不違背以上３原則，任何國家都可以翻譯成自己的文字。據我了解，目前這套課程已有西班牙文、葡萄牙文、繁體與簡體中文。問：這麼龐大又專業的翻譯計畫，你如何在沒有人力與物力下進行？答：MIT的課程非常專業，我在前６個月天天上網時就在想，如果我要將這些內容中文化，&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 要去哪裡才能找到夠專業的翻譯人才？我可以到中科院或中研院去找專業的教授，可是因為這個計畫不能營利，所以我不可能有錢付翻譯費或校稿費，於是我把腦筋動到網路上。&amp;nbsp;&amp;nbsp;&amp;nbsp; 我先將英文版的課程公開，然後在網路上請求「認養」，我用認養而不是用翻 譯，&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 就是因為這是個沒有報酬的工作，沒想到竟然有好多專業人士上門，有學者、有基金經理人甚至有專業魔術師&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; （因為其中有門課是劇劇管理），幾個月下來，700多門課已有460門課有人開始翻譯。 問：這些內容都是深奧的專業，你如何控制翻譯的品質？答：品質不是由我一人控制，所有的網友就是最好的監管者。我把這個系統設計&amp;nbsp;&amp;nbsp;&amp;nbsp; 成一個有機體，認養者提供資訊，閱讀的人若覺得有任何不妥，可以立即回饋反應，&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我只要負責查證，如果真的錯了，我隔天就更正，不用像傳統教科書還要等到下一個版本。在這過程中我深深體會，統合知識的能力勝於單一的天才，因為即使我找該領域最厲害的教授來做，&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 也不一定有這樣的品質，更何況我沒有花一毛錢，卻可以請到各行各業的專家來幫忙！ 問：這個計畫既無法取得版權也不能營利，對你的意義是什麼？答：我在計畫進行到一半時，曾到美國拜訪麻省理工學院OCW計畫總監Anne Margulies，當他們知道我是在沒有任何學術團體贊助下完成中文版網站時，大吃一驚！因為這個翻譯計畫的簡體中文版目前由大陸的一個官方機構在做，他們動員的人力與物力比&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我多很多，可是目前進度卻比我落後。我的這個計畫只是顛覆了很多人做事 情的方法。 一般人做新事業總是要先找場地或是辦公室，再找人找錢，或是開會再開會，我認為這是一個網路時代，人可以在網路上找，資源也可以在網路上創造，只要善用整合還有知識分享的力量，&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 就可以實踐看似不可能的夢想。請別小看這個創作共享的力量，我的這些譯者 都是不支薪的，&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 但為什麼願意花這麼多時間，因為他們發現將所學透過「知道、引用、分享」之後，自己反而是最大的受益者。問：MIT的開放式課程歡迎大家引用並且免費線上學習，似乎顛覆了傳統對智慧&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 財產權的觀念，難道不會引起MIT的老師或付了高學費才能上課的學生反彈？答：就我所知，多數老師反而歡迎這樣的作法，倒是學生家長有些意見，認為自己的孩子繳了學費才能進來，卻不能受到保障。MIT的理由是，線上學習開放的是知識，學費享受到的是受教育的權利，這個權利是可以用學校的設備，親自向老師問問題，以及學完後擁有證書的權利。但知識是不同的，知識要流通、要被引用才有用處。 </description>
    </item>
    
    <item>
      <title>Java theory and practice</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-02-193/</link>
      <pubDate>Tue, 02 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-02-193/</guid>
      <description>想要對 Effective Java 裡面的課題有更多探討的人，可以參考 Brian Goetz 在 developerWorks 的專欄 Java theory and practice。</description>
    </item>
    
    <item>
      <title>Effective Java</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-11-01-192/</link>
      <pubDate>Mon, 01 Nov 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-11-01-192/</guid>
      <description>我的上一次 Java programming 經驗已經是將近六年前的事了，JDK 那時才剛從 1.0 版升級至 1.1，後來因為工作內容的關係，C++ 才變成是我最常使用的程式語言。
前一陣子逛書店時瞄到了 Joshua Bloch 的《Effective Java Programming Language Guide》居然有中文版，原文的版本我是聞名已久卻沒空拜讀。我一看是侯捷翻譯的作品，二話不說便掏錢買下這本書，直到最近，我一時興起才把它讀完。
就內容而言，這本書絕對有資格跟《Effective C++》享有一樣的經典地位，不僅 Java programmer 要看，.NET programmer 也應該人手一本，因為其中的許多物件導向編程的道理是同時適用於 Java 與 .NET。中文版裡不通順或是有錯誤的地方倒是比我期待的數目多了一點，不過我想侯捷應該是不介意別人用高標準來檢驗他的作品。
下面是我發現的一些翻譯問題：
原文: Not only can the class of an object returned by a public static factory method be nonpublic, but the class can vary from invocation to invocation depending on the values of the parameters to the static factory.譯文 p7: public static factory method 傳回的物件不僅可以是個 nonpublic class 物件，而且視 static factory 函式參數的不同，還可以涉及不同的 nonpublic class .</description>
    </item>
    
    <item>
      <title>GraphViz</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-28-191/</link>
      <pubDate>Thu, 28 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-28-191/</guid>
      <description>嘗試用 GraphViz 畫 Release Line Pattern：
digraph G { node [shape=box]; { edge [arrowhead=none]; rank = same; &amp;quot;/main&amp;quot; -&amp;gt; &amp;quot;Release 1 Work&amp;quot; -&amp;gt; b1 -&amp;gt; &amp;quot;Release 2 Work&amp;quot; -&amp;gt; mr1fix -&amp;gt; b2; b2 -&amp;gt; future [arrowhead=normal]; b1 [label=&amp;quot;1.0&amp;quot; shape=circle]; mr1fix [label=&amp;quot;&amp;quot; shape=circle]; b2 [label=&amp;quot;2.0&amp;quot; shape=circle]; future [label=&amp;quot;&amp;quot; shape=plaintext]; } b1 -&amp;gt; r1; { edge [arrowhead=none]; rank = same; r1 -&amp;gt; r1fix -&amp;gt; r1m; r1 [label=&amp;quot;/Release 1&amp;quot;]; r1fix [label=&amp;quot;Bug Fixes&amp;quot;]; r1m [label=&amp;quot;&amp;quot; shape=circle]; } r1m -&amp;gt; mr1fix [style=dotted]; b2 -&amp;gt; r2; { rank = same; r2 -&amp;gt; r2future; r2 [label=&amp;quot;/Release 2&amp;quot;]; r2future [label=&amp;quot;&amp;quot; shape=plaintext]; } } 有興趣的人可以參考 An Introduction to GraphViz。</description>
    </item>
    
    <item>
      <title>Blog for nightly build changelog</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-26-190/</link>
      <pubDate>Tue, 26 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-26-190/</guid>
      <description>The Burning Edge 是 Mozilla Firefox 用來追蹤 nightly build 狀態的 blog，算是一種蠻特別的 blog 應用。在裡面，你可以看到每天 bug 修正的進度以及當天 build 的狀況，例如：
 Fixed: 265839 - External protocol handling broken (since Oct 21). Fixed: 263846 - Crash [@ nsImageFrame::FrameChanged][@ nsImageFrame::SourceRectToDest]. Fixed: 265849 - There&amp;rsquo;s no longer an Options button in the Download Manager. Fixed: 265826 - Update linux installer artwork. Fixed: 265829 - History code passes incorrect length to NS_ConvertUTF16toUTF8.  Official Windows, Official Windows installer (discussion), bangbang&amp;rsquo;s</description>
    </item>
    
    <item>
      <title>GTA3</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-25-188/</link>
      <pubDate>Mon, 25 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-25-188/</guid>
      <description>這個周末好不容易有機會把轟動歐美的 &amp;ldquo;Grand Theft Auto III&amp;rdquo; 拿出來玩，沒想到一玩就迷上它了。想想上一個能讓我有相同感動的遊戲已經是好多年前在 PS 上發售的 &amp;ldquo;Metal Gear Solid&amp;quot;。想想我實在是太後知後覺了，這麼棒的遊戲居然現在才知道。
我玩這個遊戲時，兩個小姪子在旁邊一直要我去毆打路人、搶別人的車子、跟警察火拼槍戰、或是來個飛車追撞，兩個小傢伙被逗的哈哈大笑，一旁的老婆直瞪我說敎壞小孩子，害得我一邊猛K路人還要一邊跟他們說不可這樣喔&amp;hellip; :-) 所以這遊戲還是不要在小孩子面前玩比較好。
GTA3 已經跟 &amp;ldquo;Metal Gear Solid&amp;rdquo; 並列為我心目中的最佳遊戲。</description>
    </item>
    
    <item>
      <title>技術人員轉型</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-25-189/</link>
      <pubDate>Mon, 25 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-25-189/</guid>
      <description>我不認識 Michael，但我喜歡看他的文章，我想是因為對於許多事情的看法頗為契合，例如說不必讓小孩子學電腦，或是對於資訊界一些荒謬現象的觀察。
Michael 的這篇線上演講『技術人員轉型秘笈』內容很幽默，把那些想光靠一張嘴混日子卻又不肯努力的人暗諷了一番。我想 Michael 的這篇線上演講應該能幫他的新書增加不少銷售量，至少我會想特地跑去書店翻翻這本書看是不是值得買。</description>
    </item>
    
    <item>
      <title>Examining Google Desktop</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-16-187/</link>
      <pubDate>Sat, 16 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-16-187/</guid>
      <description>下面是 Google Desktop 的一些觀察：
 Index 儲存在 Documents and Settings\User\Local Settings\Application Data\Google\Google Desktop Search，體積似乎還不小 (1,941 items indexed so far)，可能要等到整個系統的索引做完才知道會佔用多少空間。 安裝目錄內有一個 gzlib.dll，因此這一版應該支援 ZIP 內的搜尋 (希望以後可以支援 RAR 內的搜尋) 。 安裝目錄內的有一個 GoogleDesktopAPI2.dll 但是看不到相關的內容，不知道 Google 是否會公開詳細的規格？ 安裝目錄內的 GoogleDesktopNetwork1.dll 及 GoogleDesktopNetwork2.dll 似乎是個 Winsock SPI 的 DLL？  </description>
    </item>
    
    <item>
      <title>Google Server On Your Machine</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-16-186/</link>
      <pubDate>Sat, 16 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-16-186/</guid>
      <description>傳聞中的 Google Desktop 搜尋工具終於出現，詳情可以參考 O&amp;rsquo;Reilly Network 上的介紹。
整個使用者介面仍然遵循 Google 一貫簡單而直覺的風格，用起來跟網頁的搜尋一樣的順暢。下面是我的一些疑問 (或者說是期待的功能)：
 可以搜尋 MSN Messenger 交談紀錄嗎？ 可以搜尋我收集的一些 PDF 電子書嗎？ 可以搜尋 ZIP 起來的檔案嗎？ 可以搜尋我們公司那幾百萬行的程式碼嗎？ 可以寫 plug-in 擴充可以搜尋的檔案類型嗎？ Google 產生的 index 會佔多少硬碟空間？  </description>
    </item>
    
    <item>
      <title>Dilbert on Extreme Programming</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-12-185/</link>
      <pubDate>Tue, 12 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-12-185/</guid>
      <description>註：原圖來自於 dilbert.com 於 2003/01/09 及 2003/01/10 刊載的漫畫，但原網站已經移除原圖的鏈結。</description>
    </item>
    
    <item>
      <title>Grady Booch&#39;s Blog</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-11-184/</link>
      <pubDate>Mon, 11 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-11-184/</guid>
      <description>Grady Booch 的 blog 有一些精采的簡報：
 General Software Architecture Software Archeology The Limits of Software  </description>
    </item>
    
    <item>
      <title>Applied .NET Attributes</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-10-04-183/</link>
      <pubDate>Mon, 04 Oct 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-10-04-183/</guid>
      <description>《Applied .NET Attributes》是本有趣的書：精簡而專注。精簡是因為它只有短短的 232 頁；專注則是因為 custom attributes 是它的唯一主題。一開始我蠻訝異會有這樣主題的書籍出現，但仔細想了一下，custom attributes 的確是 .NET 中最值得討論的一個技術，因為它帶來了許多創新的可能性。
這本書在第一二三章首先解釋 attribute 的基本精神以及它在 compile-time, design-time, 及 runtime 所能發揮的功用。我尤其喜歡第四章中關於 ContextBoundObject 以及 AOP 的討論，這一章釐清了我以前不甚明白的一些概念。對於如何在 .NET 的環境實現 AOP 的人可以也參考下面這兩篇在 MSDN Magazine 的文章：
 Aspect-Oriented Programming Enables Better Code Encapsulation and Reuse Decouple Components by Injecting Custom Services into Your Object&amp;rsquo;s Interception Chain  </description>
    </item>
    
    <item>
      <title>奇異果的滋味</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-09-13-182/</link>
      <pubDate>Mon, 13 Sep 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-09-13-182/</guid>
      <description>一篇頗好笑的 BBS 轉載文章&amp;hellip;
 奇異果的滋味課長鳥耕作 〔面談新人不只可以強化心臟，還可以鍛鍊ＥＱ陶冶真善美，更可以聊出一些前所未聞的人生大道理。真是一項美好的活動，我愛面試，大家也都要愛唷～〕  日前讀到「白目職場新鮮人」的報導，有位姑娘以高職學歷索薪六至九萬、聲明不值班不加班、還要公司企業「無誠勿試」… 這種職場奇觀的確是很好笑，但憂國憂民的教育學者和企業主聽了恐怕是一點都笑不出來。我在一個財團法人機構裡的研發單位工作，有幸在數週月前遇到另一位有趣的少年郎，想必可以提供學者專家們去進行另外一番個案研究。&amp;nbsp;&amp;nbsp; 　這位仁兄，不是七年級的，也不屬於草莓族，而是一顆奇異果。為什麼是奇異果咧？他可能一開始也激射著草莓的亮麗與誘人香氣，但是幾經風霜雪雨的摧折，是發展出了保護層沒有錯，但它的堅韌僅只於膚淺，賣相還因此而變得更差。&amp;nbsp;&amp;nbsp; 　&amp;nbsp; 　下午四點多，我的小老闆探頭進來我的屏風，遞給我一份履歷表，說當事人已經來了，要我即刻加入面談。由於我的團隊最缺人，所以若是錄用了他，會優先補進來給我。於是我連忙放下手邊的工作，將電話設定轉接到手機上來，亦步亦趨地往會議室走去。 　哇哈哈哈哈，終於有新人可以補給我了呢，好耶好耶。後來我才發現這一點都不值得開心。我們這種不發股票也不發電影票的財團法人要找人向來就不容易，何況此時並不是換工作的熱季；在進入會議室之前，小老闆低聲耳語告訴我說，這位仁兄其實是我們某位長官的外甥，於是我們在錄用的考量上就又多了一個因素，更何況到職之後的各種訓練與工作指派，以及試用期滿是否續聘等人事議題。我們應該是一定會錄用他的啦，所以這場面試只是形式，就當做是一場互相認識的會談吧。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 會議室，人家已經坐在那兒了。趁著我小老闆在跟他介紹我們團隊概況的空檔，我趕緊研究研究他的履歷表... &amp;nbsp; （配樂：搭拉哩喇拉～） &amp;nbsp; 傑克，這世界已經好久沒有這麼神奇了，這份履歷表真的可以供起來當教材。我第一次看到履歷表可以這麼言簡意賅，總共也只有一張。嗯，我是說，只有一面。 &amp;nbsp; 前段是個人基本資料：　照片：無。　6X年次。男性。免役。未婚。Ｃ大資Ｏ系畢。美國南Ｊ大資Ｏ研究所畢。然後還在南Ｊ大後面加上（always USA Top10) 的貼心註解。　外語能力：英文＝聽／說／讀／寫：精通／精通／精通／精通 履歷第二部份顯示，他擁有三份專業資歷：　一份是他大學畢業前曾在我們單位內做過工程師（我一看就覺得其實應該是工讀生），做了九個月；一份是他碩士畢業後，在一家做視訊會議產品的公司（稱作Ａ），做了兩個半月；一份是現職，是一家無線通訊相關的公司（稱作Ｂ），到今天還未滿兩個月。 &amp;nbsp; 這個人年近30歲，不用當兵，照理說應該出來工作滿多年了，但他的職場軌跡似乎尚未建立。 &amp;nbsp; 面試官守則第一條：找出時序上的空洞，以引發最初期的話題。　　大學畢業到加入敝XX實驗室之前，空了五個月。　離開XX實驗室到出國念書之前，空了七個月。　兩年的碩士畢業到加入Ａ公司之前，空了一年多。　離開Ａ公司到加入Ｂ公司之前，空了四個月。 &amp;nbsp; 之於這些時序上的空洞，還真教我百思不解：重考？怎麼算都不對呀。不然咧…住院？坐牢？躲債？煙毒勒戒？票據通緝？黑道追殺？ &amp;nbsp; 　喂喂，做人不可以這麼不厚道，這樣月下老人會罰我以處男之身邁入不惑之年的。我現在是面試官，不是假釋官，更不是社工，我要專業，我要繼續將履歷表看下去，有什麼問題等會問他就是了。 　嗯。第三部份是自傳。啊呀，背面空白。原來奇異果先生的自傳總共才十多行。為文文法是網路聊天丟水球那種一句一句接起來的，比白話文還白話文的遣詞用字，當然更少不了最受人歡迎的濫用成語。其中兩行是完全沒有任何的標點符號，三十幾個字一路到底直接換行，讓我看得快要鬥雞眼了。最離譜的才這麼幾行，竟然錯字一堆，而且都是自然注音沒選字的那種錯法。自傳內容全無家庭狀況與求學過程，只簡述了過去在本單位和Ａ公司的相關經歷。他花了三分之二的篇幅來訴說他大學畢業後在本單位的工作有多勝任，有多愉快，然後訴說Ａ公司的管理有問題，他在試用期間所做出來的成果明明很好，產品經理也很滿意，「但不知為何總經理就是不喜歡」，於是就宣佈不續聘，「有圍有手」的他不想被「這種爛主管」所解聘，所以先自行離職，「以盡效由」。&amp;nbsp;&amp;nbsp; 　此時我的理智已在暴走邊緣～～深．深．深呼吸～不讓淚決堤～～文法也就算了，軟體工程師會寫程式比會寫中文現代詩來得重要，但標點符號跟注音選字是你多花一點點心思就可以處理好的事情，你為什麼容許你自己繳出這樣的履歷表咧？我很叫他當場拿紙筆出來寫一篇「我的志願」，可是我小老闆一定不會允許的。　終於要開始面試了。既然是要進我的團隊，就全部都由我主導發問與互動，我的小老闆則擔任記錄，以其他行政面的說明。那就依照慣例，從學校的部份做開場白吧。  　「不好意思，你有沒有帶成績單？」 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; （你不會只帶一張履歷表來吧？你為什麼不一坐下就先都拿出來呢？）　　然後他拿出一張令人相見不如懷念的C大的成績單，但我還不急著告訴他，我其實是你的學長。接著我再要研究所時期的成績單，他卻拿出一張護貝過的南Ｊ大畢業證書，跟我說，這張畢業證書很昂貴，掉了可不得了，你可以拿去看一下，看完我就馬上得收起來。請小心不要折到它，也不要留下手指印，那樣很難看的。　　活了三十年，我終於第一次深切地體驗到什麼叫做瞠目結舌。我以我最高境界的專業態度，心平氣和地告訴他說，我要看你的成績單，並不是質疑你是不是真的有畢業，而是想看看你修過些什麼課，修得怎麼樣，我還要花多少時間訓練你。不料他插嘴回答我說，他不需要什麼額外的訓練，可以「即插即用」。我認為這應該是個笑話，乾笑了幾聲。轉頭看看我小老闆，我小老闆正以橫眉豎目來暗示我不需這麼親切又慈愛，於是我又拿出了我的專業氣魄來。&amp;nbsp;&amp;nbsp; 　仔細看了看那張Ｃ大的成績單，我才發現他大二休學了一學期。他看出我的表情有異，忙著先行坦白：「我大一成績很差，其實是為了要追一個女孩子。結果女生沒有追到，成績也亂七八糟，於是我跟父母商量之後，我決定我想在家裡休息一陣子。但是，但是我還是八個學期就畢業了喔，而且我的成績有顯著的進步。你看這裡。還有這個。」好吧。會承認錯誤是個好現象，不論如何。我說了一些場面話，什麼「由此可見休息之後是可以走更長遠的路的」之類的。再來就問他的大學時的專題研究是做什麼題目，他竟然激動了起來，說跟他同一組的是一個大六的學長，混個要死，什麼事情都沒有做，然後老師也管管那個學長，事情都是他一個人做，到最後老師還給他那麼低的分數。我說那題目究竟是什麼呢？他說，他忘記了。我說那位老師是誰呀？他說，他「不想去記得」。場面有點僵，好像他因為我的探問而受到了二次性侵害似的。 &amp;nbsp; 　他每到激動處，說話就總有一種童腔童音，倒也不是嗲，很難形容。尤其是他在敘述中想要加強什麼事情的時候，會用「你知道嗎？xxxx，xxxx耶」這種句型，如「成績單很貴的，你知道嗎？是美國的，美國的學校的耶，不是Ｃ大這種十塊錢而已的」。然後若一不小心，他就會開始演講，知無不言地傾囊相授他之於某一個名詞的瞭解，自告奮勇要引領我們走出常識貧乏的蠻荒，如「Social Security Number社會安全號碼」和「梅竹賽」。然後他還把「竹」的典故給講錯，我也懶得糾正他，總之自此我們兩個面試官都必須小心翼翼地切入，以及轉移話題。&amp;nbsp;&amp;nbsp; 　在無聲勝有聲了一小會兒之後，我換個輕鬆的口吻問問他在留學南ＣJ大時期的事情。看看他在異國生活的經驗中，有無建立起美好的生活態度與價值觀。 &amp;nbsp; 「據我所知，在美國買車子滿便宜的。你當時有買車嗎？什麼牌子的呀？」（不知這仁兄花錢的態勢如何，敢放下一切去「休息」的人，想必有過人之處） &amp;nbsp; 「我們家並不有錢，所以我沒有買車。」（我我我我.</description>
    </item>
    
    <item>
      <title>.NET is better than COM</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-09-04-181/</link>
      <pubDate>Sat, 04 Sep 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-09-04-181/</guid>
      <description>Top 10 Reasons .NET is better than COM 很幽默地消遣了 Don Box&amp;hellip;</description>
    </item>
    
    <item>
      <title>Data Binding in Avalon</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-31-180/</link>
      <pubDate>Tue, 31 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-31-180/</guid>
      <description>A good introduction to the data binding mechanism in Avalon.</description>
    </item>
    
    <item>
      <title>&#34;,hr&#34;</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-30-179/</link>
      <pubDate>Mon, 30 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-30-179/</guid>
      <description>Matt Pietrek 居然不知道 &amp;ldquo;,hr&amp;rdquo; 的用法! 如同這個 blog entry 的第一篇評論，我感到蠻驚訝的。</description>
    </item>
    
    <item>
      <title>Coroutine implementation in C# 2.0</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-30-178/</link>
      <pubDate>Mon, 30 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-30-178/</guid>
      <description>Matt Pietrek 的《Fun with Iterators and state machines》解釋了 C# 2.0 如何使用 state machine 來實現 coroutine。</description>
    </item>
    
    <item>
      <title>Dependency properties</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-30-177/</link>
      <pubDate>Mon, 30 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-30-177/</guid>
      <description>剛接觸 Avalon 的人可能會對所謂的 Dependency properties 感到困惑 ，在《Three Extensibility Models: A Bad Thing?》裡，Drew 清楚地解釋 Attached properties (一種特別的 Dependency properties) 的用法及原理。
懂了 Attached properties 後可以再參考 Wesner Moise 的《Dynamic Properties and Code Generation》來了解 Dynamic properties 的概念。
最後《Core Concepts of the Presentation Subsystem (code-named &amp;ldquo;Avalon&amp;rdquo;)》可以讓你透視 Dependency properties 的目的，也就是實現下列這些機制： styling, databinding, animation, default values, value expressions, property invalidations, and inherence。</description>
    </item>
    
    <item>
      <title>My Shopping Cart for Technical Books</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-30-176/</link>
      <pubDate>Mon, 30 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-30-176/</guid>
      <description>下面是這次美國行要採購的書籍清單:
  Pragmatic ADO.NET: Data Access for the Internet World by Shawn Wildermuth    Design Patterns C# by Steven John Metsker    Coder to Developer: Tools and Strategies for Delivering Your Software by Mike Gunderloy, Sybex    Code Complete, Second Edition by Steve McConnell    Pragmatic Project Automation: How to Build, Deploy, and Monitor Java Apps by Mike Clark    Code Generation in Microsoft .</description>
    </item>
    
    <item>
      <title>Add-ins for Reflector</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-26-175/</link>
      <pubDate>Thu, 26 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-26-175/</guid>
      <description>之前的文章有提過 Lutz Roeder 的 Reflector，最近它已成為我每天必用的工具。這麼棒的東西想當然愛用者不只我一個人，有許多人已經開始為它擴充新的功能，例如：
Reflector.FileDisassembler
Reflector.Graph</description>
    </item>
    
    <item>
      <title>XAML &amp; Avalon</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-14-173/</link>
      <pubDate>Sat, 14 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-14-173/</guid>
      <description>Ian Griffiths&amp;rsquo;s articles about XAML and Avalon:
 Inside XAML Graphical Composition in AvalonBesides, Avalon Dissected is a series of articles about the architecture of Avalon. IMO, Avalon will enable Windows programmers to develop much richer applications than the ones we have today. It will change how we think about Windows application. I am excited about that. :-)  </description>
    </item>
    
    <item>
      <title>Minidump</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-08-10-172/</link>
      <pubDate>Tue, 10 Aug 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-08-10-172/</guid>
      <description>Some links about minidump:
John Robbins - Symbols and Crash DumpsMatt Pietrek - Improved Error Reporting with DBGHELP 5.1 APIsAndy Pennell - Post-Mortem Debugging Your Application&amp;hellip;Kim Gräsman - Minidumps and Security</description>
    </item>
    
    <item>
      <title>AccuRev</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-07-10-170/</link>
      <pubDate>Sat, 10 Jul 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-07-10-170/</guid>
      <description>06 Oct 16: 由於 AccuRev 的網站資料有些更新，所以我就把這篇小改了一下，順便移除幾個已經失效的URL。
昨天好不容易有空把這一期的 IEEE Software 翻了一 下，發現2004 年的 Jolt Awards 出爐了，其中的 Change and Configuration Management Tools 獎項是由 AccuRev 3.3.1抱走。
AccuRev 的獨特之處在於並非採用傳統的 file-based (如 CVS) 或是 branch-based (Perforce 或是 Subversion) 的思考方式，而是能反映實際工作流程的 stream-based 系統。我建議可以參考這個 demo 來快速了解其設計概念。
其中我最欣賞的兩個特色是 Private Versions 的支援與特別的 Progressive Promotion；Private Versions 允許 programmer 保存自己的更改紀錄而不影響到其他人的工作；Progressive Promotion 則是允許程式碼的改動可以根據工作流程而發佈出來。我相信這樣的版本控制系統應該會慢慢地在市場占有一席之地，其後勢發展是值得注意的。</description>
    </item>
    
    <item>
      <title>Comments in Windows Source Code</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-30-168/</link>
      <pubDate>Wed, 30 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-30-168/</guid>
      <description>相信很多人看過流傳在網路上的 Windows 原始碼，有沒有注意到這些在原始碼裡的有趣註解？
private\shell\shell32\util.cpp: // the fucking alpha cpp compiler seems to fuck up the goddam type &amp;quot;LPITEMIDLIST&amp;quot;, so to work&amp;lt;BR&amp;gt;// around the fucking peice of shit compiler we pass the last param as an void *instead of a LPITEMIDLIST private\windows\media\avi\verinfo.16\verinfo.h: * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! * !!!!!!!IF YOU CHANGE TABS TO SPACES, YOU WILL BE KILLED!!!!!!! * !!!!!!!!!!!!!!DOING SO FUCKS THE BUILD PROCESS!!!!!!!!!!!!!!!! * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! private\ntos\rtl\heap.c: // The specific idiot in this case is Office95, which likes // to free a random pointer when you start Word95 from a desktop // shortcut.</description>
    </item>
    
    <item>
      <title>Programming Quotes from WikiQuote</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-30-167/</link>
      <pubDate>Wed, 30 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-30-167/</guid>
      <description>Programmer 真的是一個很怪的族群，因為他們看到這些對平常人根本是無厘頭的話居然會覺得好笑：
&amp;ldquo;God is Real, unless declared Integer&amp;rdquo; - J.Allan Toogood, FORTRAN programmer
&amp;ldquo;Pascal keeps your hand tied. C gives you enough rope to hang yourself.&amp;rdquo;
&amp;ldquo;He who hasn&amp;rsquo;t hacked assemply language as a youth has no heart. He who does as an adult has no brain.&amp;rdquo; - John Moore
&amp;ldquo;Real programmers can write assembly code in any language.&amp;rdquo; - Larry Wall
&amp;ldquo;In C++ it&amp;rsquo;s harder to shoot yourself in the foot, but when you do, you blow off your whole leg&amp;rdquo; - Bjarne Stroustrup</description>
    </item>
    
    <item>
      <title>The BASIC Programming Language</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-30-166/</link>
      <pubDate>Wed, 30 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-30-166/</guid>
      <description>&amp;ldquo;It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.&amp;rdquo; - Edsger Dijkstra
&amp;ldquo;Teaching BASIC should be a criminal offense.&amp;rdquo; - Edsger Dijkstra
&amp;ldquo;BASIC - A programming language. Related to certain social diseases in that those who have it will not admit it in polite company.&amp;rdquo;
&amp;ldquo;Real Programmers don&amp;rsquo;t write in BASIC.</description>
    </item>
    
    <item>
      <title>.NET, Just for Fun</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-24-165/</link>
      <pubDate>Thu, 24 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-24-165/</guid>
      <description>好久沒看過這麼精彩的文章了！Joel 在 How Microsoft Lost the API War 裡的文筆依然犀利卻也帶著一貫的幽默。
雖然我第一個學會的程式語言是 Basic，就在我厭煩了要把行號從 50 改成 100 來放入更多的程式碼時，我就移情別戀，投入了 C 的懷抱。好吧，我承認我不用 Visual Basic 的部分原因是跟它的名字裡有 Basic 這個字有關，雖然有時候用它來開發程式真的又快又方便。因此當 C#出現時，它有著 VB 的簡單及方便性，但是語法及名字又是根源於 C 時，我就迷上它了。
因此 .NET 的出現對於已經厭煩了惱人的記憶體管理的我，如同 C 與 Basic 比較起來，不啻是個極大的誘惑。對一個 programmer 而言，.NET is fun，它可以我在陰暗的 Win32 API 角落裡還看得到一絲絲的希望。至於 .NET 是不是會普及，我倒是不那麼擔心，畢竟 Microsoft 把賭注都下在上面了，就讓他們去操心好了。
我覺得 Joel 有點太悲觀了，畢竟 Win32 API 仍然存在於 Longhorn 或 Windows N；舊的 Win32 程式依然可以在 Longhorn 上執行；許多公司依然使用 Win32 API 開發 Longhorn 的程式；只是 developers 多了一種新的、可以讓 developers 少掉幾根頭髮的選擇，不是很好嗎？
『Just for Fun』是我現在對 .</description>
    </item>
    
    <item>
      <title>NoStepInto in VS 2003</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-17-164/</link>
      <pubDate>Thu, 17 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-17-164/</guid>
      <description>今天發現在 Visual Studio 6 可以用 autoexp.dat 來取消 step into的功能在 VS 2003 沒有作用。Google 了一下，原來是做法改了，詳情參考《 How to Not Step Into Functions using the Visual C++ Debugger 》。 </description>
    </item>
    
    <item>
      <title>Streamed Lines</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-15-163/</link>
      <pubDate>Tue, 15 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-15-163/</guid>
      <description>軟體開發流程裡頗為複雜的一項工作就是 source code branching，也就是為了某個目的，將程式碼複製為數個分支，分別以不同的方式進行開發與維護。
Streamed Lines: Branching Patterns for Parallel Software Development 是 Brad Appleton 等人為了實現平行開發而提出的 patterns。整篇文章有 67 頁之多，已經快要可以出一本書了，不過值得對 SCM 有興趣的人細讀。</description>
    </item>
    
    <item>
      <title>勇氣、度量、與智慧</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-14-162/</link>
      <pubDate>Mon, 14 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-14-162/</guid>
      <description>由於最近都在看對岸的一些文章，甚至連找到的漫畫也是簡體中文版，我對於簡體字已經能夠適應，看不懂的大概都能猜出相對應的繁體字；只是我實在不太能接受『聖鬥士』變成了『圣斗士』，真的有點怪。
 有勇气来改变可以改变的事情，有度量接受不可改变的事情，有智慧来分辨两者的不同。  這句話是我從微软亚洲研究院首任院长李开复的《成功 自信 快乐 - 给中国青年学生的一封信》看到的，說的好。不過我記得比爾蓋茲在哈佛是唸法律的，怎麼變成唸數學了？</description>
    </item>
    
    <item>
      <title>Custom Attribues and eXtensible C#</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-09-161/</link>
      <pubDate>Wed, 09 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-09-161/</guid>
      <description>Pierre Nallet 的文章《Get Personal with C# Custom Attributes》介紹了 custom attributes 的應用。他把 custom attributes 分成了三類：user attributes, runtime attributes, 及 compile time attributes。一般常用的 System.Runtime.InteropServices.StructLayoutAttribute 就是屬於 runtime attributes，因為 JIT 是在執行時期才決定物件資料欄位的排列方式。
如果你有仔細查閱 System.Diagnostics 裡面的一些 attribute class，你會發現一些有趣的 attribute 應用，如 DebuggerHiddenAttribute 可以阻止 debugger 設定中斷點、DebuggerStepThroughAttribute 可以阻止 debugger 的 step into 功能。
Pierre Nallet 同時也是 eXtensible C# (XC#) 的作者。
對 Attributed Programming 有興趣的人可以參考《Applied .NET Attributes》這本書。</description>
    </item>
    
    <item>
      <title>Enjoy Code</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-04-160/</link>
      <pubDate>Fri, 04 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-04-160/</guid>
      <description>博客堂 (http://blog.joycode.com/) 有蠻多對岸的 .NET 技術人員聚集，有興趣的人可以訂閱他們的 RSS。 對我而言，除了從中吸收別人的知識經驗，也是一個不錯的管道可以了解對岸的程序員文化。</description>
    </item>
    
    <item>
      <title>Nullable types</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-04-159/</link>
      <pubDate>Fri, 04 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-04-159/</guid>
      <description>又有一項新的功能或者說是 syntax sugar 加入 C# 2.0 的規格，詳情參考 Nullable types in C# 中的討論。
簡單地說就是『允許 value type 也能有 null 值』。例如
int? x = 125; if (x != null) { ... } 我喜歡這個概念，總比一般把『整數初始化成 -1 代表不合法值』的手法好多了。</description>
    </item>
    
    <item>
      <title>The Weird &#34;break;&#34; in switch/case</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-04-158/</link>
      <pubDate>Fri, 04 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-04-158/</guid>
      <description>Ask a Language Designer 解答了一個困惑我很久的問題：為什麼 C# 中的 switch/case 不允許 fall-through 卻需要 break 來離開 case 區塊？
雖然這個答案還是不能說服我去接受它，但至少我知道了為什麼。</description>
    </item>
    
    <item>
      <title>Playin&#39; with IT</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-02-156/</link>
      <pubDate>Wed, 02 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-02-156/</guid>
      <description>对牛乱弹琴 | Playin&#39; with IT 是我最近常逛的 blog。
 微软的核心竞争力，不在于那些Windows代码，就像可口可乐的核心竞争力，也绝不是那个被神秘化了的配方。  說的好呀!</description>
    </item>
    
    <item>
      <title>Team System</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-06-02-157/</link>
      <pubDate>Wed, 02 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-06-02-157/</guid>
      <description>Rational 及其他軟體開發工具廠商注意了，因為 Microsoft 即將出招，那就是 Visual Studio 2005 Team System。
看了幾個 demo，Team System 跟 Visual Studio 的整合程度相當地高，整體上而言頗令人期待。與開發流程中的設計、測試、專案管理及協同作業的整合是這個產品的主題：
 代號『Whitehorse』的 Distributed Systems Design。 靜態程式分析工具: PREfix &amp;amp; PREfast，詳情可以參考本期 IEEE Software 的 《Righting Software》。 專案管理的工具 增強的原始碼管理工具: 沒提到跟 Visual SourceSafe 的詳細差異，我期待能有一些令人驚訝的改進。 整合的測試環境: Test-Driven Development 終於可以更簡單地實現。  只是似乎少了一個 bug tracking system。</description>
    </item>
    
    <item>
      <title>x86-64</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-05-31-155/</link>
      <pubDate>Mon, 31 May 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-05-31-155/</guid>
      <description>Yes, the age of 64-bit computing is coming: An Introduction to 64-bit Computing and x86-64.
在個人電腦上的 RAM 動輒以 GB 來計算的今日，32-bit 帶來的 4GB 定址空間已經不再是個遙不可及的龐大數字。就讓我們猜猜 x86-64 及 IA-64 何者能勝出&amp;hellip;</description>
    </item>
    
    <item>
      <title>Coder To Developer</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-05-07-151/</link>
      <pubDate>Fri, 07 May 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-05-07-151/</guid>
      <description>Coder To Developer 是 Eric Sink 及 Joel 推薦的好書，網站上有完整的目錄及試讀的章節。
你剛從學校畢業，苦惱於該選擇去「規模大而制度完整」或「規模小但正在起步」的軟體公司。作為你的第一份工作，我認為小軟體公司會是比較好的選擇，因為『你必須學會更多的東西』。在小軟體公司工作，programmer 除了基本的 coding 能力外，還得學會如何做需求分析 (requirement analysis)、架構設計 (architecture design)、時程控制 (scheduling)、選擇開發方式 (methodology)、程式碼版本控制 (source code version control)、錯誤追蹤 (bug tracking)、文件撰寫 (documentation) 等等。當然不是說大的軟體公司不做這些事，而是你會比較有機會親身參與並規劃這些事，從其中學到的東西絕對比在大公司來的多。
如果你現在就在小軟體公司工作，我想《Coder To Developer》有一些實用的建議可以讓你把這些事情做的更好。</description>
    </item>
    
    <item>
      <title>Free Visual C&#43;&#43; Compiler</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-05-07-152/</link>
      <pubDate>Fri, 07 May 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-05-07-152/</guid>
      <description>Microsoft 提供免費的 Microsoft Visual C++ Toolkit 2003，其中包含了跟 Visual Studio .NET 2003 一樣的 C++ compiler。其實 Microsoft 早就應該這樣做了，畢竟現在有誰在 Windows 上不用整合開發環境 (IDE) 來寫程式，提供免費的 C++ compiler 一點也不會影響 Visual Studio 的銷售。提供免費的 C++ 編譯器來推廣 .NET 平台的普及，我想是這個事情最主要的原因吧。</description>
    </item>
    
    <item>
      <title>SourceUnsafe</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-22-148/</link>
      <pubDate>Thu, 22 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-22-148/</guid>
      <description>每次有人推薦使用 Microsoft Visual SourceSafe 的時候，我就會忍不住跳出來告訴他們這篇文章 Visual SourceSafe: Microsoft&amp;rsquo;s Source Destruction System。
我已經很多年沒有用 VSS 了，也不懷抱任何一絲絲的希望 Microsoft 會想要改進這些缺點，因為實在有其他更好的選擇。我甚至懷疑 Microsoft 自己用不用 VSS 存 Windows 的 source code？Microsoft 自己都不吃的狗食怎麼會讓人有信心使用？</description>
    </item>
    
    <item>
      <title>英代爾管理之道</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-22-149/</link>
      <pubDate>Thu, 22 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-22-149/</guid>
      <description>推薦一本好書《英代爾管理之道》(原名為 High Output Management)
 《英代爾管理之道》目錄序 第一篇　早餐廚房 第一章　生產的基本要素 限制步驟／生產運作／複雜化／找出最佳解決方案／測試與驗貨／及早發現及早治療／以美國司法審判為例 第二章　早餐工廠的管理 建立指標／指標配對／黑箱子／控制產出／品質保證／產能／槓桿率 第二篇　團隊合作 第三章　管理槓桿率 經理人的產出是什麼？／老爸，你在公司裡到底在幹嘛？／我的一天／管理活動的槓桿率／授權也是槓桿率／監督原則／增進管理活動的速度／你應該有多少個部屬？／干擾與突發狀況／解決良方 第四章　會議 過程導向會議／任務導向會議 第五章　決策 理想的決策模式／同儕團體症候群／努力求產出／實例應用 第六章　規劃 規劃流程／規劃流程的產出／目標管理／兩個歷史上的案例 第三篇　團隊中的團隊 第七章　早餐廚房進軍全國市場 分店開張／集權或分權？／複雜性日增 第八章　混血型組織 二個極端的組織類型／混血型組織／ＡＢＣ電腦公司組織重整／其他例子 第九章　雙重報告 工廠警衛室該向誰報告？／同儕團體／讓混血型組織有效運作／二度空間組織 第十章　控制行動的模式 自由市場考量／契約義務／文化價值觀／經理人的角色／最適控制模式／實務應用 第四篇　參賽者 第十一章　激勵部屬 基本生理需求／安全感／歸屬感與認同感／地位與尊重的需求／自我實現的需求／金錢及工作相關回饋／恐懼／競賽 第十二章　工作相關成熟度 工作相關成熟度／隨成熟度變化管理風格／生命相關成熟度／建立共同價值觀／管理風格與管理槓桿／好經理難為 第十三章　績效評估 為何費此周章？／決定部屬的績效／告知績效／正反兩面俱陳／衝突性評估／評估明日巨星／其他做法 第十四章　兩件艱鉅的任務 面試／我不幹了！ 第十五章　報酬 工作相關回饋／績效獎金制度／底薪制度／陞遷／再回收 第十六章　訓練部屬 誰該負責？／注意事項 最後的叮嚀 生產／槓桿率／績效 中英文名詞對照表  </description>
    </item>
    
    <item>
      <title>Real Sucks</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-20-147/</link>
      <pubDate>Tue, 20 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-20-147/</guid>
      <description>&amp;ldquo;It used to be a great technology company, and now it&amp;rsquo;s a great marketing company,&amp;rdquo; said MPR&amp;rsquo;s Barnes.
Real Player 是給我使用者經驗最糟的一個 Windows 程式，Real Networks 很明顯地是 &amp;ldquo;You can make money without doing evil.&amp;rdquo; 這條規則的反例。</description>
    </item>
    
    <item>
      <title>CC2</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-16-146/</link>
      <pubDate>Fri, 16 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-16-146/</guid>
      <description>我已經不記得第一次讀 Code Complete 是幾年前了，但是對於書中的許多內容我還是記憶猶新，它可說是影響我程式設計風格最重要的一本書。十年後，令人引頸期盼的 Code Complete 第二版 即將於六月就要上市。想靠 progamming 吃飯卻沒看過這本書的人一定要看，而看過第一版的人可以買第二版再看一遍&amp;hellip;</description>
    </item>
    
    <item>
      <title>Avalon &amp; Indigo</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-09-144/</link>
      <pubDate>Fri, 09 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-09-144/</guid>
      <description>兩篇入門 Avalon 及 Indigo 的文章:
 Introducing the New Avalon Graphics Model Inside &amp;ldquo;Indigo,&amp;rdquo; Chapter 2: The Journey of a Message  </description>
    </item>
    
    <item>
      <title>Quit thinking and look</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-02-140/</link>
      <pubDate>Fri, 02 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-02-140/</guid>
      <description>最近遇到了一個頗為難纏的 bug，症狀是當燒錄光碟的動作完成後，有些視窗的背景會變成黑色而不是原來的背景圖案；如果燒錄的資料量越大，這問題就越快出現；更奇怪的是這問題只會發生在安裝的版本而不是開發人員自己編譯出來的版本。
根據 debugging rules 的第二條規則 &amp;ldquo;Make it fail&amp;rdquo;，最重要的事情是在開發人員的機器上重現這個問題。我們首先嘗試將開發人員編譯的執行碼來覆蓋安裝的版本，結果問題還是會發生；反之，用安裝版本來覆蓋開發人員編譯的執行碼也不會有問題。對於這樣的結果，我們感到相當困惑，因為如果不是程式碼造成的差異，那會是什麼因素造成這樣的結果？
根據 rule 3 &amp;ldquo;Quit thinking and look&amp;rdquo;，我們決定多做一點嘗試，完整複製整個環境而不是只有執行碼。花了一番功夫，我們發現居然是執行檔 manifest 的問題，關鍵在於 manifest 中的這一段：
&amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity type=&amp;quot;win32&amp;quot; name=&amp;quot;Microsoft.Windows.Common-Controls&amp;quot; version=&amp;quot;6.0.0.0&amp;quot; publicKeyToken=&amp;quot;6595b64144ccf1df&amp;quot; language=&amp;quot;*&amp;quot; processorArchitecture=&amp;quot;x86&amp;quot;/&amp;gt; &amp;lt;/dependentAssembly&amp;gt; 這差異會導致 common control 6.0 被使用，於是我們在開發人員的電腦採用這樣的 manifest 很快就重現這症狀了。現在問題是那裡的程式碼導致這樣的錯誤？由於當初猜測是 GDI 方面的問題，我們把 Windows Task Manager 叫出來，並且追蹤程式執行時的 GDI objects 數量，才赫然發現當問題發生前的一瞬間，GDI objects 的數量會暴增至 10000。此時我們很確定這是由 GDI leak 產生的問題，但對於為什麼換用新版的 common control 會導致這個 bug 卻是沒什麼頭緒。
於是我們採用檢查問題發生點附近的程式碼，一邊單步執行一邊觀察 GDI Objects 的數量。用這樣的方法慢慢檢查，發現只要一呼叫 CStatic::SetBitmap，就會有一個 GDI leak 產生。我們終於明瞭新版的 common control 對於 STM_SETIMAGE 有不一樣的處理方式：static control 有可能複製我們傳進去的 bitmap handle，因此我們有義務把傳回來的 bitmap handle 釋放掉。</description>
    </item>
    
    <item>
      <title>The n Habits of Highly Defective Windows Applications</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-04-01-139/</link>
      <pubDate>Thu, 01 Apr 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-04-01-139/</guid>
      <description>這篇文章《The n Habits of Highly Defective Windows Applications》是上班時努力地 google，想要找出方法來解決一個 GDI leak 時，不小心發現的。文章點出了許多撰寫 Windows 程式的壞方法、壞習慣，裡面包含了許多我曾經犯過而且其他新手也常常在犯的錯誤。假如你想把 Windows programming 學好，你應該嚴肅地看待文章中提出的警告。
文章作者對於 Win32 programming 相當有研究，他的其他相關的技術文章可以在 MVP Tips, Techniques, and Goodies 找到，篇篇精采。</description>
    </item>
    
    <item>
      <title>10 Tips from the Ruby Creator</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-03-30-138/</link>
      <pubDate>Tue, 30 Mar 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-03-30-138/</guid>
      <description>出自於 Ruby Creator Y. Matsumoto, CIPS Connections:
 Learn more than one programming languages, preferably many different style ones, like scripting, object-oriented, functional, logic, etc. Learning languages teaches you many about programming. Read good books, for example, &amp;ldquo;Pragmatic Programmers&amp;rdquo;, &amp;ldquo;Refactoring&amp;rdquo;, and &amp;ldquo;Art of Computer Science&amp;rdquo;. Read the source code. The source code is the source of information and knowledge. Thanks to the opensource. Don&amp;rsquo;t focus too much on tools. Tools changes.</description>
    </item>
    
    <item>
      <title>Show me the money</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-03-30-137/</link>
      <pubDate>Tue, 30 Mar 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-03-30-137/</guid>
      <description>與其說最近忙翻了，不如說被許多事情煩到無法靜下心來念一些東西。Anyway，晚上終於可以看看 Eric Sink 的新文章《Closing the Gap, Part 1》，個人覺得很妙的一篇。</description>
    </item>
    
    <item>
      <title>Anonymous Methods in C# 2.0</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-24-133/</link>
      <pubDate>Tue, 24 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-24-133/</guid>
      <description>Anonymous method 是 C# 2.0 的新功能之一，從這兩篇文章可以看到 C# 如何在 CLR 上實作 closure 的機制。
 C# V2.0 Delegate Syntax and Conceptual Integrity, Ian Griffiths Introduction to Anonymous Methods and Higher-Order Procedures in C#, Steve Maine  </description>
    </item>
    
    <item>
      <title>Hard Reading on Garbage Collection</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-24-134/</link>
      <pubDate>Tue, 24 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-24-134/</guid>
      <description>幾篇跟 CLR 的 garbage collection 有關的技術文章：
 Finalization, Chris Brumme 對於 finalization 的機制做了深入的探討，包括 finalizer 帶來的成本、一些使用限制的緣由、及一些必須謹記在心的原則。 Dispose Idiom, Tristan Cartony 提供了範例程式說明在各種情況下如何實作 Dispose Idiom。 Resource management, Brian Harry 探討了如何在 garbage collection 的環境下實現 deterministic finalization。 .NET Framework Resource Management 把所有的 type 根據管理資源的方式分成了 simple, finalizable, disposable, 及 disposable and finalizable (both) 四種類型，並且詳細地說明了各種類型適用的時機。除此之外，有幾個比較少被談到的主題也涵括在內，如 threading issues, versioning, resource collector pattern, IEnumerable with expensive resources。個人認為是蠻實用的一篇文章。  </description>
    </item>
    
    <item>
      <title>當個驕傲的工程師</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-23-131/</link>
      <pubDate>Mon, 23 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-23-131/</guid>
      <description>公司同事轉來的一篇文章：
 別立志當個工程師 曾幾何時，工程師成了財富的代名詞，大概是從那些科技公司高配股政策，再加上媒體的宣染，給社會大眾的印象開始吧！
當然，我談的是所謂科技公司的工程師，尤其是在科學園區，以廠為家，一天工作超過16小時的那些人。至於那些在傳統產業的工程師，喔，對不起，時代已經忘了你們，不在我們所謂的工程師之列。別怨恨社會把你們遺忘，你們沒有工作16小時，手中也沒有一大堆市值一百元以上的股票，對於媒體而言，你們是毫無新聞價值的。勞苦功高…，那是維士比想賺你們的錢所想出來的行銷名詞….啊….福氣啦！你對媒體所謂的工程師印象是什麼？也許我們可以從週遭的人口中探出一點端倪：
隔壁的王媽媽笑嘻嘻地說：『我大兒子清大資工研究所畢業，現在在台機電當工程師，公司給他的股票已經累積近百張了；二兒子今年會從台大電機研究所畢業，聯發科給他10張股票請他去上班，現在每張市值都300多元了…什麼？好久沒看到他們？老大已經半年沒回家過了，這回兒也不知道在美國還是中國大陸…』
喔！工程師就是高學歷，出身名校，一畢業就身價不凡，而且，是媽媽的驕傲，但是…很少有時間回家看父母。
某百貨公司的專櫃小姐要人替他介紹男朋友，條件是，科技公司的工程師，她說出她的理由：『我有一個朋友嫁給工程師，年薪加股票每年收入好幾百萬，可是她老公的工作時間非常長，回到家還是繼續工作，雖然生活亂無情趣的，可是為了補償她老婆，從不管我朋友怎麼花錢，這倒滿符合我要的生活』
喔！工程師就是很會賺錢，但是沒有時間陪家人，所以會以金錢來彌補她內心的愧疚。
某工程師的妹妹則是非常不屑與工程師交往，她說：『錢多又怎樣？除了工作，他們還是工作，我之前就有一個當工程師的男友，永遠只會送花，好不容易有時間約會，每次都是法國餐廳，笑話永遠都和電腦有關，超無趣、亂悶的』
喔！工程師永遠都不會是一個好的情人，悶悶的，可能所有的創意都獻給公司了，所以對於浪漫這檔事…對不起，他們缺乏這個基因！
問問公司的Sales吧：『其實我很佩服他們，可以在電腦前坐上一整天，如果你不主動和他們說話，他們可能一天都不開口。我就觀察了這些人很久，發現就算坐在他們附近的人，如果彼此的工作沒什麼關係，一年下來，他們也只是點頭之交，每天最多只是「早」、「Bye bye!」兩句話』
喔！工程師就是不大懂得怎麼與人相處，不能說他們的人際關係不好，而應該說，要他們和不熟的人聊天，對他們來說是有很高的心理障礙。
那工程師的老婆怎麼說呢？中國信託銀行向員工致敬的廣告不是說的一清二處了嗎？！老婆們永遠不懂，他們的老公怎麼會連工作時間也要和人比較，一定要等家庭出了事，他們才會放向手中的工作回頭關心家裡？（對於這個廣告，其實我也不是很懂，這家公司到底是在炫耀還是在懺悔？）
喔！工程師就是只會處理工作上的危機，對於生活上的危機，對不起，他們不在行。
不公平，都是週遭的人的刻版印象！我們還是要聽聽工程師怎麼說：『我其實是樂在工作，不過上個月我們那個每天工作到凌晨的36歲經理突然中風，我突然有點擔心，因為最近也常感到疲憊。但是看到那些剛從學校畢業的小夥子那種拼勁，我非常擔心我在公司的地位不保。我一定要努力工作15年，存了一大筆錢後45歲退休，我現在才工作5年，還有10年要打拼。什麼？怕不怕和經理一樣，我想應該不會，因為自從經理中風之後，我現在一定10點前就收工回家…』
喔！工程師努力工作並不完全是為了錢，大都有興趣在支撐，不過，可能是長時間工作的關係，看來身體都不會太好。其實他們也會知道疲憊，所以才會訂下一個被媒體歌頌的『用力工作15年』的職場生涯規劃。
如果你是一個又會玩，又會生活，又有一大群工作以外的朋友，而且又是被老闆賞賜的工程師，我向你致敬，你真的是不可多得的人才。如果你不是，千萬別立志當個成功的工程師&amp;ndash;雖然應該努力工作，卻也應該懂得生活，尤其千萬別讓自己成為『過勞死』的代表，因為幾百張股票也喚不回健康及美滿的家庭。
給工程師的建議是，多花點時間陪陪家人，別讓孩子長大後才去後悔沒有參與他們的成長；多多關心週遭的人、事、物，你會發現生活可以這麼有趣！
希望下次有人會對你說，『你看起來不大像工程師』，這才是真正對你工作及生活方面雙重的肯定。
 ㄟ… 這篇文章對工程師的要求也太多了吧，不僅要會賺錢、還要幽默風趣兼浪漫、每天可以有很多時間陪家人、最好還是個萬人迷。整篇文章的論點都很片面而狹隘，強把自己的價值觀硬加在別人的身上，例如『多多關心週遭的人、事、物，你會發現生活可以這麼有趣』這話沒錯，但是你能說工程師他們從事的工作就是無趣的嗎？每個人對有趣的定義都不同，只因為工程師的興趣跟一般人不太一樣就強把“無趣”這兩個字冠在他們頭上未免也太不公平。『做個成功的工程師 』跟『過著家庭與事業均衡的生活』是兩碼子事，作者似乎把『超時工作』跟『成功』混為一談了。
大部分的工程師是怪了點 (喜歡談論科技、對電腦有超乎常人的熱衷、不擅與人相處、有點工作狂、衣著沒什麼品味)，但我認為這就是他們之所以適合當工程師的特質。我向來很自豪地說我是個軟體工程師，如果人家認為我有點怪，其實我還蠻高興的，因為我認為當工程師當到人家認為你不怪實在是有點遜。英文有個字叫 Geek，一般字典的解釋是怪胎，但近來被用來形容對電腦有莫名狂熱的人，因為這種人都怪怪的。其實我還蠻驕傲地認為 “I am definitely a geek.”。</description>
    </item>
    
    <item>
      <title>Visual Assist</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-19-130/</link>
      <pubDate>Thu, 19 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-19-130/</guid>
      <description>打一下廣告： Visual Assist 有新的 beta 版本了。我不知道該怎麼形容這個東西，但是寫程式時沒有它我就渾身不自在&amp;hellip;</description>
    </item>
    
    <item>
      <title>名人談軟體</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-10-129/</link>
      <pubDate>Tue, 10 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-10-129/</guid>
      <description>看完了Anders Hejlsberg 的訪談錄之後，我才發現 Bill Venners 其實訪問過許多軟體業界的知名人物，如 James Gosling, Bruce Eckel, Andy Hunt &amp;amp; Dave Thomas, Guido van Rossum, Scott Meyers, Martin Fowler, Josh Bloch, Ward Cunningham, Bertrand Meyer, Bjarne Stroustrup, &amp;hellip; 哇！都是我的偶像！
只是我的 To-Read List 霎時多了八、九十篇文章&amp;hellip; 傻眼&amp;hellip;</description>
    </item>
    
    <item>
      <title>Bruce Eckel&#39;s Weblog</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-08-128/</link>
      <pubDate>Sun, 08 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-08-128/</guid>
      <description>今天在閱讀一些關於 checked/unchecked exception 爭議的文章時，忽然發現 Bruce Eckel 也有自己的 weblog: Thinking About Computing。
從 5-2-03 Strong Typing vs. Strong Testing 及 Does Java need Checked Exceptions? 可以看出 Bruce 是傾向於支持 unchecked exception。
下面是我找到這些文章的連結路徑：
 13 Exceptional Exception Handling Techniques   Best Practices for Exception Handling  Does Java need Checked Exceptions?   Three Rules for Effective Exception Handling    </description>
    </item>
    
    <item>
      <title>Leaky Abstractions</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-05-126/</link>
      <pubDate>Thu, 05 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-05-126/</guid>
      <description>Joel 總是能將事情解釋地比別人更好：《 The Law of Leaky Abstractions》(相關討論) 是 Joel 的文章中我最喜歡的幾篇之ㄧ。
寫過 Java 或是 .NET 程式的人大概都知道什麼是 garbage collection，甚至連 garbage collection 是什麼都不知道的人還是可以寫出一個正確無誤的程式。在這裡 garbage collection 就是一個簡化記憶體配置機制的抽象概念，這概念大大簡化了程式員要花在追蹤記憶體配置情況的心力；然而從此程式員就過著幸福快樂的日子了嗎？喔不&amp;hellip; 根據 The Law of Leaky Abstractions，garbage collection 在某些情況下反而會帶來更多問題。其中一個明顯的漏洞就是它的不可預期性，也就是你無法預期系統那時候會進行 garbage collection，因此這漏洞逼迫你要了解 garbage collection 的基本運作原理，並且要用另外一個方法來彌補它。因此 garbage collection 帶給我們的並不是完美的世界，如果你不了解其中的運作原理，很容易誤入背後潛藏的陷阱而不自知。
所以最好的策略就是：Try your best to know what&amp;rsquo;s under the hood.
附帶一提，對 .NET Framework 的 garbage collection 機制有興趣的人可以參考 Jeffrey Richter 的兩篇文章，《Garbage Collection: Automatic Memory Management in the Microsoft .NET Framework》及《Garbage Collection-Part 2: Automatic Memory Management in the Microsoft .</description>
    </item>
    
    <item>
      <title>科技設計</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-05-127/</link>
      <pubDate>Thu, 05 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-05-127/</guid>
      <description>科技演進及其對社會的影響 The evolution of technology and its social impacts：蠻有趣的，我想應該大學的資訊科系應該開一些類似的課程，尤其是偏重軟體設計的。
我想我們需要更多有品味的軟體開發人員。:-)</description>
    </item>
    
    <item>
      <title>.NET Performace Optimization</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-04-125/</link>
      <pubDate>Wed, 04 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-04-125/</guid>
      <description>Several articles about .NET performace from Microsoft CLR Performance Team:
 Gregor Noriskin, Writing High-Performance Managed Applications : A Primer, MSDN. Jan Gray, Writing Faster Code: Knowing What Things Cost, MSDN. Rico Mariani, Garbage Collector Basics and Performance Hints, MSDN.  </description>
    </item>
    
    <item>
      <title>A Conversation with Anders Hejlsberg</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-02-124/</link>
      <pubDate>Mon, 02 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-02-124/</guid>
      <description>Anders Hejlsberg 在 Bill Venners 及 Bruce Eckel 的專訪下暢談了 C# 的設計理念，一共有八篇訪文，我直接條列如下以方便點閱。
 Part I: The C# Design Process Part II: The Trouble with Checked Exceptions Part III: Delegates, Components, and Simplexity Part IV: Versioning, Virtual, and Override Part V: Contracts and Interoperability Part VI: Inappropriate Abstractions Part VII: Generics in C#, Java, and C++ Part VIII: CLR Design Choices  訪問的內容篇篇精彩，我個人尤其佩服 Anders 設計 C# 時採行的務實 (pragmatic) 觀點。事實上，了解「一個程式語言為何被如此設計」消極地能避免語言特性的誤用，積極地能讓你寫出更好的程式。&amp;ldquo;Know Why&amp;rdquo; 絕對是精通一個語言的必經過程。
這裡是另外一篇更早的專訪 (08/01/2000)：Deep Inside C#: An Interview with Microsoft Chief Architect Anders Hejlsberg</description>
    </item>
    
    <item>
      <title>C# Generics</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-02-123/</link>
      <pubDate>Mon, 02 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-02-123/</guid>
      <description>兩篇關於 C# Generics 的技術文章：
 An Introduction to C# Generics by Juval Lowy Brandon Bray 對 C++ Templates 及 C# Generics 做了一番深入的比較。  </description>
    </item>
    
    <item>
      <title>軟體公司創業指南</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-02-122/</link>
      <pubDate>Mon, 02 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-02-122/</guid>
      <description>我快變 Eric 的忠實讀者了：《Getting Started with Your Own Software Company》。</description>
    </item>
    
    <item>
      <title>Partial Types</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-02-01-121/</link>
      <pubDate>Sun, 01 Feb 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-02-01-121/</guid>
      <description>由這段話可以一窺 partial types 的原始構想：
 Host: Anders (Microsoft) Q: What&amp;rsquo;s the aim of partial types in C#? A: Two reasons. First, people often ask us for include files. When we dig a little deeper, it turns out they want to split large classes into multiple files. Partial types will allow you to do that, but in a structured fashion. Second, partial classes solve the round trip problem with auto generated code.</description>
    </item>
    
    <item>
      <title>BitTorrent</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-01-30-120/</link>
      <pubDate>Fri, 30 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-01-30-120/</guid>
      <description>BitTorrent 是一種新的檔案傳播方式，看起來蠻適合在網路上用來下載一些大型檔案。我想一些免費下載的大型檔案 (如光碟的 ISO 檔) 應該會慢慢地換成用 BitTorrent 散佈。
不知道 Debian Linux 是否有打算從 Jigdo 換成 BitTorrent 來 散佈 Debian DVD 光碟映像檔？Jigdo給我的使用經驗不是很好。</description>
    </item>
    
    <item>
      <title>W32 API -&gt; .NET Framework</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-01-30-119/</link>
      <pubDate>Fri, 30 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-01-30-119/</guid>
      <description>在寫 .NET 的程式時，我最常有的疑問就是“某個 Win32 API 是否在 .NET Framework 有相對應的部分？”
意外地發現 Microsoft Win32 to Microsoft .NET Framework API Map 就是這個問題的解答。此外 C Run-Time Library Routines and .NET Framework Equivalents 也是很棒的參考。</description>
    </item>
    
    <item>
      <title>Selected Software Engineering Books</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-01-28-118/</link>
      <pubDate>Wed, 28 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-01-28-118/</guid>
      <description>Jason Elliot Robbins 推薦的一些軟體技術書籍。Jason 同時也是 ReadySET 的作者。</description>
    </item>
    
    <item>
      <title>Calling Convention</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-01-14-116/</link>
      <pubDate>Wed, 14 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-01-14-116/</guid>
      <description>我知道有點硬，但是有興趣的就看看吧。
一系列的四篇文章介紹 calling convention：
  The history of calling conventions, part 1
  The history of calling conventions, part 2
  The history of calling conventions, part 3
  The history of calling conventions, part 4: ia64
  Why do member functions need to be &amp;ldquo;static&amp;rdquo; to be used as a callback?
  What can go wrong when you mismatch the calling convention?</description>
    </item>
    
    <item>
      <title>Exception Handling Techniques</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-01-14-117/</link>
      <pubDate>Wed, 14 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-01-14-117/</guid>
      <description>13 Exceptional Exception Handling Techniques
Best Practices for Exception Handling</description>
    </item>
    
    <item>
      <title>Make More Mistakes</title>
      <link>https://blog.simplypatrick.com/posts/2004/2004-01-08-114/</link>
      <pubDate>Thu, 08 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2004/2004-01-08-114/</guid>
      <description>&amp;ldquo;不畏懼失敗&amp;quot;是所有創業家的特質，而成功的創業家更能夠從失敗中學習；然而從技術人員出身的的創業家往往會陷入『技術至上』的迷思，忘記了他們現在從事的是真實世界的生意。Eric Sink 在 MSDN 的專欄文章《Make More Mistakes》分享了他在創業過程中學到的教訓：
 Be careful about fixed-bid projects. Be careful about using bleeding-edge technologies. Small ISVs should do software and stay out of real estate. Investors don&amp;rsquo;t like low-margin business models. A market with no competition ain&amp;rsquo;t. The negative connotations of the word &amp;ldquo;middleman&amp;rdquo; are often deserved. All contracts must be reviewed by an attorney. No exceptions. Cash is supposed to flow from your customers to you, never the other way around.</description>
    </item>
    
    <item>
      <title>SCM 好書推薦</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-27-113/</link>
      <pubDate>Sat, 27 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-27-113/</guid>
      <description>講到 svn，順便推薦一本不錯的書《Software Configuration Management Patterns: Effective Teamwork, Practical Integration》，自己看 amazon.com 上面的評論吧。書中提到的 pattern 如 Integration Build, Task Level Commit, Codeline Policy, Release Line, Task Branch 等等在實務上都非常地有用。
一家軟體公司的專業與否往往看他們怎麼管理程式碼就可以看出來。身為程式員，你服務的公司做到了多少？我想絕大多數的台灣軟體公司都不及格。&amp;lt;sigh&amp;gt;</description>
    </item>
    
    <item>
      <title>Pragmatic Starter Kit</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-26-111/</link>
      <pubDate>Fri, 26 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-26-111/</guid>
      <description>驚喜地發現 Andy 跟 Dave 出新書了，不需要多考慮，掏錢買就對了。
看《Pragmatic Version Control using CVS》的目錄感覺內容有點單薄，當成入門書籍還說的過去。我個人比較期待《Pragmatic Unit Testing》及《Pragmatic Project Automation 》。
 Software development is difficult enough; if you try to build on a shaky foundation it can make development almost impossible; (which might account for the fact that about 50% of software projects fail). The Starter Kit fixes that. It&amp;rsquo;s a set of three books covering basic practices that are applicable in all software development situations.</description>
    </item>
    
    <item>
      <title>你還在用 VSS 嗎?</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-26-112/</link>
      <pubDate>Fri, 26 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-26-112/</guid>
      <description>第一次注意到 Subversion (簡稱 svn) 已經是兩年前的事了。我對於 CVS 一直是雖不滿意但能接受，只是當時的我深深地覺得 &amp;ldquo;Programmers deserve a better version control system.&amp;quot;。svn 經過兩年多的耕耘，已經實現了許多程式員渴望的功能，穩定度也相當不錯。
svn 最讓我驚訝的它絕妙的檔案系統設計，幾乎是讓你以零成本的代價進行程式碼的分支 (branching)，而同時也提供方便的檔案更名及移動的版本控制，跟 Perforce 提供的 Inter-File Branching 有異曲同工之妙。如果你也注意到 svn 的 tag 跟 branch 居然是用同一套機制時，你就不禁會佩服設計者的巧思。
今天花了點時間，參考《Subversion Book 中文版》把 subversion 0.32.1 裝在我腳邊運作著 Debian Linux 的機器上，比較討厭的是不能跟 apache 1.x 相容，需要另外安裝 apache2。Windows client 則是使用 TortoiseSVN，跟檔案總管整合起來還蠻方便的。其他的 GUI client (RapidSVN, Svn-Up, Supervision) 試用的結果都不是很成熟， 我想現在缺的就是一個類似 WinCVS 的 WinSVN 了。
真的是該準備跟你的 Visual SourceSafe 跟 CVS 說再見了。</description>
    </item>
    
    <item>
      <title>學習 - 最值得投資的事</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-22-110/</link>
      <pubDate>Mon, 22 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-22-110/</guid>
      <description>身為一位 software engineer，你有多久沒有買書了？
我尤其指跟 software development 有關的書。在軟體業已經工作了四年的我很訝異地發現：大部分的人投資在技術書籍上的錢真的少的可憐。許多人的藉口都是『原文書太貴了』、『英文看不懂或是閱讀英文速度很慢』、『網路上找方法就好了，何必買書？』、『下班回家後就已經很累了，根本不想看書』。但我認為這些都是推託的藉口：原文書太貴？也沒看到你買中文書來看；英文能力不好？那你可能不太適合這個行業；網路可以找到所有的答案？網路上的知識都太零散了，沒辦法提供完整而有組織的學習；加班太累，沒時間讀？早點回家唸書，想想該怎麼有效率的工作，你就會發現不用每天加班了。
想要在這個產業成功，『積極學習』絶對是不二法門。我強力推薦 Eric 的短文《Career Calculus》。你也可以參考 How to Keep Your Job。</description>
    </item>
    
    <item>
      <title>Browser Wars</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-21-109/</link>
      <pubDate>Sun, 21 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-21-109/</guid>
      <description>我想不是很多人知道 Internet Explorer vs Netscape Navigator 背後的這個故事《Memoirs From the Browser Wars》。
這個故事給我們的啟示是『會做不如會賣』以及『別想從 Microsoft 身上賺到錢 』。</description>
    </item>
    
    <item>
      <title>Design Guidelines for Class Library Developers</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-20-108/</link>
      <pubDate>Sat, 20 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-20-108/</guid>
      <description>Design Guidelines for Class Library Developers (.NET Framework General Reference) should be a good reference document for .NET developers.</description>
    </item>
    
    <item>
      <title>10 things Google has found to be true</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-16-107/</link>
      <pubDate>Tue, 16 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-16-107/</guid>
      <description>引用《文森咖啡館: Google十大信條》，原文出處於《Google Today》。
 Focus on the user and all else will follow. It&amp;rsquo;s best to do one thing really, really well. Fast is better than slow. Democracy on the web works. You don&amp;rsquo;t need to be at your desk to need an answer. You can make money without doing evil. There&amp;rsquo;s always more information out there. The need for information crosses all borders. You can be serious without a suit.</description>
    </item>
    
    <item>
      <title>Debugging</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-12-105/</link>
      <pubDate>Fri, 12 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-12-105/</guid>
      <description>最令程式員頭痛的莫過於各式各樣的 bug，它們也通常是讓程式員每天加班晚歸的最大兇手。程式新手通常缺乏 debug 的有效技巧，對於問題的應對方式不是瞎子摸象就是一籌莫展。然而你會發現老經驗的程式員總是能很快地把 bug 解決掉，差別就是聰明的他們會從過去的經驗累積一些經驗法則，運用這些法則往往能將 90% 的 bug 一網打盡。
《Debugging》是一本奇特的書，David Agans 教導程式員如何使用系統化及科學化的方法來對付各種 bug。整本書的重點在於 David 提出的的九大原則：
 Understand the system Make it fail Quit thinking and look Divide and conquer Change one thing at a time Keep an audit trail Check the plug Get a fresh view If you didn&amp;rsquo;t fix it, it ain&amp;rsquo;t fixed  不論你是新手或是老手，我相信你一定能在這本書中獲益良多。Don&amp;rsquo;t Debug Hard - Debug Smart.</description>
    </item>
    
    <item>
      <title>The Legend of Zelda: Wind Waker</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-09-104/</link>
      <pubDate>Tue, 09 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-09-104/</guid>
      <description>打開 GameCube 的電源，聽到薩爾達的經典配樂時，心裡不禁升起一股感動，從紅白機時代到現在的全 3D 卡通風格，薩爾達系列總是沒讓人失望過。
或許有人不習慣這一版的賽路路卡通風格，但這種新的嘗試卻也帶來許多意想不到的效果，例如林克要被大砲發射出去時的爆笑表情就只有用卡通才能表現地如此淋漓盡致，現在每次想起還是會不覺莞爾。
邊玩邊跟老婆聊天說，自己就是會著迷於遊戲的許多小細節，因為這不僅代表了製作小組的用心，也是他們對玩家的尊重。
在 DETSTAR 可以找到完整的攻略。</description>
    </item>
    
    <item>
      <title>News Aggregator in C#</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-03-102/</link>
      <pubDate>Wed, 03 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-03-102/</guid>
      <description>由於常逛的 blog 實在太多了，還是找了個 RSS reader 來用。如果你對用 C# 實作一個 RSS reader 有興趣的話，請看《Building a Desktop News Aggregator》。此外 O&amp;rsquo;Reilly 出版的《Content Syndication with RSS》也是不錯的參考。
哈哈，用 Syndirella 看呆伯特漫畫比用瀏覽器輕鬆多了。FeedDemon 也是不錯的選擇。</description>
    </item>
    
    <item>
      <title>Compiling a Compiler</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-02-100/</link>
      <pubDate>Tue, 02 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-02-100/</guid>
      <description>最近不知道為什麼又對 Programming Language 感興趣起來了，算了，看這個關於 C compiler 的有趣故事吧：《Compiling a Compiler》。</description>
    </item>
    
    <item>
      <title>Good software, like wine, takes time.</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-12-02-101/</link>
      <pubDate>Tue, 02 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-12-02-101/</guid>
      <description>我喜歡 Joel 的這篇文章《Good Software Takes Ten Years. Get Used To it.》。
直覺地想，programmer 的生產力應該是隨著軟體技術的發展而增加，因為有了新的工具及方法的輔助；然而事實是如此嗎？
程序員的生產力似乎並沒有大幅地進步〈我沒有任何資料可以印證這個看法，純粹就我個人的觀察〉， 我認為主要的原因是因為要開發的軟體也同時變複雜了，如此一消一長，軟體業還是停留在需要大量腦力的狀態。 就拿最簡單的 &amp;ldquo;Hello World&amp;rdquo; 為例，DOS 版、 Windows API 版本、MFC 版本，一個比一個複雜，越需要更多的背景知識來確保程式運作正常。
那最新的 .NET 就能改善這情況嗎？我並不對此感到樂觀。那麼 programmer 該怎麼辦呢？ 我個人認為還是要務實、不好高騖遠、必須對底層的運作機制有一定程度的了解、多方面地充實自己的知識。
To be a good programmer, like wine, takes time.</description>
    </item>
    
    <item>
      <title>Beyond Chaos</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-11-24-95/</link>
      <pubDate>Mon, 24 Nov 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-11-24-95/</guid>
      <description>《Beyond Chaos: The Expert Edge in Managing Software Development》
是我最近在 Amazon 買的一本二手書，請在美國出差的同事幫我帶回來。價錢 $4.14 加上運費 $3.49，折合台幣才兩百五十元，實在是非常划算。對於常買原文書的我，這樣的方式倒是能幫我省下不少錢。
喜歡買原文技術書籍的人，可以試試看 AddALL 或是 Google 新的比價服務 Froogle。</description>
    </item>
    
    <item>
      <title>Programming Embedded Systems</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-11-24-94/</link>
      <pubDate>Mon, 24 Nov 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-11-24-94/</guid>
      <description>最近剛讀完《Programming Embedded Systems in C and C++》，讓完全不懂 embedded system 的我很快地就對嵌入式系統有了一定程度的了解。推薦給任何對 embedded system programming 有興趣的人。</description>
    </item>
    
    <item>
      <title>數位的花園</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-11-21-92/</link>
      <pubDate>Fri, 21 Nov 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-11-21-92/</guid>
      <description>第一次看到這方面的話題：《Turning Over Software》討論如何順利地移交你的程式碼給其他人接手。
我喜歡作者把程式比喻成需要細心灌溉維護的花園：
 Programs are not static creations like buildings, they are more like gardens. They have an initial plan and form and implementation, but they require ongoing care and maintenance, and enhancements. If you don&amp;rsquo;t turn your code over to someone else, eventually you will spend all your time caring for your existing code, and you&amp;rsquo;ll be trapped.
 而這句話我舉雙手贊成： &amp;ldquo;In order for programmers to be productive and happy, they must feel a sense of ownership.</description>
    </item>
    
    <item>
      <title>程式員救星</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-11-21-93/</link>
      <pubDate>Fri, 21 Nov 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-11-21-93/</guid>
      <description>程式員都不喜歡寫 spec，因為寫 spec 比寫程式難多了。儘管如此，《The Lead Bullet - Writing Specs》告訴我們：好的 spec 是過勞的程式員值得依賴的救星。</description>
    </item>
    
    <item>
      <title>The Two Switches</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-11-20-91/</link>
      <pubDate>Thu, 20 Nov 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-11-20-91/</guid>
      <description>一個有趣的易智題目： The Two Switches，在 Moving Mount Fuji 可以找到更多類似的題目。喜歡出這些奇奇怪怪的題目來測試應徵者的公司中，最有名的就是 Microsoft 了，有興趣的可以看 Microsoft Interview Questions。
要進 MS 似乎不是件容易的事。 :-)</description>
    </item>
    
    <item>
      <title>Microsoft and G5</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-11-04-86/</link>
      <pubDate>Tue, 04 Nov 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-11-04-86/</guid>
      <description>Even Microsoft wants G5s
因為 blog 而丟了工作？
我想 Michael 也沒想到拍一張照片會把這新聞炒的這麼大。正所謂樹大招風，Microsoft 開除了這名員工，反而引來更多的人來關注這件事。
雖然我認為 Microsoft 以違反公司安全為由開除員工有他的道理，只是更輕鬆地處理這件事不是很好？畢竟 Microsoft 有太多的負面消息了，還是他們不在乎多這一則？</description>
    </item>
    
    <item>
      <title>Have you watched fight club?</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-10-21-83/</link>
      <pubDate>Tue, 21 Oct 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-10-21-83/</guid>
      <description>非常棒的一個討論串：Software Defects - Do Late Bugs Really Cost More?，討論一個軟體人一定要有的觀念：『Bug 修正的成本隨時間而遞增』。</description>
    </item>
    
    <item>
      <title>Software Development</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-10-18-82/</link>
      <pubDate>Sat, 18 Oct 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-10-18-82/</guid>
      <description>Steve McConnell, &amp;ldquo;Professional Software Development&amp;rdquo;, chapter 4 - Software Engineering, Not Computer Science
 During software design, I&amp;rsquo;m an architect. When I&amp;rsquo;m designing the user interface, I&amp;rsquo;m an artist. During construction, I&amp;rsquo;m a craftsman. And during unit testing, I&amp;rsquo;m one mean son of a bitch!
 </description>
    </item>
    
    <item>
      <title>Flash Clock</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-10-10-81/</link>
      <pubDate>Fri, 10 Oct 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-10-10-81/</guid>
      <description>在網路上亂逛找到的，這個 Flash Clock 也很酷: INDUSTORIOUS CLOCK ||| MONO*CRAFTS。
Flash 的多才多藝讓我聯想到 Metaprogramming 這個字，對我而言，軟體就是要夠“軟”才能稱的上軟體，也就是至少要符合 flexible, configurable, 及 extensible 這三個特性。軟體 (software) 這名字的由來是因為你可以輕而易舉地改變它，只要敲敲鍵盤、更改原始碼，重新編譯﹝甚至不用﹞就可完成想要的更改；
然而真正的事實是『軟體一點也不軟』，你需要付出相當的代價 - 細心的分析及設計，來讓它變軟。然而決定『那個部分要軟、那個部分要硬』就是一們很大的學問，因為太軟的軟體往往過於複雜，而太硬的軟體又缺乏實用性。</description>
    </item>
    
    <item>
      <title>MIT OpenCourseWare</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-10-04-79/</link>
      <pubDate>Sat, 04 Oct 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-10-04-79/</guid>
      <description>MIT OpenCourseWare 是麻省理工學院的公開線上課程，目前總共有五百門左右的課程開放，更重要的是這些課程完成是免費的，任何人都可以上網來自行進修。我對於這種『知識共享』的理念感到非常地敬佩，逛著上面的課程，不禁回想起以前在學校追求知識的那種熱情。你或許沒機會去 MIT 親臨教授上課的風采，但那並不能停止你對於學習的渴望，畢竟生於現代的我們有網際網路，不是嗎？
我打算利用閒暇的時間來研讀 6.170 Laboratory in Software Engineering, Fall 2001 這們課程，有一些心得再與大家分享。</description>
    </item>
    
    <item>
      <title>Joel 的新辦公室</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-30-78/</link>
      <pubDate>Tue, 30 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-30-78/</guid>
      <description>Joel 的新辦公室看起來真是讚，programmer 就該有這樣的工作空間。Philip Greenspun 的《Managing Software Engineers》討論如何營照一個比家還棒的工作環境，看完後我的感想是這篇文章應該改名叫《如何讓 programmer 不想回家》。
何時老闆們才會了解：
Software engineering is different.  </description>
    </item>
    
    <item>
      <title>What does the customer want?</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-30-77/</link>
      <pubDate>Tue, 30 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-30-77/</guid>
      <description>是的，顧客有時連他們想要什麼都說不清楚。
p166, Rapid Development, Steve McConnell
 It is difficult to know whether you can build the product that the customer wants in the desired time frame until you have a detailed understanding of what the customer wants.
 </description>
    </item>
    
    <item>
      <title>Aspect-Oriented Programming, Part II</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-29-76/</link>
      <pubDate>Mon, 29 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-29-76/</guid>
      <description>IBM、JBoss聯手Java新功能
 IBM與開放原始碼Java軟體商JBoss有意進行一項Java標準化計劃，意在反制日益受到歡迎的微軟C#語言。
兩家公司目前獨立投資於一項軟體開發技術稱為AOP(aspect-oriented programming)，可加速應用開發速度，且更具彈性，同時也更不容易出錯。
JBoss企業開發與策略副總裁Bob Bickel透露，現在兩家公司則有意把AOP變成Java的標準功能。
 看來 AOP 將成為 Java 與 C# 互較長短的新戰場。Java 方面已經有頗為成熟的 AspectJ，而 C# 方面則是積極發展中。就我看來，要普及 AOP 並讓程式員了解並使用這個嶄新的概念，整合開發環境的支援扮演了一個重要的角色；在這方面，似乎又是 Java 領先 (參考 AJDT in Eclipse)。
對 AOP 有興趣的可以參考葉秉哲在 JavaTwo 2003 研討會的演講《AspectJ: Beyond OOP》。</description>
    </item>
    
    <item>
      <title>SSCLI</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-16-74/</link>
      <pubDate>Tue, 16 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-16-74/</guid>
      <description>《Extending SSCLI》非常酷的一份教學，告訴你如何擴充 CLI 的功能。
SSCLI (Shared Source Common Language Infrestrcuture) 是 Microsoft 代號為 Rotor 的一個計畫，目的是公開 CLI 的原始碼，讓更多的人參與 .NET 的開發與研究。微軟的這些傢伙真的非常聰明，曉得就是會有許多無聊的人(例如我)喜歡去探究系統內部的運作，當這些人對整個系統熟悉了自然就會成為 .NET 技術的支持者。不可否認地，閱讀 SSCLI 的原始碼真的有讓人如入寶庫的感覺，正如同這份教學裡的一段話:
A runtime such as SSCLI is a neat example of knowledge repository of the past 30 years of computer science.
或許 computer science 30 年的精華是有點誇張，但你絕對可以從中學到一點東西。然而學習最快的方法就是親自動手去做囉，這份教學藉由增加一個新的 IL instruction 來讓你對整個 CLI 的架構有一個大致的了解，值得一試!
如果你對 SSCLI 有興趣，歡迎一起來討論。Jason Whittington 在 MSDN 的這篇文章《Rotor: Shared Source CLI Provides Source Code for a FreeBSD Implementation of .</description>
    </item>
    
    <item>
      <title>Leading a Software Development Team</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-15-73/</link>
      <pubDate>Mon, 15 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-15-73/</guid>
      <description>我非常喜歡 Richard Whitehead 的這本《Leading a Software Development Team》，書中教導如何有效地管理一個軟體團隊，內容相當地有趣及易懂。在軟體業界，許多人往往是因為優異的技術能力被提升為主管，完全沒有管理經驗的人往往會適應不良，便萌生“還是單純地搞技術比較輕鬆 ”這種想法，而這本書就是這些菜鳥主管的救星啦。整本書以一問一答的方式來組織，瞧瞧下列的這幾個是不是一直困擾你很久的問題：
   I&amp;rsquo;ve just been made team leader of a new project. Where do I start?    I have to interview a job applicant. How do I go about it?    How do I earn the respect of my team?    How can I get a good job done when our procedures are so bad?</description>
    </item>
    
    <item>
      <title>Multithreading in Windows Froms</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-08-71/</link>
      <pubDate>Mon, 08 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-08-71/</guid>
      <description>Four interesting articles about multitheading programming in Windows Form by Chris Sells and Ian Griffiths:
 Safe, Simple Multithreading in Windows Forms, Part 1, Chris Sells Safe, Simple Multithreading in Windows Forms, Part 2, Chris Sells Safe, Simple Multithreading in Windows Forms, Part 3, Chris Sells Give Your .NET-based Application a Fast and Responsive UI with Multiple Threads, Ian Griffiths  You should read this article if you don&amp;rsquo;t know what delegate is: .</description>
    </item>
    
    <item>
      <title>Under Pressure and On Time</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-09-07-70/</link>
      <pubDate>Sun, 07 Sep 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-09-07-70/</guid>
      <description>最近逛書店時很驚訝地發現這本書的中文版《e世紀軟體開發術》(光看這書名我實在不大想買)，由於之前曾經在 amazon.com 看過它的簡介與評價，便順手買了下來。
Numega 應該是大家耳熟能詳的一家公司，Windows Programming 領域中鼎鼎有名的 Matt Pietrek 及 John Robbins 都曾從事於該公司。Ed Sullivan 在這本書中所描述狀況，其實正是所有草創初期的軟體公司一定會遇到的問題，然而並不是每一家公司克服這些困難而存活下來，其中最大的關鍵點就是『持續地改進軟體開發的程序』。我常訝異於許多軟體公司居然能夠在沒有 source code control system 的環境下工作，難道他們不知道如何讓自己的工作更有效率嗎？
Ed 在本書中提出了許多軟體開發的關鍵問題與答案，然而你不應該對 Ed 的標準答案期待太多，因為他的方法並不一定適用於你 (Ed 的答案也並不十分詳盡而完善)，正因為軟體開發沒有所謂的萬靈丹。然而 Ed 已經領你進門了，真正關心自己的工作並且要去思考的不就是你自己嗎?</description>
    </item>
    
    <item>
      <title>We will not ship shit</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-27-68/</link>
      <pubDate>Sun, 27 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-27-68/</guid>
      <description>We will not ship shit ，乍看之下只是一個自命不凡的激情口號，不是嗎？
軟體是用人的腦子設計出來的，而所謂的設計本就牽涉許多的考量與取捨 (trade-offs)。 身為軟體設計者的我們必須常常面對『現實』與『理想』的抉擇，『現實』指的是在短時間內完成產品， 而『理想』則為產品的高品質。這兩者是否如魚與熊掌不可兼得？ 答案事實上已經公認為否定的，並且大家相信『對於高品質的要求甚至會縮短軟體開發所需的時程』。 因此所謂的『理想』並不只基於對軟體開發的熱情及對專業的自尊，也是為更實際的考量。 要看一個人是不是一流的程式員，就是看他對於自己作品的要求高不高。
 &amp;ldquo;Think twice before you make shit.&amp;rdquo;
 </description>
    </item>
    
    <item>
      <title>Iceberg Sneak-Ins</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-07-67/</link>
      <pubDate>Mon, 07 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-07-67/</guid>
      <description>Everything looks easier than it really is. New features are like icebergs. Most of the effort is invisible, hiding below the water, waiting to sink your project. The actual implementation effort is the visible part sticking above the water.
 在《Iceberg Sneak-Ins》這篇文章，Eric 討論了一個軟體界最常見的問題：feature creep。Feature creep 指的是『程式的規格在開發的過程中持續被更動』，其中包含了『變更』及『新增』功能。Eric 特別針對『臨時增加的小功能』提出了一些實用的建議。
另一篇文章《Killing Feature Creep Without Ever Saying No》也值得參考。</description>
    </item>
    
    <item>
      <title>developer vs. programmer, part II</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-05-65/</link>
      <pubDate>Sat, 05 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-05-65/</guid>
      <description>我在之前的一篇文章中提到了 Developer 跟 Programmer 的差別，而 Eric 的文章《Small ISVs: You need Developers, not Programmers》把這一點講的更清楚了。
Developers 可以比喻為軟體設計的『通才』，而 Programmers 則是軟體設計的『專才』。正如其他一般的行業，通才是比較吃得開的，因為他們的彈性比起專才大的多，也較受企業的歡迎。然而現實上，一般的大學教育還是以訓練專才為主，也就是寫程式的能力。在學校，沒有人教你如何寫 spec、如何管理 software configuration、如何寫程式文件、如何測試及偵錯程式等等必需的技能，這些東西往往是到業界來才邊做邊學的。事實上，別小看這些看起來很簡單的事情，如果你能比同儕更快學會這些事或是做的更好，你很有可能就會得到上司的賞識而晉升。
總之，別侷限於自己的專精領域，看的更廣會讓你做的更好。</description>
    </item>
    
    <item>
      <title>ISV</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-05-66/</link>
      <pubDate>Sat, 05 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-05-66/</guid>
      <description>看完《What is a Small ISV?》之後才知道，原來 VA Software 在 NASDAQ 的股票代號是 LNUX，不過這是題外話。Eric 的重點是軟體供應商 (ISV)；ISV 通常的特色就是『小而美』並且在市場上有很明確的定位。怎麼樣才算是一個『小而美』的軟體公司？這問題似乎沒有一個固定的答案，不過我們可以從一些已經是現存的小公司來尋找一些蛛絲馬跡，例如 Perforce 就是我認為符合『小而美』原則的一家軟體公司。
Perforce 把公司的唯一產品 Perforce SCM 定位成 &amp;ldquo;the fast Software Configuration Management System&amp;rdquo;，如果你用過這套產品，你就會知道“他們真正了解客戶需要什麼，而且提出了相當優秀的解決方案”。小公司的經營並不允許做太多錯誤的決策，因此我想 Perforce 秉持著『選擇正確的事情，並把它做到最好』的策略就是其成功的最重要因素。</description>
    </item>
    
    <item>
      <title>::Manageability::</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-04-63/</link>
      <pubDate>Fri, 04 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-04-63/</guid>
      <description>發現了一個很棒的 weblog: ::Manageability::，在那裡可以看到許多關於軟體開發的有趣討論〈大多數的文章都是有關 Java 的〉。
其中的一則文章《Thinking Styles and Software Engineering 》提到了一個有趣的心理測驗，可以用來測試你或是他人偏向那一種思考模式，也許值得應用在面試新人上。</description>
    </item>
    
    <item>
      <title>Eric.Weblog()</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-04-64/</link>
      <pubDate>Fri, 04 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-04-64/</guid>
      <description>Eric.Weblog() 的內容正如它的副標題《Thoughts about .NET, version control, and business from yet another person who invented the Internet》，不過 another person who invented the Internet 指的是？</description>
    </item>
    
    <item>
      <title>Refactoring &amp; Patterns</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-03-62/</link>
      <pubDate>Thu, 03 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-03-62/</guid>
      <description>《Refactoring To Patterns》提供了許多『經由 refactoring 的手法來改善物件導向程式架構的方法』，我個人認為相當地具有實用價值，值得一看。</description>
    </item>
    
    <item>
      <title>Aspect-Oriented Programming</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-07-01-59/</link>
      <pubDate>Tue, 01 Jul 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-07-01-59/</guid>
      <description>「Aspect-Oriented Programming」是繼OOP之後的新程式設計思維， 大陸的譯名是「面向方面」(有夠饒口的)。
aspect 在字典裡的定義是:
 A distinct feature or element in a problem A characteristic to be considered &amp;hellip;  我想 1. 跟 2. 的解釋是比較貼近 AOP 中 Aspect 的定義。
我個人比較有興趣的是 AOP 與 C# 的結合，在 Google 可以找到一些相關的資訊。在這個領域將會產生許多有趣的東西，我想。
這裡是一些介紹 AOP 的入門文章：
 Extract Aspect Refactoring ? I want my AOP! The AspectJ Programming Guide Improve modularity with aspect-oriented programming  </description>
    </item>
    
    <item>
      <title>How to Keep Your Job</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-30-58/</link>
      <pubDate>Mon, 30 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-30-58/</guid>
      <description>面對中國大陸廉價人力的競爭，台灣的軟體人才該如何因應？ Dave Thomas 的《How to Keep Your Job》提供了一些答案，畢竟美國也面臨類似的問題。
在這個變化快速的時代，想找一份鐵飯碗是不可能的事了，這篇文章值得一看。</description>
    </item>
    
    <item>
      <title>履歷</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-24-56/</link>
      <pubDate>Tue, 24 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-24-56/</guid>
      <description>不管在哪一個行業，履歷是應徵者給人的第一印象，好的履歷更能讓你在眾多應徵者中脫穎而出，但似乎許多人都不懂得如何寫出讓未來的面試官印象深刻的履歷。《Applying for a Job II: Resumes》提供了一些方法教大家如何寫一份好的履歷〈尤其是軟體業〉，我認為內容相當中肯。
我本身因為工作的關係，有機會看到一些人力網站送來的履歷。我發現大多數人的最大問題就是內容沒有重點並且太過於平舖直述，無法突顯『為什麼你適合這份工作？』這個最重要的訊息。想找一份好工作，先花點時間在你的履歷上吧。</description>
    </item>
    
    <item>
      <title>辦公室規劃</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-20-55/</link>
      <pubDate>Fri, 20 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-20-55/</guid>
      <description>Fog Creek Software 的搬家故事
看來是個很溫馨的小公司。我想很多人加班到深夜〈例如我〉就是因為待在充滿人造燈光的室內，而缺乏陽光的滋潤，也打亂了『日出而做，日落而息』的生物規律。
我只要一想到『靠窗的工作隔間』，就會有一種幸福的感覺，只是不知道何時才能實現這個小小的願望…</description>
    </item>
    
    <item>
      <title>The Life of a Project - Issue Tracking</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-18-53/</link>
      <pubDate>Wed, 18 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-18-53/</guid>
      <description>朋友轉寄給我的一篇文章《The Life of a Project - Issue Tracking: Day 1 》。
我想重點在於作者如何把一個構想 (idea) 經由分析思考而轉化成具體的需求 (requirements)。
Software Requirements Analysis and Management 其實是門很大的學問，有興趣的人我推薦 Karl E. Wiegers 的《Software Requirements》當作入門書。在眾多軟體需求管理的書籍中，它至少讓我讀起來比較不會昏昏欲睡。</description>
    </item>
    
    <item>
      <title>M.C. Escher</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-17-52/</link>
      <pubDate>Tue, 17 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-17-52/</guid>
      <description>很驚訝地發現今天 Google 的 Logo 是模仿 M.C. Escher 的名畫『互繪的雙手』。 在 Google Holiday Logos 可以找到所有的 Logo。</description>
    </item>
    
    <item>
      <title>A Community of Software Thinkers</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-11-49/</link>
      <pubDate>Wed, 11 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-11-49/</guid>
      <description>Artima Weblogs 是一個以討論軟體設計為主的 weblog，其中有許多話題正是我最近感到興趣的:
 《Refactoring To Aspects》討論的是 Aspect-Oriented Programming 《One per Pixel》討論軟體開發人員的生產力問題 《Are Programmers People? And If So, What to Do About It?》討論的似乎也很有趣  </description>
    </item>
    
    <item>
      <title>Interview</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-11-50/</link>
      <pubDate>Wed, 11 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-11-50/</guid>
      <description>《How to Interview a Programmer》如果你的公司要找好的 programmer 的話，可以參考這篇文章看看。如果我是面試官的話，下列可能是我的問題：
 請列出最近讀過的技術書籍，並陳述你的讀後心得。 請陳述你自認為精通的技術，並回答我所提出的疑問。 請陳述對某項技術的觀點或分析不同技術的優缺點。 請展示任何以前所寫過的程式碼來證明你的程式設計能力。 請批評這段程式碼，並提出任何改進的方法。  或許你也想知道 Microsoft 如何面試新人及另一個有趣的面試故事。</description>
    </item>
    
    <item>
      <title>Manifesto for Agile Software Development</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-11-51/</link>
      <pubDate>Wed, 11 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-11-51/</guid>
      <description>Agile Manifesto 代表的是 Agile Software Development 的核心精神。
 We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:
   Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan    That is, while there is value in the items on the right, we value the items on the left more.</description>
    </item>
    
    <item>
      <title>Hardware breakpoints</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-10-46/</link>
      <pubDate>Tue, 10 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-10-46/</guid>
      <description>嗯，VC++ 的確有提供 data breakpoint，但是使用起來卻不大方便，原因是你必須知道資料的位址然後填入例如 *((DWORD*)0x12345678) 的表示式才行。
現在，試試 Mike Morearty 的 CBreakpoint，你可以這樣做：
DWORD x = 1; CBreakpoint bp; bp.Set(&amp;amp;x, sizeof(x), CBreakpoint::Write); 相當地酷！</description>
    </item>
    
    <item>
      <title>ILDASM</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-10-47/</link>
      <pubDate>Tue, 10 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-10-47/</guid>
      <description>ILDASM is Your New Best Friend John Robbins 在 MSDN 上簡介 MSIL (Microsoft Intermediate Language) 及 CLR 的基本概念，想要成為 .Net 的專家，對於 MSIL 必然要下一番功夫。
 Knowing how things work at the lowest level does make it easier to see the big picture.
 </description>
    </item>
    
    <item>
      <title>Winamp author</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-10-48/</link>
      <pubDate>Tue, 10 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-10-48/</guid>
      <description> For me, coding is a form of self-expression. It&amp;rsquo;s probably the form I&amp;rsquo;m most effective at.
&amp;ndash; Justin Frankel
 </description>
    </item>
    
    <item>
      <title>developer vs. programmer</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-09-45/</link>
      <pubDate>Mon, 09 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-09-45/</guid>
      <description>Being a good developer in BCB requires that you remember you are a developer rather than a programmer - which is to say that you have responsibility for much more than the excellence of developed code. You are also responsible for the excellence of the design of the software and databases, the user interface, and for the reusability and maintainability of the result. And of course, an understanding and appreciation of the business context of your development effort is essential.</description>
    </item>
    
    <item>
      <title>Assertions and Error Handling</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-08-43/</link>
      <pubDate>Sun, 08 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-08-43/</guid>
      <description>Andrei 在 C++ User Journal 發表了幾篇關於 C++ error handling 的文章，蠻有趣的，也解決了一些困擾我很久的問題。
 Assertions Enforcements Change the Way You Write Exception-Safe Code — Forever  關於 Exception，大部分的人已經能夠接受其觀念，並且也被許多主流的的程式語言所支援。然而 Exception 帶來的似乎不是期待中的天堂，而是更多的困惑。也就是 Exception 解決了舊的問題，卻也帶來了新的挑戰。程序員慢慢地了解『撰寫 exception-safe 的程式碼卻不容易』，而解決的方法往往需要去使用一些非內建的機制，如 Andrei 所提到的方法。例如 C++ 中缺乏 finally 的支援就使我覺得非常困擾。
我想程式語言除了支援 Exception 外，還需再多提供一些錯誤處理的支援，像我就蠻喜歡 C# 中的 using (…) {}。</description>
    </item>
    
    <item>
      <title>悲哀的新辦公室</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-06-41/</link>
      <pubDate>Fri, 06 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-06-41/</guid>
      <description>公司新辦公室的規劃果然如我所料，除了大老闆的位置外，沒有一個位置靠窗。除此之外，幾乎每個座位都緊鄰主要的走道。It really really sucks.
問題是員工都習慣了逆來順受嗎？或是大家覺得這一點也不重要？
不，一個好的工作環境對於軟體開發人員有著極大的影響。好的工作環境不一定會讓工作效率變好，但壞的工作環境絕對會讓工作效率與品質變差。為什麼偏偏老闆們都不懂得這道理呢？我想，他們太忙了吧以至於連《Rapid Development》或 《Peopleware》都沒唸過。也或許他們唸過，但他們當這些作者都在放屁吧。 搬到新辦公室應該是件值得高興的事，但為什麼我就是快樂不起來呢？</description>
    </item>
    
    <item>
      <title>Language of the Year</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-04-38/</link>
      <pubDate>Wed, 04 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-04-38/</guid>
      <description>“Learn at least one new [programming] language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut.”
  — The Pragmatic Programmer
 檢視一下你現在手頭熟悉的技術，你是否很久都沒學什麼新東西了？所謂『老狗變不出新花樣』，該接觸一些新事物來充實一下自己了。採用新的流程、新的思考方式、新的設計方式、或是新的程式語言都可幫你提昇自己思考的廣度。別懼怕『樣樣通，樣樣鬆』的批評，學習新的事物反而可以提昇自己專精領域的深度。 準備好了嗎？一起參加 Language of the Year 來學習 Haskell 吧。</description>
    </item>
    
    <item>
      <title>選擇與天賦</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-06-04-39/</link>
      <pubDate>Wed, 04 Jun 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-06-04-39/</guid>
      <description> It is our choices that show what we truly are, far more than our abilities.
  我們的選擇，遠比我們的天賦才能，更能顯示出我們的真貌。
  &amp;ndash; 鄧不利多 《哈利波特2 - 消失的密室》
 </description>
    </item>
    
    <item>
      <title>Exceptional C&#43;&#43;</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-22-35/</link>
      <pubDate>Thu, 22 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-22-35/</guid>
      <description>C++ 的信徒應該對 Herb Sutter 不感到陌生。草藥兄最常發表技術文章的地方是C/C++ Users Journal 的 C++ 專欄。不才也有一本他寫的 Exceptional C++，雖是薄薄的一本卻是字字珠璣，沒有多餘的廢話。任何自認為 C++ 的專家都應該來挑戰看看書中所提的問題。每次我誤入書中所設的的陷阱時，彷彿都能聽見 Herb 在耳邊說 &amp;ldquo;gotcha&amp;quot;。</description>
    </item>
    
    <item>
      <title>Cleaning up code</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-21-33/</link>
      <pubDate>Wed, 21 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-21-33/</guid>
      <description>&amp;lsquo;Cleaning up code&amp;rsquo; is a terrible thing. Redesigning WORKING code into different WORKING code (also known as refactoring) is terrible. The reason is that once you touch WORKING code, it becomes NON-WORKING code, and the changes you make (once you get it working again) will never be known. It&amp;rsquo;s like Programmer masturbation, it might make you feel good, but no one will probably know you did it.
  &amp;ndash; Paul Tyma</description>
    </item>
    
    <item>
      <title>C# and Beautiful Code</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-20-31/</link>
      <pubDate>Tue, 20 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-20-31/</guid>
      <description>O’Reilly Network: Beautiful Code C++ 或是 Java 的語法的確是 boring 了一點，但就可讀性而言的確可以讓 programmer 把程式寫得中規中矩一點。
Perl 提供了許多 syntactic sugar，但讀起別人寫的 Perl 程式可就不是那麼輕鬆…
我想這傢伙是不是在暗指 C# 比 Java 寫起來漂亮些，因為這段程式用 C# 來表示就相當地簡明易懂：
foreach (User user in dao.getUsers()) { // do something with user } </description>
    </item>
    
    <item>
      <title>To Speak Perl</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-17-29/</link>
      <pubDate>Sat, 17 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-17-29/</guid>
      <description>似乎是最近才對 Perl 開了竅，不會覺得寫 Perl Script 是件很彆扭的事。也許是自己拋棄了以前對它的成見，願意用異於平常的觀點去了解其背後的設計哲學。
希望有一天也能做到 &amp;ldquo;I don&amp;rsquo;t write Perl, I speak it.&amp;rdquo; 的境界。</description>
    </item>
    
    <item>
      <title>Programmer Dvorak Keyboard Layout</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-14-26/</link>
      <pubDate>Wed, 14 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-14-26/</guid>
      <description>常常寫 C++ 的你是否有想過『為什麼 { 是 shift + ] ?』，畢竟 { 比 [ 更常被用到不是嗎？如果你是 LISP 的愛好者， 我更可以了解你對於要輸入許多 () 的無奈。
Programmer Dvorak 似乎是 programmer 的救星。只是在這個被 QWERTY 鍵盤佔據的世界中，當個使用 Dvorak 鍵盤的異類是很辛苦的。</description>
    </item>
    
    <item>
      <title>All I Really Need to Know I Learned in Kindergarten</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-12-23/</link>
      <pubDate>Mon, 12 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-12-23/</guid>
      <description>{% blockquote %} All I Really Need to Know I Learned in Kindergarten By Robert Fulghum (Fulghum 1988)
Share everything. Play fair. Don’t hit people. Put things back where you found them. Clean up your own mess. Don’t take things that aren’t yours. Say you’re sorry when you hurt somebody. Wash your hands before you eat. Flush. Warm cookies and cold milk are good for you. Live a balanced life – learn some and think some and draw and paint and sing and dance and play and work every day some.</description>
    </item>
    
    <item>
      <title>Pair Programming</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-12-24/</link>
      <pubDate>Mon, 12 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-12-24/</guid>
      <description>那麼 Robert Fulghum 的《All I Really Need to Know I Learned in Kindergarten 》怎麼又會跟 Extreme Programming 所提倡的 Pair Programming 扯上關係呢？ 看看這篇曾經刊登於 Communications of the ACM 的文章《All I Really Need to Know about Pair Programming I Learned In Kindergarten》吧。
  Pair programming is a style of programming in which two programmers work side-by-side at one computer, continuously collaborating on the same design, algorithm, code or test. As discussed below, use of this practice has been demonstrated to improve productivity and quality of software products.</description>
    </item>
    
    <item>
      <title>Software Process Management</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-08-21/</link>
      <pubDate>Thu, 08 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-08-21/</guid>
      <description>在 Process Impact – Software Process Improvement Consulting and Education 可以找到許多 Karl Wiegers 的文章，對於 Software Process Management 有興趣的人值得一看。</description>
    </item>
    
    <item>
      <title>Borland and Microsoft</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-07-19/</link>
      <pubDate>Wed, 07 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-07-19/</guid>
      <description>由李維所撰寫的《和Borland的緣由》，相當地精采。因為整個故事發生的過程正是自己學電腦的萌芽期，因此讀起來特別地有趣。印象最深刻的是當時 Turbo C++ 必須用兩張 3 1/2 的碟片來編譯 C++ 程式；比照起今日的開發環境真是有天壤之別。 今天的『不可能』轉瞬間就會化為『可能』，畢竟軟體是由人的想像力所創造出來的，不是嗎？</description>
    </item>
    
    <item>
      <title>John Warnock</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-07-18/</link>
      <pubDate>Wed, 07 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-07-18/</guid>
      <description>應該是大家耳熟能詳的軟體公司，不過其創辦人似乎沒有像其他大公司的赫赫有名，就讓蔣濤告訴你Adobe 與 John Warnock 的故事。另有繁體中文版。</description>
    </item>
    
    <item>
      <title>~ ! @ # $ % ^ &amp; * 到底要怎麼唸?</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-07-20/</link>
      <pubDate>Wed, 07 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-07-20/</guid>
      <description>有時跟老外交談時會不曉得這些符號怎麼唸，就查查這篇文章《pronunciation guide for unix》吧。</description>
    </item>
    
    <item>
      <title>Pragmatic Programmers</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-05-14/</link>
      <pubDate>Mon, 05 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-05-14/</guid>
      <description>Dave Thomas 跟 Andy Hunt 在 IEEE Software 的專欄是我最近最喜歡看的文章。幽默簡潔而務實是我對他們文章的最大印象，喜歡談大道理的作者一向不是我的偏好，這兩位就剛剛合我的胃口。是除了 Demarco &amp;amp; Lister 外我最喜歡的一對作者。</description>
    </item>
    
    <item>
      <title>Joel on Software</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-04-13/</link>
      <pubDate>Sun, 04 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-04-13/</guid>
      <description>很酷的一個網站，Joel 很直接地點出許多於軟體業存在以久的蠢事。你認為軟體業是高科技產業嗎？錯，大部分的公司還是漫無章法地進行軟體開發，把軟體開發人員當成廉價勞工使用。我想你應該聽聽 Joel 怎麼說，其中最精采的幾篇文章已經翻成中文，值得你細細體會，並絕對能博你一笑。</description>
    </item>
    
    <item>
      <title>Google</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-03-12/</link>
      <pubDate>Sat, 03 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-03-12/</guid>
      <description>讓 Google 找到你以及讓 Google 別再煩你。</description>
    </item>
    
    <item>
      <title>Gödel, Escher, Bach</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-02-10/</link>
      <pubDate>Fri, 02 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-02-10/</guid>
      <description>或許是今天太閒了吧，心血來潮地把 Douglas Hofstadter 的《Gödel, Escher, Bach - An Eternal Golden Braid》拿出來翻了一遍。
如果要硬掰一個理由解釋為什麼買這本書以來從沒能夠好好地把它讀懂，我只能說 Escher 的版畫太迷人了。往往書一拿起來，就有一股衝動想把所有的畫看一遍。畢竟我對巴哈的音樂不熟悉，歌德爾的數學又太難懂了… :-)
Escher 的數學藝術 Google 的相關連結</description>
    </item>
    
    <item>
      <title>Virus</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-02-11/</link>
      <pubDate>Fri, 02 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-02-11/</guid>
      <description>查了一下 access log，發現一些有趣的東西。上網查了一下，原來是頂頂有名的 Nimda 跟 Code Red。看來即使已經過了流行高峰期，被感染的電腦還是蠻多的。
61.150.x.x - &amp;quot;GET /scripts/root.exe?/c+dir HTTP/1.0&amp;quot; 404 277 61.150.x.x - &amp;quot;GET /MSADC/root.exe?/c+dir HTTP/1.0&amp;quot; 404 275 61.150.x.x - &amp;quot;GET /c/winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 285 61.150.x.x - &amp;quot;GET /d/winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 285 61.150.x.x - &amp;quot;GET /scripts/..%255c../winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 299 61.150.x.x - &amp;quot;GET /_vti_bin/..%255c../..%255c../..%255c../winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 316 61.150.x.x - &amp;quot;GET /_mem_bin/..%255c../..%255c../..%255c../winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 316 61.150.x.x - &amp;quot;GET /msadc/..%255c../..%255c../..%255c/..%c1%1c../..%c1%1c../..%c1%1c../winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 332 61.150.x.x - &amp;quot;GET /scripts/..%c1%1c../winnt/system32/cmd.exe?/c+dir HTTP/1.0&amp;quot; 404 298 61.</description>
    </item>
    
    <item>
      <title>Applied Microsoft .Net framework programming</title>
      <link>https://blog.simplypatrick.com/posts/2003/2003-05-01-9/</link>
      <pubDate>Thu, 01 May 2003 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simplypatrick.com/posts/2003/2003-05-01-9/</guid>
      <description>衝著 Jeffrey Richter 的名字，我還是買了這本由文魁出版的中譯本。看了三章後，我後悔了。
這本書被翻的實在是慘不忍睹，不僅文義謬誤而且錯字連篇，專有名詞也翻得非常饒口，你能想像什麼是『資料名單中繼資料表格』嗎？最經典的例子是原文的：
『You Can’t Have Too Many finally Blocks - I think finally blocks are awesome!』
正確意思應該是：
『finally 區塊再多也不為過 - 我覺得 finally 區塊實在是棒透了！』
在中譯本的 18-26 頁居然被翻成：
『不能使用太多 finally 區段 - 我認為 finally 區段式可怕的！』
連續兩個句子都譯成相反的意思，而且還有錯字『是』=&amp;gt;『式』。
為了省五百元，買了生平第一本文魁出版的書，現在只想『趕快把內容看完，然後把書丟掉』。
在此向 Jeffrey 表達深深的懺悔。 Jeffrey, Your book is great but Kingsinfo sucks.</description>
    </item>
    
  </channel>
</rss>
